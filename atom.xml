<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行云流水</title>
  
  <subtitle>却也碎碎念念</subtitle>
  <link href="https://weizhimiao.github.io/atom.xml" rel="self"/>
  
  <link href="https://weizhimiao.github.io/"/>
  <updated>2021-10-26T06:53:41.617Z</updated>
  <id>https://weizhimiao.github.io/</id>
  
  <author>
    <name>zhimiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>systemctl 命令完全指南</title>
    <link href="https://weizhimiao.github.io/2017/08/15/systemctl%E5%91%BD%E4%BB%A4%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://weizhimiao.github.io/2017/08/15/systemctl%E5%91%BD%E4%BB%A4%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</id>
    <published>2017-08-15T15:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。</p><p>Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统。</p><p>在Linux生态系统中，Systemd被部署到了大多数的标准Linux发行版中(redhat、CentOS、fedora)，只有为数不多的几个发行版尚未部署。Systemd通常是所有其它守护进程的父进程，但并非总是如此。</p><p><img data-src="/images/systemctl.jpg" alt="使用Systemctl管理Linux服务"></p><p>本文旨在阐明在运行systemd的系统上“如何控制系统和服务”。</p><span id="more"></span><h2 id="Systemd初体验和Systemctl基础"><a href="#Systemd初体验和Systemctl基础" class="headerlink" title="Systemd初体验和Systemctl基础"></a>Systemd初体验和Systemctl基础</h2><h3 id="1-首先检查你的系统中是否安装有systemd并确定当前安装的版本"><a href="#1-首先检查你的系统中是否安装有systemd并确定当前安装的版本" class="headerlink" title="1. 首先检查你的系统中是否安装有systemd并确定当前安装的版本"></a>1. 首先检查你的系统中是否安装有systemd并确定当前安装的版本</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl --version</span>systemd 215+PAM +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ -SECCOMP -APPARMOR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上例中很清楚地表明，我们安装了215版本的systemd。</p><h3 id="2-检查systemd和systemctl的二进制文件和库文件的安装位置"><a href="#2-检查systemd和systemctl的二进制文件和库文件的安装位置" class="headerlink" title="2. 检查systemd和systemctl的二进制文件和库文件的安装位置"></a>2. 检查systemd和systemctl的二进制文件和库文件的安装位置</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># whereis systemd</span>systemd: /usr/lib/systemd /etc/systemd /usr/share/systemd /usr/share/man/man1/systemd.1.gz<span class="token comment" spellcheck="true"># whereis systemctl</span>systemctl: /usr/bin/systemctl /usr/share/man/man1/systemctl.1.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-检查systemd是否运行"><a href="#3-检查systemd是否运行" class="headerlink" title="3. 检查systemd是否运行"></a>3. 检查systemd是否运行</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ps -eaf | grep [s]ystemd</span>root         1     0  0 16:27 ?        00:00:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 23root       444     1  0 16:27 ?        00:00:00 /usr/lib/systemd/systemd-journaldroot       469     1  0 16:27 ?        00:00:00 /usr/lib/systemd/systemd-udevdroot       555     1  0 16:27 ?        00:00:00 /usr/lib/systemd/systemd-loginddbus       556     1  0 16:27 ?        00:00:00 /bin/dbus-daemon --system --address<span class="token operator">=</span>systemd: --nofork --nopidfile --systemd-activation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> <code>systemd</code>是作为父进程（<code>PID=1</code>）运行的。在上面带（<code>-e</code>）参数的<code>ps</code>命令输出中，选择所有进程，（<code>-a</code>）选择除会话前导外的所有进程，并使用（<code>-f</code>）参数输出完整格式列表（即 <code>-eaf</code>）。</p><p>也请注意上例中后随的方括号和例子中剩余部分。方括号表达式是<code>grep</code>的字符类表达式的一部分。</p><h3 id="4-分析systemd启动进程"><a href="#4-分析systemd启动进程" class="headerlink" title="4. 分析systemd启动进程"></a>4. 分析systemd启动进程</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-analyze</span>Startup finished <span class="token keyword">in</span> 487ms <span class="token punctuation">(</span>kernel<span class="token punctuation">)</span> + 2.776s <span class="token punctuation">(</span>initrd<span class="token punctuation">)</span> + 20.229s <span class="token punctuation">(</span>userspace<span class="token punctuation">)</span> <span class="token operator">=</span> 23.493s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-分析启动时各个进程花费的时间"><a href="#5-分析启动时各个进程花费的时间" class="headerlink" title="5. 分析启动时各个进程花费的时间"></a>5. 分析启动时各个进程花费的时间</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-analyze blame</span>8.565s mariadb.service7.991s webmin.service6.095s postfix.service4.311s httpd.service3.926s firewalld.service3.780s kdump.service3.238s tuned.service1.712s network.service1.394s lvm2-monitor.service1.126s systemd-logind.service<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-分析启动时的关键链"><a href="#6-分析启动时的关键链" class="headerlink" title="6. 分析启动时的关键链"></a>6. 分析启动时的关键链</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-analyze critical-chain</span>The <span class="token function">time</span> after the unit is active or started is printed after the <span class="token string">"@"</span> character.The <span class="token function">time</span> the unit takes to start is printed after the <span class="token string">"+"</span> character.multi-user.target @20.222s└─mariadb.service @11.657s +8.565s  └─network.target @11.168s    └─network.service @9.456s +1.712s      └─NetworkManager.service @8.858s +596ms        └─firewalld.service @4.931s +3.926s          └─basic.target @4.916s            └─sockets.target @4.916s              └─dbus.socket @4.916s                └─sysinit.target @4.905s                  └─systemd-update-utmp.service @4.864s +39ms                    └─auditd.service @4.563s +301ms                      └─systemd-tmpfiles-setup.service @4.485s +69ms                        └─rhel-import-state.service @4.342s +142ms                          └─local-fs.target @4.324s                            └─boot.mount @4.286s +31ms                              └─systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d19608096                                └─dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重要：</strong> Systemctl接受服务（<code>.service</code>），挂载点（<code>.mount</code>），套接口（<code>.socket</code>）和设备（<code>.device</code>）作为单元。                            </p><h3 id="7-列出所有可用单元"><a href="#7-列出所有可用单元" class="headerlink" title="7. 列出所有可用单元"></a>7. 列出所有可用单元</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-unit-files</span>UNIT FILE                                   STATE   proc-sys-fs-binfmt_misc.automount           static  dev-hugepages.mount                         static  dev-mqueue.mount                            static  proc-sys-fs-binfmt_misc.mount               static  sys-fs-fuse-connections.mount               static  sys-kernel-config.mount                     static  sys-kernel-debug.mount                      static  tmp.mount                                   disabledbrandbot.path                               disabled<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-列出所有运行中单元"><a href="#8-列出所有运行中单元" class="headerlink" title="8. 列出所有运行中单元"></a>8. 列出所有运行中单元</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-units</span>UNIT                                        LOAD   ACTIVE SUB       DESCRIPTIONproc-sys-fs-binfmt_misc.automount           loaded active waiting   Arbitrary Executable File Formats File Systesys-devices-pc<span class="token punctuation">..</span>.0-1:0:0:0-block-sr0.device loaded active plugged   VBOX_CD-ROMsys-devices-pc<span class="token punctuation">..</span>.:00:03.0-net-enp0s3.device loaded active plugged   PRO/1000 MT Desktop Adaptersys-devices-pc<span class="token punctuation">..</span>.00:05.0-sound-card0.device loaded active plugged   82801AA AC\'97 Audio Controllersys-devices-pc<span class="token punctuation">..</span>.:0:0-block-sda-sda1.device loaded active plugged   VBOX_HARDDISKsys-devices-pc<span class="token punctuation">..</span>.:0:0-block-sda-sda2.device loaded active plugged   LVM PV Qzyo3l-qYaL-uRUa-Cjuk-pljo-qKtX-VgBQ8sys-devices-pc<span class="token punctuation">..</span>.0-2:0:0:0-block-sda.device loaded active plugged   VBOX_HARDDISKsys-devices-pl<span class="token punctuation">..</span>.erial8250-tty-ttyS0.device loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS0sys-devices-pl<span class="token punctuation">..</span>.erial8250-tty-ttyS1.device loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS1sys-devices-pl<span class="token punctuation">..</span>.erial8250-tty-ttyS2.device loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS2sys-devices-pl<span class="token punctuation">..</span>.erial8250-tty-ttyS3.device loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS3sys-devices-virtual-block-dm\x2d0.device    loaded active plugged   /sys/devices/virtual/block/dm-0sys-devices-virtual-block-dm\x2d1.device    loaded active plugged   /sys/devices/virtual/block/dm-1sys-module-configfs.device                  loaded active plugged   /sys/module/configfs<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-列出所有失败单元"><a href="#9-列出所有失败单元" class="headerlink" title="9. 列出所有失败单元"></a>9. 列出所有失败单元</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl --failed</span>UNIT          LOAD   ACTIVE SUB    DESCRIPTIONkdump.service loaded failed failed Crash recovery kernel armingLOAD   <span class="token operator">=</span> Reflects whether the unit definition was properly loaded.ACTIVE <span class="token operator">=</span> The high-level unit activation state, i.e. generalization of SUB.SUB    <span class="token operator">=</span> The low-level unit activation state, values depend on unit type.1 loaded <span class="token function">units</span> listed. Pass --all to see loaded but inactive units, too.To show all installed unit files use \'systemctl list-unit-files\'.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-检查某个单元（如-cron-service）是否启用"><a href="#10-检查某个单元（如-cron-service）是否启用" class="headerlink" title="10. 检查某个单元（如 cron.service）是否启用"></a>10. 检查某个单元（如 cron.service）是否启用</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl is-enabled crond.service</span>enabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="11-检查某个单元或服务是否运行"><a href="#11-检查某个单元或服务是否运行" class="headerlink" title="11. 检查某个单元或服务是否运行"></a>11. 检查某个单元或服务是否运行</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl status firewalld.service</span>firewalld.service - firewalld - dynamic firewall daemon   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/firewalld.service<span class="token punctuation">;</span> enabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Tue 2015-04-28 16:27:55 IST<span class="token punctuation">;</span> 34min ago Main PID: 549 <span class="token punctuation">(</span>firewalld<span class="token punctuation">)</span>   CGroup: /system.slice/firewalld.service           └─549 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopidApr 28 16:27:51 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Starting firewalld - dynamic firewall daemon<span class="token punctuation">..</span>.Apr 28 16:27:55 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Started firewalld - dynamic firewall daemon.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Systemctl控制并管理服务"><a href="#使用Systemctl控制并管理服务" class="headerlink" title="使用Systemctl控制并管理服务"></a>使用Systemctl控制并管理服务</h2><h3 id="12-列出所有服务（包括启用的和禁用的）"><a href="#12-列出所有服务（包括启用的和禁用的）" class="headerlink" title="12. 列出所有服务（包括启用的和禁用的）"></a>12. 列出所有服务（包括启用的和禁用的）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-unit-files --type=service</span>UNIT FILE                                   STATE   arp-ethers.service                          disabledauditd.service                              enabledautovt@.service                             disabledblk-availability.service                    disabledbrandbot.service                            static  collectd.service                            disabledconsole-getty.service                       disabledconsole-shell.service                       disabledcpupower.service                            disabledcrond.service                               enableddbus-org.fedoraproject.FirewallD1.service   enabled<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-Linux中如何启动、重启、停止、重载服务以及检查服务（如-httpd-service）状态"><a href="#13-Linux中如何启动、重启、停止、重载服务以及检查服务（如-httpd-service）状态" class="headerlink" title="13. Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态"></a>13. Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl start httpd.service</span><span class="token comment" spellcheck="true"># systemctl restart httpd.service</span><span class="token comment" spellcheck="true"># systemctl stop httpd.service</span><span class="token comment" spellcheck="true"># systemctl reload httpd.service</span><span class="token comment" spellcheck="true"># systemctl status httpd.service</span>httpd.service - The Apache HTTP Server   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/httpd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Tue 2015-04-28 17:21:30 IST<span class="token punctuation">;</span> 6s ago  Process: 2876 ExecStop<span class="token operator">=</span>/bin/kill -WINCH $<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;MAINPID&amp;#125; (code=exited, status=0/SUCCESS)</span> Main PID: 2881 <span class="token punctuation">(</span>httpd<span class="token punctuation">)</span>   Status: <span class="token string">"Processing requests..."</span>   CGroup: /system.slice/httpd.service           ├─2881 /usr/sbin/httpd -DFOREGROUND           ├─2884 /usr/sbin/httpd -DFOREGROUND           ├─2885 /usr/sbin/httpd -DFOREGROUND           ├─2886 /usr/sbin/httpd -DFOREGROUND           ├─2887 /usr/sbin/httpd -DFOREGROUND           └─2888 /usr/sbin/httpd -DFOREGROUNDApr 28 17:21:30 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Starting The Apache HTTP Server<span class="token punctuation">..</span>.Apr 28 17:21:30 tecmint httpd<span class="token punctuation">[</span>2881<span class="token punctuation">]</span>: AH00558: httpd: Could not reliably determine the server\'s fully q<span class="token punctuation">..</span>.ssageApr 28 17:21:30 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Started The Apache HTTP Server.Hint: Some lines were ellipsized, use -l to show <span class="token keyword">in</span> full.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 当我们使用systemctl的start，restart，stop和reload命令时，我们不会从终端获取到任何输出内容，只有status命令可以打印输出。</p><h3 id="14-如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）"><a href="#14-如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）" class="headerlink" title="14. 如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）"></a>14. 如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl is-active httpd.service</span><span class="token comment" spellcheck="true"># systemctl enable httpd.service</span><span class="token comment" spellcheck="true"># systemctl disable httpd.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="15-如何屏蔽（让它不能启动）或显示服务（如-httpd-service）"><a href="#15-如何屏蔽（让它不能启动）或显示服务（如-httpd-service）" class="headerlink" title="15. 如何屏蔽（让它不能启动）或显示服务（如 httpd.service）"></a>15. 如何屏蔽（让它不能启动）或显示服务（如 httpd.service）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl mask httpd.service</span><span class="token function">ln</span> -s <span class="token string">'/dev/null'</span> <span class="token string">'/etc/systemd/system/httpd.service'</span><span class="token comment" spellcheck="true"># systemctl unmask httpd.service</span><span class="token function">rm</span> <span class="token string">'/etc/systemd/system/httpd.service'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="16-使用systemctl命令杀死服务"><a href="#16-使用systemctl命令杀死服务" class="headerlink" title="16. 使用systemctl命令杀死服务"></a>16. 使用systemctl命令杀死服务</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl kill httpd</span><span class="token comment" spellcheck="true"># systemctl status httpd</span>httpd.service - The Apache HTTP Server   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/httpd.service<span class="token punctuation">;</span> enabled<span class="token punctuation">)</span>   Active: failed <span class="token punctuation">(</span>Result: exit-code<span class="token punctuation">)</span> since Tue 2015-04-28 18:01:42 IST<span class="token punctuation">;</span> 28min ago Main PID: 2881 <span class="token punctuation">(</span>code<span class="token operator">=</span>exited, status<span class="token operator">=</span>0/SUCCESS<span class="token punctuation">)</span>   Status: <span class="token string">"Total requests: 0; Current requests/sec: 0; Current traffic:   0 B/sec"</span>Apr 28 17:37:29 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:29 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:39 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:39 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:49 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:49 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:59 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 17:37:59 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: Got notification message from PID 2881, but recepti<span class="token punctuation">..</span>.bled.Apr 28 18:01:42 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: httpd.service: control process exited, code<span class="token operator">=</span>exited status<span class="token operator">=</span>226Apr 28 18:01:42 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Unit httpd.service entered failed state.Hint: Some lines were ellipsized, use -l to show <span class="token keyword">in</span> full.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Systemctl控制并管理挂载点"><a href="#使用Systemctl控制并管理挂载点" class="headerlink" title="使用Systemctl控制并管理挂载点"></a>使用Systemctl控制并管理挂载点</h2><h3 id="17-列出所有系统挂载点"><a href="#17-列出所有系统挂载点" class="headerlink" title="17. 列出所有系统挂载点"></a>17. 列出所有系统挂载点</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-unit-files --type=mount</span>UNIT FILE                     STATE   dev-hugepages.mount           static  dev-mqueue.mount              static  proc-sys-fs-binfmt_misc.mount static  sys-fs-fuse-connections.mount static  sys-kernel-config.mount       static  sys-kernel-debug.mount        static  tmp.mount                     disabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="18-挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态"><a href="#18-挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态" class="headerlink" title="18. 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态"></a>18. 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl start tmp.mount</span><span class="token comment" spellcheck="true"># systemctl stop tmp.mount</span><span class="token comment" spellcheck="true"># systemctl restart tmp.mount</span><span class="token comment" spellcheck="true"># systemctl reload tmp.mount</span><span class="token comment" spellcheck="true"># systemctl status tmp.mount</span>tmp.mount - Temporary Directory   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/tmp.mount<span class="token punctuation">;</span> disabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>mounted<span class="token punctuation">)</span> since Tue 2015-04-28 17:46:06 IST<span class="token punctuation">;</span> 2min 48s ago    Where: /tmp     What: tmpfs     Docs: man:hier<span class="token punctuation">(</span>7<span class="token punctuation">)</span>http://www.freedesktop.org/wiki/Software/systemd/APIFileSystems  Process: 3908 ExecMount<span class="token operator">=</span>/bin/mount tmpfs /tmp -t tmpfs -o mode<span class="token operator">=</span>1777,strictatime <span class="token punctuation">(</span>code<span class="token operator">=</span>exited, status<span class="token operator">=</span>0/SUCCESS<span class="token punctuation">)</span>Apr 28 17:46:06 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Mounting Temporary Directory<span class="token punctuation">..</span>.Apr 28 17:46:06 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: tmp.mount: Directory /tmp to <span class="token function">mount</span> over is not empty, mounting anyway.Apr 28 17:46:06 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Mounted Temporary Directory.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="19-在启动时激活、启用或禁用挂载点（系统启动时自动挂载）"><a href="#19-在启动时激活、启用或禁用挂载点（系统启动时自动挂载）" class="headerlink" title="19. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载）"></a>19. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl is-active tmp.mount</span><span class="token comment" spellcheck="true"># systemctl enable tmp.mount</span><span class="token comment" spellcheck="true"># systemctl disable  tmp.mount</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="20-在Linux中屏蔽（让它不能启用）或可见挂载点"><a href="#20-在Linux中屏蔽（让它不能启用）或可见挂载点" class="headerlink" title="20. 在Linux中屏蔽（让它不能启用）或可见挂载点"></a>20. 在Linux中屏蔽（让它不能启用）或可见挂载点</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl mask tmp.mount</span><span class="token function">ln</span> -s <span class="token string">'/dev/null'</span> <span class="token string">'/etc/systemd/system/tmp.mount'</span><span class="token comment" spellcheck="true"># systemctl unmask tmp.mount</span><span class="token function">rm</span> <span class="token string">'/etc/systemd/system/tmp.mount'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Systemctl控制并管理套接口"><a href="#使用Systemctl控制并管理套接口" class="headerlink" title="使用Systemctl控制并管理套接口"></a>使用Systemctl控制并管理套接口</h2><h3 id="21-列出所有可用系统套接口"><a href="#21-列出所有可用系统套接口" class="headerlink" title="21. 列出所有可用系统套接口"></a>21. 列出所有可用系统套接口</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-unit-files --type=socket</span>UNIT FILE                    STATE   dbus.socket                  static  dm-event.socket              enabledlvm2-lvmetad.socket          enabledrsyncd.socket                disabledsshd.socket                  disabledsyslog.socket                static  systemd-initctl.socket       static  systemd-journald.socket      static  systemd-shutdownd.socket     static  systemd-udevd-control.socket static  systemd-udevd-kernel.socket  static  11 unit files listed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22-在Linux中启动、重启、停止、重载套接口并检查其状态"><a href="#22-在Linux中启动、重启、停止、重载套接口并检查其状态" class="headerlink" title="22. 在Linux中启动、重启、停止、重载套接口并检查其状态"></a>22. 在Linux中启动、重启、停止、重载套接口并检查其状态</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl start cups.socket</span><span class="token comment" spellcheck="true"># systemctl restart cups.socket</span><span class="token comment" spellcheck="true"># systemctl stop cups.socket</span><span class="token comment" spellcheck="true"># systemctl reload cups.socket</span><span class="token comment" spellcheck="true"># systemctl status cups.socket</span>cups.socket - CUPS Printing Service Sockets   Loaded: loaded <span class="token punctuation">(</span>/usr/lib/systemd/system/cups.socket<span class="token punctuation">;</span> enabled<span class="token punctuation">)</span>   Active: active <span class="token punctuation">(</span>listening<span class="token punctuation">)</span> since Tue 2015-04-28 18:10:59 IST<span class="token punctuation">;</span> 8s ago   Listen: /var/run/cups/cups.sock <span class="token punctuation">(</span>Stream<span class="token punctuation">)</span>Apr 28 18:10:59 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Starting CUPS Printing Service Sockets.Apr 28 18:10:59 tecmint systemd<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Listening on CUPS Printing Service Sockets.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23-在启动时激活套接口，并启用或禁用它（系统启动时自启动）"><a href="#23-在启动时激活套接口，并启用或禁用它（系统启动时自启动）" class="headerlink" title="23. 在启动时激活套接口，并启用或禁用它（系统启动时自启动）"></a>23. 在启动时激活套接口，并启用或禁用它（系统启动时自启动）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl is-active cups.socket</span><span class="token comment" spellcheck="true"># systemctl enable cups.socket</span><span class="token comment" spellcheck="true"># systemctl disable cups.socket</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="24-屏蔽（使它不能启动）或显示套接口"><a href="#24-屏蔽（使它不能启动）或显示套接口" class="headerlink" title="24. 屏蔽（使它不能启动）或显示套接口"></a>24. 屏蔽（使它不能启动）或显示套接口</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl mask cups.socket</span><span class="token function">ln</span> -s <span class="token string">'/dev/null'</span> <span class="token string">'/etc/systemd/system/cups.socket'</span><span class="token comment" spellcheck="true"># systemctl unmask cups.socket</span><span class="token function">rm</span> <span class="token string">'/etc/systemd/system/cups.socket'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务的CPU利用率（分配额）"><a href="#服务的CPU利用率（分配额）" class="headerlink" title="服务的CPU利用率（分配额）"></a>服务的CPU利用率（分配额）</h2><h3 id="25-获取当前某个服务的CPU分配额（如httpd）"><a href="#25-获取当前某个服务的CPU分配额（如httpd）" class="headerlink" title="25. 获取当前某个服务的CPU分配额（如httpd）"></a>25. 获取当前某个服务的CPU分配额（如httpd）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl show -p CPUShares httpd.service</span>CPUShares<span class="token operator">=</span>1024<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意：</strong> 各个服务的默认CPU分配份额=1024，你可以增加/减少某个进程的CPU分配份额。</p><h3 id="26-将某个服务（httpd-service）的CPU分配份额限制为2000-CPUShares"><a href="#26-将某个服务（httpd-service）的CPU分配份额限制为2000-CPUShares" class="headerlink" title="26. 将某个服务（httpd.service）的CPU分配份额限制为2000 CPUShares/"></a>26. 将某个服务（httpd.service）的CPU分配份额限制为2000 CPUShares/</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl set-property httpd.service CPUShares=2000</span><span class="token comment" spellcheck="true"># systemctl show -p CPUShares httpd.service</span>CPUShares<span class="token operator">=</span>2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 当你为某个服务设置CPUShares，会自动创建一个以服务名命名的目录（如 httpd.service），里面包含了一个名为90-CPUShares.conf的文件，该文件含有CPUShare限制信息，你可以通过以下方式查看该文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># vi /etc/systemd/system/httpd.service.d/90-CPUShares.conf</span><span class="token punctuation">[</span>Service<span class="token punctuation">]</span>CPUShares<span class="token operator">=</span>2000        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="27-检查某个服务的所有配置细节"><a href="#27-检查某个服务的所有配置细节" class="headerlink" title="27. 检查某个服务的所有配置细节"></a>27. 检查某个服务的所有配置细节</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl show httpd</span>Id<span class="token operator">=</span>httpd.serviceNames<span class="token operator">=</span>httpd.serviceRequires<span class="token operator">=</span>basic.targetWants<span class="token operator">=</span>system.sliceWantedBy<span class="token operator">=</span>multi-user.targetConflicts<span class="token operator">=</span>shutdown.targetBefore<span class="token operator">=</span>shutdown.target multi-user.targetAfter<span class="token operator">=</span>network.target remote-fs.target nss-lookup.target systemd-journald.socket basic.target system.sliceDescription<span class="token operator">=</span>The Apache HTTP ServerLoadState<span class="token operator">=</span>loadedActiveState<span class="token operator">=</span>activeSubState<span class="token operator">=</span>runningFragmentPath<span class="token operator">=</span>/usr/lib/systemd/system/httpd.service<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="28-分析某个服务（httpd）的关键链"><a href="#28-分析某个服务（httpd）的关键链" class="headerlink" title="28. 分析某个服务（httpd）的关键链"></a>28. 分析某个服务（httpd）的关键链</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-analyze critical-chain httpd.service</span>The <span class="token function">time</span> after the unit is active or started is printed after the <span class="token string">"@"</span> character.The <span class="token function">time</span> the unit takes to start is printed after the <span class="token string">"+"</span> character.httpd.service +142ms└─network.target @11.168s  └─network.service @9.456s +1.712s    └─NetworkManager.service @8.858s +596ms      └─firewalld.service @4.931s +3.926s        └─basic.target @4.916s          └─sockets.target @4.916s            └─dbus.socket @4.916s              └─sysinit.target @4.905s                └─systemd-update-utmp.service @4.864s +39ms                  └─auditd.service @4.563s +301ms                    └─systemd-tmpfiles-setup.service @4.485s +69ms                      └─rhel-import-state.service @4.342s +142ms                        └─local-fs.target @4.324s                          └─boot.mount @4.286s +31ms                            └─systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.service @4.092s +149ms                              └─dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4.092s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="29-获取某个服务（httpd）的依赖性列表"><a href="#29-获取某个服务（httpd）的依赖性列表" class="headerlink" title="29. 获取某个服务（httpd）的依赖性列表"></a>29. 获取某个服务（httpd）的依赖性列表</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl list-dependencies httpd.service</span>httpd.service├─system.slice└─basic.target  ├─firewalld.service  ├─microcode.service  ├─rhel-autorelabel-mark.service  ├─rhel-autorelabel.service  ├─rhel-configure.service  ├─rhel-dmesg.service  ├─rhel-loadmodules.service  ├─paths.target  ├─slices.target  │ ├─-.slice  │ └─system.slice  ├─sockets.target  │ ├─dbus.socket<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="30-按等级列出控制组"><a href="#30-按等级列出控制组" class="headerlink" title="30. 按等级列出控制组"></a>30. 按等级列出控制组</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-cgls</span>├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 23├─user.slice│ └─user-0.slice│   └─session-1.scope│     ├─2498 sshd: root@pts/0    │     ├─2500 -bash│     ├─4521 systemd-cgls│     └─4522 systemd-cgls└─system.slice  ├─httpd.service  │ ├─4440 /usr/sbin/httpd -DFOREGROUND  │ ├─4442 /usr/sbin/httpd -DFOREGROUND  │ ├─4443 /usr/sbin/httpd -DFOREGROUND  │ ├─4444 /usr/sbin/httpd -DFOREGROUND  │ ├─4445 /usr/sbin/httpd -DFOREGROUND  │ └─4446 /usr/sbin/httpd -DFOREGROUND  ├─polkit.service  │ └─721 /usr/lib/polkit-1/polkitd --no-debug<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="31-按CPU、内存、输入和输出列出控制组"><a href="#31-按CPU、内存、输入和输出列出控制组" class="headerlink" title="31. 按CPU、内存、输入和输出列出控制组"></a>31. 按CPU、内存、输入和输出列出控制组</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemd-cgtop</span>Path                                                              Tasks   %CPU   Memory  Input/s Output/s/                                                                    83    1.0   437.8M        -        -/system.slice                                                         -    0.1        -        -        -/system.slice/mariadb.service                                         2    0.1        -        -        -/system.slice/tuned.service                                           1    0.0        -        -        -/system.slice/httpd.service                                           6    0.0        -        -        -/system.slice/NetworkManager.service                                  1      -        -        -        -/system.slice/atop.service                                            1      -        -        -        -/system.slice/atopacct.service                                        1      -        -        -        -/system.slice/auditd.service                                          1      -        -        -        -/system.slice/crond.service                                           1      -        -        -        -/system.slice/dbus.service                                            1      -        -        -        -/system.slice/firewalld.service                                       1      -        -        -        -/system.slice/lvm2-lvmetad.service                                    1      -        -        -        -/system.slice/polkit.service                                          1      -        -        -        -/system.slice/postfix.service                                         3      -        -        -        -/system.slice/rsyslog.service                                         1      -        -        -        -/system.slice/system-getty.slice/getty@tty1.service                   1      -        -        -        -/system.slice/systemd-journald.service                                1      -        -        -        -/system.slice/systemd-logind.service                                  1      -        -        -        -/system.slice/systemd-udevd.service                                   1      -        -        -        -/system.slice/webmin.service                                          1      -        -        -        -/user.slice/user-0.slice/session-1.scope                              3      -        -        -        -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="控制系统运行等级"><a href="#控制系统运行等级" class="headerlink" title="控制系统运行等级"></a>控制系统运行等级</h2><h3 id="32-启动系统救援模式"><a href="#32-启动系统救援模式" class="headerlink" title="32. 启动系统救援模式"></a>32. 启动系统救援模式</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl rescue</span>Broadcast message from root@tecmint on pts/0 <span class="token punctuation">(</span>Wed 2015-04-29 11:31:18 IST<span class="token punctuation">)</span>:The system is going down to rescue mode NOW<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="33-进入紧急模式"><a href="#33-进入紧急模式" class="headerlink" title="33. 进入紧急模式"></a>33. 进入紧急模式</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl emergency</span>Welcome to emergency mode<span class="token operator">!</span> After logging in, <span class="token function">type</span> <span class="token string">"journalctl -xb"</span> to viewsystem logs, <span class="token string">"systemctl reboot"</span> to reboot, <span class="token string">"systemctl default"</span> to try againto boot into default mode.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="34-列出当前使用的运行等级"><a href="#34-列出当前使用的运行等级" class="headerlink" title="34. 列出当前使用的运行等级"></a>34. 列出当前使用的运行等级</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl get-default</span>multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="35-启动运行等级5，即图形模式"><a href="#35-启动运行等级5，即图形模式" class="headerlink" title="35. 启动运行等级5，即图形模式"></a>35. 启动运行等级5，即图形模式</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl isolate runlevel5.target</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl isolate graphical.target</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="36-启动运行等级3，即多用户模式（命令行）"><a href="#36-启动运行等级3，即多用户模式（命令行）" class="headerlink" title="36. 启动运行等级3，即多用户模式（命令行）"></a>36. 启动运行等级3，即多用户模式（命令行）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl isolate runlevel3.target</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl isolate multiuser.target</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="37-设置多用户模式或图形模式为默认运行等级"><a href="#37-设置多用户模式或图形模式为默认运行等级" class="headerlink" title="37. 设置多用户模式或图形模式为默认运行等级"></a>37. 设置多用户模式或图形模式为默认运行等级</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl set-default runlevel3.target</span><span class="token comment" spellcheck="true"># systemctl set-default runlevel5.target</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="38-重启、停止、挂起、休眠系统或使系统进入混合睡眠"><a href="#38-重启、停止、挂起、休眠系统或使系统进入混合睡眠" class="headerlink" title="38. 重启、停止、挂起、休眠系统或使系统进入混合睡眠"></a>38. 重启、停止、挂起、休眠系统或使系统进入混合睡眠</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># systemctl reboot</span><span class="token comment" spellcheck="true"># systemctl halt</span><span class="token comment" spellcheck="true"># systemctl suspend</span><span class="token comment" spellcheck="true"># systemctl hibernate</span><span class="token comment" spellcheck="true"># systemctl hybrid-sleep</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不知运行等级为何物的人，说明如下。</p><ul><li>Runlevel 0 : 关闭系统</li><li>Runlevel 1 : 救援？维护模式</li><li>Runlevel 3 : 多用户，无图形系统</li><li>Runlevel 4 : 多用户，无图形系统</li><li>Runlevel 5 : 多用户，图形化系统</li><li>Runlevel 6 : 关闭并重启机器</li></ul><p>到此为止吧。保持连线，进行评论。别忘了在下面的评论中为我们提供一些有价值的反馈哦。喜欢我们、与我们分享，求扩散。</p><pre><code>译自: http://www.tecmint.com/manage-services-using-systemd-and-systemctl-in-linux/转自: https://linux.cn/article-5926-1.html作者: Avishek Kumar译者: GOLinux</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。&lt;/p&gt;
&lt;p&gt;Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统。&lt;/p&gt;
&lt;p&gt;在Linux生态系统中，Systemd被部署到了大多数的标准Linux发行版中(redhat、CentOS、fedora)，只有为数不多的几个发行版尚未部署。Systemd通常是所有其它守护进程的父进程，但并非总是如此。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/systemctl.jpg&quot; alt=&quot;使用Systemctl管理Linux服务&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文旨在阐明在运行systemd的系统上“如何控制系统和服务”。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="systemctl" scheme="https://weizhimiao.github.io/tags/systemctl/"/>
    
  </entry>
  
  <entry>
    <title>利用ELK搭建自己的日志分析系统</title>
    <link href="https://weizhimiao.github.io/2017/04/23/%E5%88%A9%E7%94%A8ELK%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://weizhimiao.github.io/2017/04/23/%E5%88%A9%E7%94%A8ELK%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2017-04-23T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>不管是用于记录，监控或者程序的Debug，日志，对于任何系统来说都是一个及其重要的部分。但一般日志的数据量会比较大，并且分散在各个地方。如果管理的服务器或者程序比较少的情况我们还可以逐一登录到各个服务器去查看，分析。但如果服务器或者程序的数量比较多了之后这种方法就显得力不从心。基于此，一些集中式的日志系统也就应用而生。<br>目前比较有名成熟的有，Splunk(商业)、FaceBook 的Scribe、Apache 的 Chukwa<br>Cloudera 的 Fluentd、还有ELK 等等。</p><span id="more"></span><h2 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h2><p>ELK不是一款软件，是三个软件产品的首字母缩写，Elasticsearch，Logstash 和 Kibana。这三款软件都是开源的，现在归于 Elastic.co 公司。</p><center>![ELK协议栈](https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/img001.png)</center><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。作为ELK协议栈的核心，它用于集中存储数据。目前，最新最新的版本是 5.3。</p><p>特点：</p><ul><li>实时（准实时）</li><li>分布式</li><li>面向文档</li><li>高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。</li><li>接口友好（RESTful）</li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。目前最新的版本是 5.3。</p><p>特点</p><ul><li>几乎可以访问任何数据</li><li>可以和多种外部应用结合</li><li>支持弹性扩展</li></ul><center>![logstash](https://static-www.elastic.co/assets/blt8a9ac25aedbd9ca7/logstash-img1.png?q=414)</center><p>组成部分</p><ul><li>INPUTS, 从各种地方获取各种数据数据</li><li>FILTERS, 过滤处理获取到的数据</li><li>OUTPUTS, 将处理完的数据输出到指定地方（消息队列，或者 ElasticSearch中）</li></ul><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。目前最新的版本是 5.3。</p><h2 id="ELK-日志分析系统的搭建"><a href="#ELK-日志分析系统的搭建" class="headerlink" title="ELK 日志分析系统的搭建"></a>ELK 日志分析系统的搭建</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="服务器配置："><a href="#服务器配置：" class="headerlink" title="服务器配置："></a>服务器配置：</h4><ul><li>系统：CentOS 7.3 64</li><li>配置：CPU：2核 内存：4G</li><li>实例<ul><li>10.47.45.66(内)</li><li>10.30.70.120(内)</li><li>10.47.45.32(内)</li></ul></li></ul><h4 id="用到的软件或文件"><a href="#用到的软件或文件" class="headerlink" title="用到的软件或文件"></a>用到的软件或文件</h4><ul><li>JDK 8 （jdk-8u131-linux-x64.tar.gz）</li><li>elasticsearch(<a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.0.zip">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.0.zip</a>)</li><li>kibana(<a href="https://artifacts.elastic.co/downloads/kibana/kibana-5.3.0-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-5.3.0-linux-x86_64.tar.gz</a>)</li><li>x-pack (<a href="https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.3.0ll.zip">https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.3.0ll.zip</a>)</li><li>logstash(<a href="https://artifacts.elastic.co/downloads/logstash/logstash-5.3.0.zip">https://artifacts.elastic.co/downloads/logstash/logstash-5.3.0.zip</a>)</li><li>Nginx</li><li>metricbeat(<a href="https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-5.3.1-x86_64.rpm">https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-5.3.1-x86_64.rpm</a>)</li></ul><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><center>![ELK日志系统架构图](http://wx4.sinaimg.cn/mw690/8e242e12ly1fevtki0lwkj20xc0gota6.jpg)</center><blockquote><p>这里将会用三台服务器来模拟一个简单的集群环境</p></blockquote><p>ElasticSearch集群</p><ul><li>服务器节点<ul><li>【主节点】10.47.45.66(内)</li><li>【数据节点】10.30.70.120(内)</li><li>【数据节点】10.47.45.32(内)</li></ul></li><li>将要安装的软件或插件<ul><li>ElasticSearch</li><li>ElasticSearch x-pack插件</li></ul></li></ul><p>Kibana</p><ul><li>服务器节点<ul><li>10.47.45.66(内)</li></ul></li><li>将要安装的软件或插件<ul><li>Nginx（提供前端代理）</li><li>Kibana（提供Kibana UI）</li><li>Kibana x-pack插件</li></ul></li></ul><p>Logstash</p><ul><li>服务器节点<ul><li>10.47.45.32(内)</li></ul></li><li>将要安装的软件或插件<ul><li>Apache(模拟产生访问日志)</li><li>Logstash</li><li>beats</li></ul></li></ul><h3 id="具体安装与配置过程"><a href="#具体安装与配置过程" class="headerlink" title="具体安装与配置过程"></a>具体安装与配置过程</h3><ol><li>JDK（所有节点）的安装与配置</li><li>ElasticSearch 的安装与配置</li><li>Kibana 的安装与配置</li><li>Nginx 的安装与配置</li><li>Logstash 的安装与配置</li><li>Apache、beats 的安装与配置</li><li>验证</li></ol><h4 id="JDK-8-的安装与配置"><a href="#JDK-8-的安装与配置" class="headerlink" title="JDK 8 的安装与配置"></a>JDK 8 的安装与配置</h4><blockquote><p>安装范围：所有节点</p></blockquote><p>Elasticsearch 5.3对Java的版本至少是 Java 8.<br>查看当前的Java 版本,及 JAVA_HOME 环境变量的设置：</p><pre class="line-numbers language-sh"><code class="language-sh">java -versionecho $JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果没有安装，或版本不满足，则需要安装并配置</p><p>下载解压</p><pre class="line-numbers language-sh"><code class="language-sh">wget http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1492857236_f012353e60ed757db930682d071feefc -O jdk-8u131-linux-x64.tar.gztar -zxf jdk-8u131-linux-x64.tar.gzmv jdk1.8.0_131 /usr/local/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置环境变量</p><pre class="line-numbers language-sh"><code class="language-sh">vi /etc/bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件底部追加下面两行</p><pre class="line-numbers language-sh"><code class="language-sh">export JAVA_HOME=/usr/local/jdk1.8.0_131export PATH=$PATH:$JAVA_HOME/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载，使之生效</p><pre class="line-numbers language-sh"><code class="language-sh">source /etc/bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-sh"><code class="language-sh">java -versionjava version "1.8.0_131"Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)echo $JAVA_HOME/usr/local/jdk1.8.0_131<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ElasticSearch-的安装与配置"><a href="#ElasticSearch-的安装与配置" class="headerlink" title="ElasticSearch 的安装与配置"></a>ElasticSearch 的安装与配置</h4><blockquote><p>在三台ElasticSearch节点上分别安装，并按照节点的类型，分别修改相应配置</p></blockquote><h5 id="下载并解压-Elasticsearch"><a href="#下载并解压-Elasticsearch" class="headerlink" title="下载并解压 Elasticsearch"></a>下载并解压 Elasticsearch</h5><pre class="line-numbers language-sh"><code class="language-sh">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.3.0.zipunzip elasticsearch-5.3.0.zipmv elasticsearch-5.3.0 /usr/local/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Elasticsearch 的目录结构如下：</p><pre class="line-numbers language-sh"><code class="language-sh">.├── bin│   ├── elasticsearch│   ├── elasticsearch.bat│   ├── elasticsearch.in.bat│   ├── elasticsearch.in.sh│   ├── elasticsearch-keystore│   ├── elasticsearch-keystore.bat│   ├── elasticsearch-plugin│   ├── elasticsearch-plugin.bat│   ├── elasticsearch-service.bat│   ├── elasticsearch-service-mgr.exe│   ├── elasticsearch-service-x64.exe│   ├── elasticsearch-service-x86.exe│   ├── elasticsearch-systemd-pre-exec│   ├── elasticsearch-translog│   └── elasticsearch-translog.bat├── config│   ├── elasticsearch.yml│   ├── jvm.options│   └── log4j2.properties├── lib│   ├── elasticsearch-5.3.0.jar│   ├── HdrHistogram-2.1.6.jar│   ├── hppc-0.7.1.jar│   ├── jackson-core-2.8.6.jar│   ├── jackson-dataformat-cbor-2.8.6.jar│   ├── jackson-dataformat-smile-2.8.6.jar│   ├── jackson-dataformat-yaml-2.8.6.jar│   ├── java-version-checker-5.3.0.jar│   ├── jna-4.2.2.jar│   ├── joda-time-2.9.5.jar│   ├── jopt-simple-5.0.2.jar│   ├── jts-1.13.jar│   ├── log4j-1.2-api-2.7.jar│   ├── log4j-api-2.7.jar│   ├── log4j-core-2.7.jar│   ├── lucene-analyzers-common-6.4.1.jar│   ├── lucene-backward-codecs-6.4.1.jar│   ├── lucene-core-6.4.1.jar│   ├── lucene-grouping-6.4.1.jar│   ├── lucene-highlighter-6.4.1.jar│   ├── lucene-join-6.4.1.jar│   ├── lucene-memory-6.4.1.jar│   ├── lucene-misc-6.4.1.jar│   ├── lucene-queries-6.4.1.jar│   ├── lucene-queryparser-6.4.1.jar│   ├── lucene-sandbox-6.4.1.jar│   ├── lucene-spatial3d-6.4.1.jar│   ├── lucene-spatial-6.4.1.jar│   ├── lucene-spatial-extras-6.4.1.jar│   ├── lucene-suggest-6.4.1.jar│   ├── securesm-1.1.jar│   ├── snakeyaml-1.15.jar│   ├── spatial4j-0.6.jar│   └── t-digest-3.0.jar├── LICENSE.txt├── modules│   ├── aggs-matrix-stats│   ├── ingest-common│   ├── lang-expression│   ├── lang-groovy│   ├── lang-mustache│   ├── lang-painless│   ├── percolator│   ├── reindex│   ├── transport-netty3│   └── transport-netty4├── NOTICE.txt├── plugins└── README.textile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>ElasticSearch默认有三个配置文件：</p><pre class="line-numbers language-sh"><code class="language-sh">config/├── elasticsearch.yml # 基本配置├── jvm.options       # java虚拟机的相关配置└── log4j2.properties # 日志相关配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>elasticsearch了配置文件示例</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># ======================== Elasticsearch Configuration =========================</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># NOTE: Elasticsearch comes with reasonable defaults for most settings.</span><span class="token comment" spellcheck="true">#       Before you set out to tweak and tune the configuration, make sure you</span><span class="token comment" spellcheck="true">#       understand what are you trying to accomplish and the consequences.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The primary way of configuring a node is via this file. This template lists</span><span class="token comment" spellcheck="true"># the most important settings you may want to configure for a production cluster.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Please consult the documentation for further information on configuration options:</span><span class="token comment" spellcheck="true"># https://www.elastic.co/guide/en/elasticsearch/reference/index.html</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ---------------------------------- Cluster -----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Use a descriptive name for your cluster:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#cluster.name: my-application</span><span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> zhimiao<span class="token punctuation">-</span>app<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ------------------------------------ Node ------------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Use a descriptive name for the node:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#node.name: node-1</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Add custom attributes to the node:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#node.attr.rack: r1</span><span class="token comment" spellcheck="true">#</span><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true"># ----------------------------------- Paths ------------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Path to directory where to store the data (separate multiple locations by comma):</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#path.data: /path/to/data</span><span class="token key atrule">path.data</span><span class="token punctuation">:</span> /data/elasticData<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Path to log files:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#path.logs: /path/to/logs</span><span class="token key atrule">path.logs</span><span class="token punctuation">:</span> /data/logs<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ----------------------------------- Memory -----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Lock the memory on startup:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#bootstrap.memory_lock: true</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Make sure that the heap size is set to about half the memory available</span><span class="token comment" spellcheck="true"># on the system and that the owner of the process is allowed to use this</span><span class="token comment" spellcheck="true"># limit.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Elasticsearch performs poorly when the system is swapping the memory.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ---------------------------------- Network -----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Set the bind address to a specific IP (IPv4 or IPv6):</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#network.host: 192.168.0.1</span><span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0<span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Set a custom port for HTTP:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#http.port: 9200</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># For more information, consult the network module documentation.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># --------------------------------- Discovery ----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Pass an initial list of hosts to perform discovery when new node is started:</span><span class="token comment" spellcheck="true"># The default list of hosts is ["127.0.0.1", "[::1]"]</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#discovery.zen.ping.unicast.hosts: ["host1", "host2"]</span><span class="token key atrule">discovery.zen.ping.unicast.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"10.47.45.66"</span><span class="token punctuation">,</span> <span class="token string">"10.30.70.120"</span><span class="token punctuation">,</span><span class="token string">"10.47.45.32"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Prevent the "split brain" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#discovery.zen.minimum_master_nodes: 3</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># For more information, consult the zen discovery module documentation.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ---------------------------------- Gateway -----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Block initial recovery after a full cluster restart until N nodes are started:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#gateway.recover_after_nodes: 3</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># For more information, consult the gateway module documentation.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># ---------------------------------- Various -----------------------------------</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Require explicit names when deleting indices:</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#action.destructive_requires_name: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于配置的几点简单说明</p><ul><li>cluster.name ，集群的名称标识将会被用于群集的自动发现。如果在同一个网络上的正在运行多个群集，则需要确保该集群的所有节点上使用的是相同的名称。</li><li>node.master ，允许此节点可以作为主节点（默认启用）。</li><li>node.data ， 允许此节点可以用来存储数据（默认启用）。</li><li>path.data ， 索引数据存储的路径，可以配置多个位置</li><li>path.logs ， 日志文件路径</li><li>discovery.zen.ping.unicast.hosts ， 集群的初始清单</li></ul><p>ElasticSearch 集群角色规划</p><ul><li><p>如果想让这个节点只能作为ElasticSearch集群的主节点，而不存储数据，则应该这样配置。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果希望这个节点只作为数据节点，而不会成为主节点，则应该这样配置。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果希望这个节点既不是不是主节点，又不是数据节点，而是充当“搜索负载平衡器”（取从节点的数据，聚集结果等），则可以这样配置。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="安装x-pack插件"><a href="#安装x-pack插件" class="headerlink" title="安装x-pack插件"></a>安装x-pack插件</h5><pre class="line-numbers language-sh"><code class="language-sh">$ sudo /usr/local/elasticsearch-5.3.0/bin/elasticsearch-plugin  install x-pack [=================================================] 100%  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     WARNING: plugin requires additional permissions     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@* java.lang.RuntimePermission accessClassInPackage.com.sun.activation.registries* java.lang.RuntimePermission getClassLoader* java.lang.RuntimePermission setContextClassLoader* java.lang.RuntimePermission setFactory* java.security.SecurityPermission createPolicy.JavaPolicy* java.security.SecurityPermission getPolicy* java.security.SecurityPermission putProviderProperty.BC* java.security.SecurityPermission setPolicy* java.util.PropertyPermission * read,write* java.util.PropertyPermission sun.nio.ch.bugLevel write* javax.net.ssl.SSLPermission setHostnameVerifierSee http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.htmlfor descriptions of what these permissions allow and the associated risks.Continue with installation? [y/N]y-> Installed x-pack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>x-pack插件的安装需要在线下载安装包，所以对于网络环境比较差或者一些离线的服务器，可以离线下载 x-pack 安装包，来手动指定。</p><pre class="line-numbers language-sh"><code class="language-sh">$ wget  https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.3.0ll.zip$ sudo /usr/local/elasticsearch-5.3.0/bin/elasticsearch-plugin  install file:///home/datanode/x-pack-5.3.0.zip-> Downloading file:///root/x-pack-5.3.0.zip[=================================================] 100%  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     WARNING: plugin requires additional permissions     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@* java.lang.RuntimePermission accessClassInPackage.com.sun.activation.registries* java.lang.RuntimePermission getClassLoader* java.lang.RuntimePermission setContextClassLoader* java.lang.RuntimePermission setFactory* java.security.SecurityPermission createPolicy.JavaPolicy* java.security.SecurityPermission getPolicy* java.security.SecurityPermission putProviderProperty.BC* java.security.SecurityPermission setPolicy* java.util.PropertyPermission * read,write* java.util.PropertyPermission sun.nio.ch.bugLevel write* javax.net.ssl.SSLPermission setHostnameVerifierSee http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.htmlfor descriptions of what these permissions allow and the associated risks.Continue with installation? [y/N]y-> Installed x-pack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre class="line-numbers language-sh"><code class="language-sh">$ /usr/local/elasticsearch-5.3.0/bin/elasticsearch -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><ol><li><p>查看端口</p><pre class="line-numbers language-sh"><code class="language-sh">$ netstat -tlunActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0      0 127.0.0.1:9200          0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:9300          0.0.0.0:*               LISTEN     tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     udp        0      0 47.90.15.84:123         0.0.0.0:*                          udp        0      0 10.27.46.180:123        0.0.0.0:*                          udp        0      0 127.0.0.1:123           0.0.0.0:*                          udp        0      0 0.0.0.0:123             0.0.0.0:*                          udp6       0      0 :::123                  :::*      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用REST API</p><blockquote><p>由于我们已经安装x-pack，所以在使用 REST API 进行请求的时候需要加上认证信息。默认：</p><ul><li>用户名为：<code>elastic</code></li></ul><ul><li>密码为：<code>changeme</code></li></ul></blockquote></li></ol><pre class="line-numbers language-sh"><code class="language-sh">$ curl http://localhost:9200 -u elastic&#123;  "name" : "E0QjUN9",  "cluster_name" : "elasticsearch",  "cluster_uuid" : "oSsjMVpETViMkzUCf110Cw",  "version" : &#123;    "number" : "5.3.0",    "build_hash" : "3adb13b",    "build_date" : "2017-03-23T03:31:50.652Z",    "build_snapshot" : false,    "lucene_version" : "6.4.1"  &#125;,  "tagline" : "You Know, for Search"&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ElasticSearch的简单管理"><a href="#ElasticSearch的简单管理" class="headerlink" title="ElasticSearch的简单管理"></a>ElasticSearch的简单管理</h5><p>启动</p><pre class="line-numbers language-sh"><code class="language-sh">$ /usr/local/elasticsearch-5.3.0/bin/elasticsearch  -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置开机自启动</p><pre class="line-numbers language-sh"><code class="language-sh">echo "/usr/local/elasticsearch-5.3.0/bin/elasticsearch -d" > /etc/rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何关闭elasticsearch</p><ul><li>方法一：如果节点与控制台相连并且当前elasticsearch是使用-f选项运行，则只需要按下Ctrl+C组合键即可</li><li>方法二：通过发送TERM信号来终止服务器进程 kill -9 进程ID</li><li>方法三：使用REST API</li></ul><p>前两种就不说了，简单说一下第三种，</p><ul><li>关闭整个集群<pre class="line-numbers language-sh"><code class="language-sh">curl -XPOST http://localhost:9200/_cluster/nodes/_shutdown -u elastic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>关闭单个节点<pre class="line-numbers language-sh"><code class="language-sh">curl -XPOST  http://127.0.0.1:9200/_cluster/nodes/2ens0yuEQ12G6ct1UDpihQ/_shutdown -u elastic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><h2 id="2ens0yuEQ12G6ct1UDpihQ-，为要关闭的节点标志符"><a href="#2ens0yuEQ12G6ct1UDpihQ-，为要关闭的节点标志符" class="headerlink" title="2ens0yuEQ12G6ct1UDpihQ ，为要关闭的节点标志符"></a>2ens0yuEQ12G6ct1UDpihQ ，为要关闭的节点标志符</h2><p>查看节点标志符，可以从elasticsearch日志中或者通过REST API中获得</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">curl http://localhost:9200/_nodes/?pretty -u elastic&#123;"cluster_name" : "elasticsearch","nodes" : &#123;  "13QfvIdATEurGAhVAlO6tQ" : &#123;    "name" : "Edwin Jarvis",    ...  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="安装或者启动时可能会遇到的问题列表："><a href="#安装或者启动时可能会遇到的问题列表：" class="headerlink" title="安装或者启动时可能会遇到的问题列表："></a>安装或者启动时可能会遇到的问题列表：</h5><ol><li> can not run elasticsearch as root</li></ol><p>解决：新建一个专门运行和管理ElasticSearch 的用户。切换到该用户下重新运行。</p><ol start="2"><li> max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]</li></ol><p>解决：切换到root用户，编辑limits.conf 添加类似如下内容</p><pre class="line-numbers language-sh"><code class="language-sh">vi /etc/security/limits.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改文件末尾如下内容:</p><pre><code>* soft nofile 655350* hard nofile 655350</code></pre><p>然后切换回用户，使用<code>ulimit -a</code> 查看是否已经更改(对应的是<code>open file</code> 选项)</p><ol start="3"><li> max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</li></ol><p>解决：切换到root用户修改配置sysctl.conf</p><pre class="line-numbers language-sh"><code class="language-sh">vi /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加下面配置：</p><pre><code>vm.max_map_count=655300</code></pre><p>并执行命令：</p><pre class="line-numbers language-sh"><code class="language-sh">sysctl -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，切换回用户，重新运行 ElasticSearch</p><h4 id="Kibana-的安装与配置"><a href="#Kibana-的安装与配置" class="headerlink" title="Kibana 的安装与配置"></a>Kibana 的安装与配置</h4><h5 id="下载并解压-Kibana"><a href="#下载并解压-Kibana" class="headerlink" title="下载并解压 Kibana"></a>下载并解压 Kibana</h5><pre class="line-numbers language-sh"><code class="language-sh">$ wget https://artifacts.elastic.co/downloads/kibana/kibana-5.3.0-linux-x86_64.tar.gz$ tar -zxf kibana-5.3.0-linux-x86_64.tar.gzsudo mv kibana-5.3.0-linux-x86_64 /usr/local/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="安装-x-pack-插件"><a href="#安装-x-pack-插件" class="headerlink" title="安装 x-pack 插件"></a>安装 x-pack 插件</h5><pre class="line-numbers language-sh"><code class="language-sh">$ bin/kibana-plugin  install x-pack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>离线安装</p><p>同ElasticSearch 的x-pack插件一样，在安装时需要在线下载安装包，所以对于网络环境比较差或者一些离线的服务器，也需要离线下载 x-pack 安装包，来手动指定。</p><blockquote><p>Elasticsearch，Kibana和Logstash的插件都包含在同一个zip文件中,即 之前下载过的 x-pack-5.3.0ll.zip</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">$ sudo /usr/local/kibana-5.3.0-linux-x86_64/bin/kibana-plugin  install file:///home/datanode/x-pack-5.3.0.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>安装过程可能会比较长（请耐心等待）…</p></blockquote><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><pre class="line-numbers language-sh"><code class="language-sh">$ cd /usr/local/kibana-5.3.0-linux-x86_64$ vi config/kibana.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>kibana.yml 示例</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Kibana is served by a back end server. This setting specifies the port to use.</span><span class="token comment" spellcheck="true">#server.port: 5601</span><span class="token comment" spellcheck="true"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span><span class="token comment" spellcheck="true"># The default is 'localhost', which usually means remote machines will not be able to connect.</span><span class="token comment" spellcheck="true"># To allow connections from remote users, set this parameter to a non-loopback address.</span><span class="token comment" spellcheck="true">#server.host: "127.0.0.1"</span><span class="token comment" spellcheck="true"># Enables you to specify a path to mount Kibana at if you are running behind a proxy. This only affects</span><span class="token comment" spellcheck="true"># the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests</span><span class="token comment" spellcheck="true"># to Kibana. This setting cannot end in a slash.</span><span class="token comment" spellcheck="true">#server.basePath: ""</span><span class="token comment" spellcheck="true"># The maximum payload size in bytes for incoming server requests.</span><span class="token comment" spellcheck="true">#server.maxPayloadBytes: 1048576</span><span class="token comment" spellcheck="true"># The Kibana server's name.  This is used for display purposes.</span><span class="token comment" spellcheck="true">#server.name: "your-hostname"</span><span class="token comment" spellcheck="true"># The URL of the Elasticsearch instance to use for all your queries.</span><span class="token key atrule">elasticsearch.url</span><span class="token punctuation">:</span> <span class="token string">"http://10.30.70.120:9200"</span><span class="token comment" spellcheck="true"># When this setting's value is true Kibana uses the hostname specified in the server.host</span><span class="token comment" spellcheck="true"># setting. When the value of this setting is false, Kibana uses the hostname of the host</span><span class="token comment" spellcheck="true"># that connects to this Kibana instance.</span><span class="token comment" spellcheck="true">#elasticsearch.preserveHost: true</span><span class="token comment" spellcheck="true"># Kibana uses an index in Elasticsearch to store saved searches, visualizations and</span><span class="token comment" spellcheck="true"># dashboards. Kibana creates a new index if the index doesn't already exist.</span><span class="token comment" spellcheck="true">#kibana.index: ".kibana"</span><span class="token comment" spellcheck="true"># The default application to load.</span><span class="token comment" spellcheck="true">#kibana.defaultAppId: "discover"</span><span class="token comment" spellcheck="true"># If your Elasticsearch is protected with basic authentication, these settings provide</span><span class="token comment" spellcheck="true"># the username and password that the Kibana server uses to perform maintenance on the Kibana</span><span class="token comment" spellcheck="true"># index at startup. Your Kibana users still need to authenticate with Elasticsearch, which</span><span class="token comment" spellcheck="true"># is proxied through the Kibana server.</span><span class="token comment" spellcheck="true">#elasticsearch.username: "user"</span><span class="token comment" spellcheck="true">#elasticsearch.password: "pass"</span><span class="token comment" spellcheck="true"># Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.</span><span class="token comment" spellcheck="true"># These settings enable SSL for outgoing requests from the Kibana server to the browser.</span><span class="token comment" spellcheck="true">#server.ssl.enabled: false</span><span class="token comment" spellcheck="true">#server.ssl.certificate: /path/to/your/server.crt</span><span class="token comment" spellcheck="true">#server.ssl.key: /path/to/your/server.key</span><span class="token comment" spellcheck="true"># Optional settings that provide the paths to the PEM-format SSL certificate and key files.</span><span class="token comment" spellcheck="true"># These files validate that your Elasticsearch backend uses the same key files.</span><span class="token comment" spellcheck="true">#elasticsearch.ssl.certificate: /path/to/your/client.crt</span><span class="token comment" spellcheck="true">#elasticsearch.ssl.key: /path/to/your/client.key</span><span class="token comment" spellcheck="true"># Optional setting that enables you to specify a path to the PEM file for the certificate</span><span class="token comment" spellcheck="true"># authority for your Elasticsearch instance.</span><span class="token comment" spellcheck="true">#elasticsearch.ssl.certificateAuthorities: [ "/path/to/your/CA.pem" ]</span><span class="token comment" spellcheck="true"># To disregard the validity of SSL certificates, change this setting's value to 'none'.</span><span class="token comment" spellcheck="true">#elasticsearch.ssl.verificationMode: full</span><span class="token comment" spellcheck="true"># Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of</span><span class="token comment" spellcheck="true"># the elasticsearch.requestTimeout setting.</span><span class="token comment" spellcheck="true">#elasticsearch.pingTimeout: 1500</span><span class="token comment" spellcheck="true"># Time in milliseconds to wait for responses from the back end or Elasticsearch. This value</span><span class="token comment" spellcheck="true"># must be a positive integer.</span><span class="token comment" spellcheck="true">#elasticsearch.requestTimeout: 30000</span><span class="token comment" spellcheck="true"># List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side</span><span class="token comment" spellcheck="true"># headers, set this value to [] (an empty list).</span><span class="token comment" spellcheck="true">#elasticsearch.requestHeadersWhitelist: [ authorization ]</span><span class="token comment" spellcheck="true"># Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten</span><span class="token comment" spellcheck="true"># by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.</span><span class="token comment" spellcheck="true">#elasticsearch.customHeaders: &amp;#123;&amp;#125;</span><span class="token comment" spellcheck="true"># Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.</span><span class="token comment" spellcheck="true">#elasticsearch.shardTimeout: 0</span><span class="token comment" spellcheck="true"># Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.</span><span class="token comment" spellcheck="true">#elasticsearch.startupTimeout: 5000</span><span class="token comment" spellcheck="true"># Specifies the path where Kibana creates the process ID file.</span><span class="token comment" spellcheck="true">#pid.file: /var/run/kibana.pid</span><span class="token comment" spellcheck="true"># Enables you specify a file where Kibana stores log output.</span><span class="token comment" spellcheck="true">#logging.dest: stdout</span><span class="token comment" spellcheck="true"># Set the value of this setting to true to suppress all logging output.</span><span class="token comment" spellcheck="true">#logging.silent: false</span><span class="token comment" spellcheck="true"># Set the value of this setting to true to suppress all logging output other than error messages.</span><span class="token comment" spellcheck="true">#logging.quiet: false</span><span class="token comment" spellcheck="true"># Set the value of this setting to true to log all events, including system usage information</span><span class="token comment" spellcheck="true"># and all requests.</span><span class="token comment" spellcheck="true">#logging.verbose: false</span><span class="token comment" spellcheck="true"># Set the interval in milliseconds to sample system and process performance</span><span class="token comment" spellcheck="true"># metrics. Minimum is 100ms. Defaults to 5000.</span><span class="token comment" spellcheck="true">#ops.interval: 5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件简单说明</p><ul><li><p><code>server.host</code> , 配置Kibana服务器绑定地址。IP地址或者域名</p><blockquote><p>默认是 “localhost”。远程用户无法连接。如果需要通过网络进行直接访问，则需要将该参数设置为非环回地址。</p><p>这里我将它设置为 “127.0.0.1”，即表示远程用户无法直接访问，需要通过之后安装配置的Nginx进行代理访问。</p></blockquote></li><li><p><code>elasticsearch.url</code> , 指向 Elasticsearch 实例</p></li></ul><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><pre class="line-numbers language-sh"><code class="language-sh">$ nohup /usr/local/kibana-5.3.0-linux-x86_64/bin/kibana &<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看是否已经运行</p><pre class="line-numbers language-sh"><code class="language-sh">$ ps aux | grep kiba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-sh"><code class="language-sh">$ netstat -tlun | grep 5601tcp        0      0 127.0.0.1:5601          0.0.0.0:*               LISTEN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Nginx-的安装与配置"><a href="#Nginx-的安装与配置" class="headerlink" title="Nginx 的安装与配置"></a>Nginx 的安装与配置</h4><p>安装</p><pre class="line-numbers language-sh"><code class="language-sh"># yum install nginx -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证</p><pre class="line-numbers language-sh"><code class="language-sh"># nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加配置</p><pre class="line-numbers language-sh"><code class="language-sh"># vi /etc/nginx/conf.d/kibana.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kibana.conf 示例</p><pre class="line-numbers language-ini"><code class="language-ini">server &amp;#123;    listen 80;    server_name 47.90.15.84;    location / &amp;#123;        proxy_pass http://127.0.0.1:5601;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection 'upgrade';        proxy_set_header Host $host;        proxy_cache_bypass $http_upgrade;    &amp;#125;&amp;#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动 Nginx</p><pre><code># nginx</code></pre><p>验证</p><p>浏览器打开 <code>http://47.90.15.84</code>，能看到登录界面，则说明配置成功</p><center>![登录页面](http://wx1.sinaimg.cn/mw690/8e242e12ly1fevxyyb4rej21kw0zk0v4.jpg)</center><blockquote><p>默认账号</p><ul><li>username: elastic</li><li>password: changeme</li></ul></blockquote><h4 id="Logstash-的安装与配置"><a href="#Logstash-的安装与配置" class="headerlink" title="Logstash 的安装与配置"></a>Logstash 的安装与配置</h4><h5 id="下载并解压-Logstash"><a href="#下载并解压-Logstash" class="headerlink" title="下载并解压 Logstash"></a>下载并解压 Logstash</h5><pre><code># wget https://artifacts.elastic.co/downloads/logstash/logstash-5.3.0.zip# unzip logstash-5.3.0.zip# mv logstash-5.3.0 /usr/local/</code></pre><h5 id="测试-Logstash"><a href="#测试-Logstash" class="headerlink" title="测试 Logstash"></a>测试 Logstash</h5><pre><code>cd /usr/local/logstash-5.3.0bin/logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</code></pre><blockquote><p>-e 选项表示直接从命令行指定配置</p></blockquote><p>待 Logstash 启动， 看到 “Pipeline main started” ，在命令行中输入 “hello logstash”，将会看到</p><pre><code>hello logstash2017-04-22T17:19:31.051Z iZj6c1rlufgkgsimhzuumaZ hello logstash</code></pre><blockquote><p>Logstash 将时间戳和主机名添加到了消息中</p></blockquote><h5 id="添加一个-Logstash-配置文件，将我们上面安装的Nginx-的访问日志作为input，输出到-ElasticSearch-中"><a href="#添加一个-Logstash-配置文件，将我们上面安装的Nginx-的访问日志作为input，输出到-ElasticSearch-中" class="headerlink" title="添加一个 Logstash 配置文件，将我们上面安装的Nginx 的访问日志作为input，输出到 ElasticSearch 中"></a>添加一个 Logstash 配置文件，将我们上面安装的Nginx 的访问日志作为input，输出到 ElasticSearch 中</h5><p>Nginx 访问日志的位置：<code>/var/log/nginx/access.log</code></p><pre><code>vi first-pipeline.conf</code></pre><p>first-pipeline.conf 示例</p><pre><code>input &#123;  file &#123;    path =&gt; &quot;/var/log/nginx/access.log&quot;    type =&gt; &quot;nginx&quot;  &#125;&#125;filter &#123;    grok &#123;        match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;    &#125;    geoip &#123;        source =&gt; &quot;clientip&quot;    &#125;&#125;output &#123;    #stdout &#123; codec =&gt; rubydebug &#125;    elasticsearch &#123;        hosts =&gt; [&quot;10.30.70.120:9200&quot;,&quot;10.47.45.32:9200&quot;]        user =&gt; &quot;elastic&quot;        password =&gt; &quot;changeme&quot;  &#125;&#125;</code></pre><p>配置文件简析</p><ul><li><p>input 区块</p><blockquote><p>使用了 input 的file 插件， 该插件跟踪 path 路径下的文件变化，并将数据读取到 Logstash。</p></blockquote></li><li><p>filter 区块</p><blockquote><ul><li>该区块应用了 grok 插件，会将非结构化的日志数据转化为可查询的结构化的数据</li><li>geoip插件将IP地址转换为实际地址坐标信息</li></ul></blockquote></li><li><p>output区块</p><blockquote><ul><li>该区块使用了 ElasticSearch 插件，直接将数据输出到 ElasticSearch集群中</li><li>stdout插件则会直接将结果输出到控制台。（开发时将其打开，方便调试）</li></ul></blockquote></li></ul><h5 id="测试-amp-运行"><a href="#测试-amp-运行" class="headerlink" title="测试&amp;运行"></a>测试&amp;运行</h5><p>测试配置文件</p><pre><code> /usr/local/logstash-5.3.0/bin/logstash -f first-pipeline.conf --config.test_and_exit</code></pre><ul><li>–config.test_and_exit , 测试我们编写的配置文件</li></ul><p>如果测试通过，用下面的命令启动 Logstash</p><pre><code>bin/logstash -f first-pipeline.conf --config.reload.automatic</code></pre><ul><li>–config.reload.automatic ,启用自动重新加载配置</li></ul><blockquote><p>启用自动重新加载配置，之后每次修改配置文件时不必停止再重新启动Logstash。</p></blockquote><h5 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h5><p>浏览器打开 <code>http://47.90.15.84</code> ，登录 Kibana</p><p>添加“<code>logstash-*</code>” 索引</p><center>![添加索引](http://wx3.sinaimg.cn/mw690/8e242e12ly1fewnxhoiqyj21hc0u0tdk.jpg)</center><p>然后再 Discovery 中查看是否有数据被写入</p><center>![验证效果](http://wx1.sinaimg.cn/mw690/8e242e12ly1few1y2tl0uj21h30prtfm.jpg)</center><h4 id="beats-的安装与配置"><a href="#beats-的安装与配置" class="headerlink" title="beats 的安装与配置"></a>beats 的安装与配置</h4><p>Beats是作为代理在服务器上安装的开源的 data shippers，能将各种不同类型的操作数据（如， wireData、LogFiles、Metrics、WinEvent）直接发送到 Elasticsearch，或者通过Logstash将其发送到Elasticsearch。我们可以使用它来解析和转换我们需要收集的各种数据。</p><p>这里以 Metricbeat 为例，来监控我们想要监控的服务器。</p><h5 id="步骤1：安装Metricbeat"><a href="#步骤1：安装Metricbeat" class="headerlink" title="步骤1：安装Metricbeat"></a>步骤1：安装Metricbeat</h5><pre><code>curl -L -O https://artifacts.elastic.co/downloads/beats/metricbeat/metricbeat-5.3.1-x86_64.rpmsudo  rpm -vi metricbeat-5.3.1-x86_64.rpm</code></pre><blockquote><p>yum 包管理工具安装：<a href="https://www.elastic.co/guide/en/beats/metricbeat/5.3/setup-repositories.html">https://www.elastic.co/guide/en/beats/metricbeat/5.3/setup-repositories.html</a></p></blockquote><p>测试</p><pre><code>metricbeat -version</code></pre><h5 id="步骤2：配置Metricbeat"><a href="#步骤2：配置Metricbeat" class="headerlink" title="步骤2：配置Metricbeat"></a>步骤2：配置Metricbeat</h5><pre><code>cat /etc/metricbeat/metricbeat.yml</code></pre><p>内容如下：</p><pre><code>metricbeat.modules:- module: system metricsets:   - cpu   - load   - core   - diskio   - filesystem   - fsstat   - memory   - network   - process   - socket enabled: true period: 10s processes: [&#39;.*&#39;]- module: nginx metricsets: [&quot;stubstatus&quot;] enabled: true period: 10s hosts: [&quot;http://127.0.0.1&quot;] server_status_path: &quot;NginxStatus&quot;output.elasticsearch: hosts: [&quot;10.30.70.120:9200&quot;,&quot;10.47.45.32:9200&quot;] username: &quot;elastic&quot; password: &quot;changeme&quot;logging.level: debug</code></pre><p>配置文件检查</p><pre><code># metricbeat.sh -c metricbeat.yml  -configtest</code></pre><p>显示 <code>Config OK</code> 则说明配置文件语法正确</p><h5 id="第3步：加载索引模板Elasticsearch"><a href="#第3步：加载索引模板Elasticsearch" class="headerlink" title="第3步：加载索引模板Elasticsearch"></a>第3步：加载索引模板Elasticsearch</h5><pre><code>curl -H &#39;Content-Type: application/json&#39; -XPUT &#39;http://10.30.70.120:9200/_template/metricbeat&#39; -d@/etc/metricbeat/metricbeat.template.json -u elastic:changeme</code></pre><p>有如下显示则表示加载成功</p><pre><code>&#123;&quot;acknowledged&quot;:true&#125;</code></pre><h5 id="第4步：启动Metricbeat"><a href="#第4步：启动Metricbeat" class="headerlink" title="第4步：启动Metricbeat"></a>第4步：启动Metricbeat</h5><pre><code>/etc/init.d/metricbeat start</code></pre><p>验证服务器的统计信息是否被正确的已经发送在Elasticsearch中：</p><pre><code>curl -XGET &#39;http://10.30.70.120:9200/metricbeat-*/_search?pretty&#39; -u elastic:changeme</code></pre><h5 id="第5步：导入Kibana仪表板模板"><a href="#第5步：导入Kibana仪表板模板" class="headerlink" title="第5步：导入Kibana仪表板模板"></a>第5步：导入Kibana仪表板模板</h5><p><code>Metricbeat</code>自带了 <code>scripts/import_dashboards</code> 导入工具，我们可以使用它来导入例如dashboards, visualizations。该脚本还会为Metricbeat创建<code> metricbeat-*</code> 索引。</p><blockquote><p>我们可以通过 scripts/import_dashboards 后跟相应的选项，来控制是否只导入 dashboards 或者 index。</p><ul><li><code>-only-index</code> , 只创建索引</li><li><code>-only-dashboards</code> , 只导入 仪表盘</li></ul></blockquote><p>由于我们采用的是 rpm包 安装的 Metricbeat，所以该脚本是在<code>/usr/share/metricbeat/</code> 下。</p><pre><code># cd /usr/share/metricbeat/# ./scripts/import_dashboards -es http://10.30.70.120:9200 -user elastic -pass changemeCreate temporary directory /tmp/tmp252960117Downloading https://artifacts.elastic.co/downloads/beats/beats-dashboards/beats-dashboards-5.3.0.zipUnzip archive /tmp/tmp252960117Importing Kibana from /tmp/tmp252960117/beats-dashboards-5.3.0/filebeat...Importing Kibana from /tmp/tmp252960117/beats-dashboards-5.3.0/packetbeatImporting Kibana from /tmp/tmp252960117/beats-dashboards-5.3.0/winlogbeat</code></pre><p>导入之后，我们登录 Kibana 查看</p><center><p><img data-src="http://wx2.sinaimg.cn/mw690/8e242e12ly1fewv6vsm41j21kw0fggr5.jpg" alt="img"></p><p><img data-src="http://wx1.sinaimg.cn/mw690/8e242e12ly1fewv89jhhdj21kw0w6wlv.jpg" alt="img"></p></center><p>点击其中相应的 dashboard 我们就能查看到相应的参数。</p><h4 id="over"><a href="#over" class="headerlink" title="over~"></a>over~</h4><p>到此，这个简单的日志分析系统的架构就算基本搭建出来了。</p><p>对于搭建过程中遇到的其它问题和上述相关软件的使用，留待以后慢慢整理~~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不管是用于记录，监控或者程序的Debug，日志，对于任何系统来说都是一个及其重要的部分。但一般日志的数据量会比较大，并且分散在各个地方。如果管理的服务器或者程序比较少的情况我们还可以逐一登录到各个服务器去查看，分析。但如果服务器或者程序的数量比较多了之后这种方法就显得力不从心。基于此，一些集中式的日志系统也就应用而生。&lt;br&gt;目前比较有名成熟的有，Splunk(商业)、FaceBook 的Scribe、Apache 的 Chukwa&lt;br&gt;Cloudera 的 Fluentd、还有ELK 等等。&lt;/p&gt;</summary>
    
    
    
    <category term="ELK" scheme="https://weizhimiao.github.io/categories/ELK/"/>
    
    
    <category term="ELK" scheme="https://weizhimiao.github.io/tags/ELK/"/>
    
    <category term="Elasticsearch" scheme="https://weizhimiao.github.io/tags/Elasticsearch/"/>
    
    <category term="Logstash" scheme="https://weizhimiao.github.io/tags/Logstash/"/>
    
    <category term="Kibana" scheme="https://weizhimiao.github.io/tags/Kibana/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Web客户端追踪[转]</title>
    <link href="https://weizhimiao.github.io/2017/03/29/%E6%B5%85%E8%B0%88Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://weizhimiao.github.io/2017/03/29/%E6%B5%85%E8%B0%88Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2017-03-29T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>随着互联网络的广泛普及，数以亿计网民的网络行为数据早已成为最宝贵的资源，企业通过五花八门的各种手段了解网民的行为和隐私数据，用于广告投递、用户兴趣分析等，进而作为决策的依据。利用Web客户端对用户行为进行收集和追踪是重要手段之一，文本对主流的Web客户端追踪技术进行了简要分析，并给出相关参考供感兴趣的朋友深入，不喜之处还望大神勿喷。</p><span id="more"></span><h2 id="Web客户端追踪技术概述"><a href="#Web客户端追踪技术概述" class="headerlink" title="Web客户端追踪技术概述"></a>Web客户端追踪技术概述</h2><p>Web客户端追踪，主要是指用户使用客户端（通常是指浏览器）访问Web网站时，Web服务器通过一系列手段对用户客户端进行标记和识别，进而关联和分析用户行为的技术。</p><p>实际上，只要通过Web进入互联网的海洋，Web客户端追踪几乎无时不刻不在发生。</p><p>当你网购时，即便没有登录，关掉浏览器后购物车的物品也不会消失；当你访问其他新闻、娱乐网站时，弹出的广告往往都是近期浏览购物网站的类似商品；稍有意识的用户可能会不定时清空浏览器缓存、使用“无痕浏览”、“隐私保护模式”等，然而仍然不能阻止类似广告的洗脑。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/CCC2C265-F4A1-4D0E-AEE7-3DAC87997A54.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/4809C3B6-4DAD-49A8-9AE5-3B59C15E44A7.png" alt="img"></p><p>现实世界可通过体貌特征、身份证件、生物特征（如指纹信息）等手段对用户进行唯一性识别，Web世界主要通过Cookies、客户端指纹等技术进行识别。</p><h2 id="典型追踪技术"><a href="#典型追踪技术" class="headerlink" title="典型追踪技术"></a>典型追踪技术</h2><h3 id="1-Cookie追踪"><a href="#1-Cookie追踪" class="headerlink" title="1. Cookie追踪"></a>1. Cookie追踪</h3><h4 id="1-Cookie简介"><a href="#1-Cookie简介" class="headerlink" title="1)  Cookie简介"></a>1)  Cookie简介</h4><p>Cookie，中文翻译为小甜饼，有时也用复数形式Cookies，在Web世界中其实际上是用户浏览网站时，网站存储在用户浏览器上的一段信息，并在服务器和浏览器之间传递，用户与辨别用户身份和维持状态。</p><p>通常是以cookies:user@domain格式命名的，user是你的本地用户名，domain是所访问的网站的域名。在现有Windows系统中，一般存放位置在</p><p><code>C:\Users\user\AppData\Local\Microsoft\Windows\TemporaryInternet Files\</code>文件夹下。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/90ADED7C-F517-4460-AAF4-4052AF293B63.png" alt="img"></p><p>以添加购物车为例，Cookies的大致利用过程可表示为：</p><ul><li>①、用户第一次访问购物网站：</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/5FD30CF8-5A10-454A-924A-0E51431A95FB.png" alt="img"></p><ul><li>②、用户第二次访问网站：</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/1F01FC18-7FAB-4DE7-88DF-4BCBDE1F5979.png" alt="img"></p><ul><li>③、浏览器查看Cookies如下：</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/909A1F2B-3584-49CA-9446-8BD5E9685565.png" alt="img"></p><h4 id="2-Evercookie"><a href="#2-Evercookie" class="headerlink" title="2)  Evercookie"></a>2)  Evercookie</h4><p>用户可以通过清空浏览器缓存等方式，清除已保存的Cookie，Evercookie将Cookie通过多种机制保存到系统多个地方，如果用户删除其中某几处的Cookie， Evercookie仍然可以恢复Cookie，如果开启本地共享对象(Local Shared Objects)，Evercookie甚至可以跨浏览器传播（详见参考地址[1]）。</p><p>主要的存储机制如下图，开源地址：</p><p><a href="https://github.com/samyk/evercookie">https://github.com/samyk/evercookie</a></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/3D9E61BC-FFE2-4FDF-8755-2BC7F293ABD4.png" alt="img"></p><h4 id="3-Cookie同步"><a href="#3-Cookie同步" class="headerlink" title="3)  Cookie同步"></a>3)  Cookie同步</h4><p>Cookie同步是指用户访问某A网站时，该网站通过页面跳转等方式将用户的Cookie发送到B网站，使得B网站获取到用户在A网站的用户隐私信息，然后通过Ad Network等一系列平台进行有效的广告推送服务。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/81117524-6CBE-4EBF-B2E8-F6CFDED2C069.png" alt="img"></p><p>研究人员通过访问了Alexa排名前1500网站，发现两个追踪者进行Cookie同步以后，可以把数据完全共享，就像是一个追踪者一样。（详见参考地址[2]）</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/13E3C6AC-ACC4-4D12-B33E-F14FF233F9D7.png" alt="img"></p><p>Cookie越来越受限制，不少安全工具甚至是浏览器都允许或者引导关闭追踪Cookie，浏览器指纹追踪渐渐成为了Web追踪的重要技术手段。</p><h3 id="2-浏览器指纹"><a href="#2-浏览器指纹" class="headerlink" title="2. 浏览器指纹"></a>2. 浏览器指纹</h3><p>类似人的外貌和指纹，Web客户端（这里主要指浏览器）也有多种“外貌”信息和“指纹”信息，将这些信息综合分析计算后，可对客户端唯一性识别，进而追踪、了解网民行为和隐私数据。</p><h4 id="1-基本指纹"><a href="#1-基本指纹" class="headerlink" title="1)  基本指纹"></a>1)  基本指纹</h4><p>基本指纹是任何浏览器都具有的特征标识，比如硬件类型（Apple）、操作系统（Mac OS）、用户代理（Useragent）、系统字体、语言、屏幕分辨率、浏览器插件 (Flash,Silverlight, Java, etc)、浏览器扩展、浏览器设置(Do-Not-Track, etc)、时区差（BrowserGMT Offset）等众多信息。</p><p>可以在该网址进行查看测试，<a href="https://www.whatismybrowser.com/">https://www.whatismybrowser.com/</a></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/761F97FB-C31C-49ED-91F9-0361F0DF4A26.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/BE609BB4-53EE-4115-BA93-40CD9C243972.png" alt="img"></p><h4 id="2-高级指纹"><a href="#2-高级指纹" class="headerlink" title="2)  高级指纹"></a>2)  高级指纹</h4><p>基本指纹就像是人的外貌特征，外貌可以用男女、身高、体重之分，然而这些特征不能对某个人进行唯一性标识。基于HTML5的诸多高级指纹对此提供了新思路。</p><ul><li>①、Canvas指纹</li></ul><p>Canvas（画布），是HTML5中一种动态绘图的标签，可以使用其生成高级图片，官网有众多绘画事例，如下图。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/AAC806FA-2B19-4735-932F-80D47366E009.png" alt="img"></p><p>2014年9月，ProPublica报道：新型的Canvas指纹追踪正在被用到“上到白宫，下到YouPorn”等众多网站，众多重要网站都部署了Canvas指纹追踪。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/4EFB75A4-9BF9-4E43-A9B4-D0F17BC3984D.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/BD836DFD-178E-446F-A71F-C2DF37A2DD15.png" alt="img"></p><p>利用Canvas进行追踪的过程大致如下：</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/B8554485-29B1-4B8A-89AB-8550371CE09A.png" alt="img"></p><p>基于Canvas绘制特定内容的图片，使用canvas.toDataURL()方法获得图片内容的base64编码（对于PNG格式的图片，以块(chunk)划分，最后一块是32位CRC校验）作为唯一性标识，如下图。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/1BDA6AFA-B37C-400E-AE2F-71B13F76E4F9.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/7B8514B0-881B-4880-B297-918CB3B72A4C.png" alt="img"></p><p><em><strong>Canvas指纹的原理大致如下：</strong></em></p><p>相同的HTML5Canvas元素绘制操作，在不同操作系统、不同浏览器上，产生的图片内容不完全相同。</p><p>在图片格式上，不同浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别等。</p><p>在像素级别来看，操作系统各自使用了不同的设置和算法来进行抗锯齿和子像素渲染操作。即使相同的绘图操作，产生的图片数据的CRC检验也不相同。</p><p>在线测试地址：</p><p><a href="https://www.browserleaks.com/canvas">https://www.browserleaks.com/canvas</a></p><p>可查看浏览器的Canvas唯一性字符串。</p><ul><li>②、AudioContext指纹</li></ul><p>HTML5提供给JavaScript编程用的AudioAPI则让开发者有能力在代码中直接操作原始的音频流数据，对其进行任意生成、加工、再造，诸如提高音色，改变音调，音频分割等多种操作，甚至可称为网页版的Adobe Audition。</p><p><em><strong>AudioContext指纹原理大致如下：</strong></em></p><p>方法一：生成音频信息流(三角波)，对其进行FFT变换，计算SHA值作为指纹，音频输出到音频设备之前进行清除，用户毫无察觉。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/38DBB916-AAF4-42E1-B7B4-11A3F9DC3F39.png" alt="img"></p><p>方法二：生成音频信息流（正弦波），进行动态压缩处理，计算MD5值。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/038BF410-893D-4D20-B62A-24FECB62A794.png" alt="img"></p><p>AudioContext指纹基本原理：<br>主机或浏览器硬件或软件的细微差别，导致音频信号的处理上的差异，相同器上的同款浏览器产生相同的音频输出，不同机器或不同浏览器产生的音频输出会存在差异。</p><p>从上可以看出AudioContext和Canvas指纹原理很类似，都是利用硬件或软件的差异，前者生成音频，后者生成图片，然后计算得到不同哈希值来作为标识。</p><p>音频指纹测试地址：<a href="https://audiofingerprint.openwpm.com/">https://audiofingerprint.openwpm.com/</a></p><h4 id="3-硬件指纹"><a href="#3-硬件指纹" class="headerlink" title="3)  硬件指纹"></a>3)  硬件指纹</h4><p>硬件指纹主要通过检测硬件模块获取信息，作为对基于软件的指纹的补充，主要的硬件模块有：GPU’sclock frequency、Camera、Speakers/Microphone、Motion sensors、GPS、Battery等。</p><p>更多细节请参考：<a href="https://arxiv.org/pdf/1503.01408v3.pdf">https://arxiv.org/pdf/1503.01408v3.pdf</a></p><h4 id="4-综合指纹"><a href="#4-综合指纹" class="headerlink" title="4)  综合指纹"></a>4)  综合指纹</h4><p>Web世界的指纹碰撞不可避免，将上述基本指纹和高级指纹综合起来，计算哈希值作为综合指纹，可以大大降低碰撞率。</p><p>测试地址：<a href="https://panopticlick.eff.org/">https://panopticlick.eff.org/</a></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/2959BA38-D4E7-4E17-BDE4-3A562ABB1D21.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/C748D9A2-26B7-4205-9A39-652AE9DAD763.png" alt="img"></p><h3 id="3-跨浏览器指纹"><a href="#3-跨浏览器指纹" class="headerlink" title="3. 跨浏览器指纹"></a>3. 跨浏览器指纹</h3><p>上述指纹都是基于浏览器进行的，同一台电脑的不同浏览器具有不同的指纹信息。</p><p>这样造成的结果是，当同一用户使用同一台电脑的不同浏览器时，服务方收集到的浏览器指纹信息不同，无法将该用户进行唯一性识别，进而无法有效分析改用户的的行为。</p><p>近期有学者研究了一种跨浏览器的浏览器指纹，其依赖于浏览器与操作系统和硬件底层进行交互进而分析计算出指纹，这种指纹对于同一台电脑的不同浏览器也是相同的。</p><p>更多技术细节请参考：</p><p><a href="http://yinzhicao.org/TrackingFree/crossbrowsertracking_NDSS17.pdf">http://yinzhicao.org/TrackingFree/crossbrowsertracking_NDSS17.pdf</a></p><h3 id="4-WebRTC"><a href="#4-WebRTC" class="headerlink" title="4. WebRTC"></a>4. WebRTC</h3><p>WebRTC（网页实时通信，Web Real Time Communication），是一个支持网页浏览器进行实时语音对话或视频对话的API，功能是让浏览器实时获取和交换视频、音频和数据。基于WebRTC可以实现浏览器上，通过Javascript就可以达到实时通讯的能力。</p><p>基于WebRTC的实时通讯功能，可以获取客户端的IP地址，包括本地内网地址和公网地址。其原理是利用到RTCPeerConnection的API，大致函数如下：</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/369C0E01-4122-4B75-BCAA-00C6026C1378.png" alt="img"></p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170329/701F38B8-C7A0-49AE-8676-6053F8F0EF4D.png" alt="img"></p><p>利用WebRTC能做的事情还远不止这些，比如使用其探测扫描内网信息，进行语音、视频交流，更多技术细节请参考：</p><p><a href="http://net.ipcalf.com/">http://net.ipcalf.com</a></p><p><a href="https://diafygi.github.io/webrtc-ips/">https://diafygi.github.io/webrtc-ips/</a></p><h2 id="防客户端追踪措施"><a href="#防客户端追踪措施" class="headerlink" title="防客户端追踪措施"></a>防客户端追踪措施</h2><h3 id="1-浏览器设置"><a href="#1-浏览器设置" class="headerlink" title="1. 浏览器设置"></a>1. 浏览器设置</h3><ul><li><p>①、使用隐身模式，目前主流的浏览器都支持该模式。</p></li><li><p>②、禁用Cookie和JavaScript（此项可能导致页面显示不正常，慎用）</p></li><li><p>③、禁用WebRTC，如Firefox浏览器：打开about:config，找到media.peerconnection.enabled的项，设置成 false</p></li><li><p>④、禁用Geolocation，Firefox浏览器：打开about:config，找到geo.enabled的值，设置其值为 false。Chrome 点击设置（Settings），从显示高级设置（Show advanced settings）上，找到隐私（Privacy）并且点击内容设置（Content settings），在窗口里找到定位（Location）并设置选项不允许任何网站追踪你的物理位置（Do not allow any site to track your physical location）</p></li><li><p>⑤、限制API访问文件资源时序信息，恶意网站会通过检测浏览器缓存的时序信息，包括访问和忽略第三方网站的资源，来判断使用者是否访问过第三方网站。Firefox浏览器：打开about:config，将dom.enable_resource_timing, dom.enable_user_timing 和dom.performance.enable_user_timing_logging设置为 false，来阻止这些 API 运行。</p></li></ul><h3 id="2-插件"><a href="#2-插件" class="headerlink" title="2. 插件"></a>2. 插件</h3><p>推荐几个较好的插件来阻止第三方广告追踪和广告：<br>Ghostery，官网地址：<br><a href="https://www.ghostery.com/try-us/download-browser-extension">https://www.ghostery.com/try-us/download-browser-extension</a></p><p>Privacy Badger，官网地址：<br><a href="https://www.eff.org/privacybadger/">https://www.eff.org/privacybadger/</a></p><p>uMatrix（仅Chrome和FireFox）：<br><a href="https://addons.mozilla.org/en-us/firefox/addon/umatrix/">https://addons.mozilla.org/en-us/firefox/addon/umatrix/</a></p><p>NoScript（仅FireFox）：<br><a href="https://addons.mozilla.org/en-US/firefox/addon/noscript/#">https://addons.mozilla.org/en-US/firefox/addon/noscript/#</a></p><p>Chameleon（仅Chrome）：<br><a href="https://github.com/ghostwords/chameleon">https://github.com/ghostwords/chameleon</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://samy.pl/evercookie/">http://samy.pl/evercookie/</a></p><p>[2] <a href="http://freedom-to-tinker.com/2014/08/07/the-hidden-perils-of-cookie-syncing/">http://freedom-to-tinker.com/2014/08/07/the-hidden-perils-of-cookie-syncing/</a></p><p>[3] <a href="https://securehomes.esat.kuleuven.be/~gacar/persistent/index.html">https://securehomes.esat.kuleuven.be/~gacar/persistent/index.html</a></p><p>[4] <a href="http://cseweb.ucsd.edu/~hovav/papers/ms12.html">http://cseweb.ucsd.edu/~hovav/papers/ms12.html</a></p><p>[5] <a href="https://arxiv.org/pdf/1503.01408v3.pdf">https://arxiv.org/pdf/1503.01408v3.pdf</a></p><p>[6] <a href="https://eprint.iacr.org/2015/616.pdf">https://eprint.iacr.org/2015/616.pdf</a></p><blockquote><p>作者：ArkTeam/Wellee</p><p>来源：FreeBuf</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着互联网络的广泛普及，数以亿计网民的网络行为数据早已成为最宝贵的资源，企业通过五花八门的各种手段了解网民的行为和隐私数据，用于广告投递、用户兴趣分析等，进而作为决策的依据。利用Web客户端对用户行为进行收集和追踪是重要手段之一，文本对主流的Web客户端追踪技术进行了简要分析，并给出相关参考供感兴趣的朋友深入，不喜之处还望大神勿喷。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://weizhimiao.github.io/categories/Web/"/>
    
    
    <category term="客户端追踪" scheme="https://weizhimiao.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>PHP中常见的密码处理方式与建议</title>
    <link href="https://weizhimiao.github.io/2017/02/22/PHP%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%86%E7%A0%81%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%BB%BA%E8%AE%AE/"/>
    <id>https://weizhimiao.github.io/2017/02/22/PHP%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%86%E7%A0%81%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%BB%BA%E8%AE%AE/</id>
    <published>2017-02-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>密码安全的重要性我们就不用再去强调，随着在线攻击的增多，如果我们对密码没有进行合适的处理或做防御措施，我们的应用就会肯定会收到来自各方的威胁和攻击。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170223/QQTuPian20170223093340.png" alt="password"></p><p>所以作为开发者，我们需要对用户的密码做好预防措施。</p><span id="more"></span><h2 id="关于密码我们应该遵守的一些原则"><a href="#关于密码我们应该遵守的一些原则" class="headerlink" title="关于密码我们应该遵守的一些原则"></a>关于密码我们应该遵守的一些原则</h2><h3 id="绝对不能知道用户的密码"><a href="#绝对不能知道用户的密码" class="headerlink" title="绝对不能知道用户的密码"></a>绝对不能知道用户的密码</h3><ul><li>我们绝对不能知道用户的密码，也不能有获取用户密码的方式。</li><li><strong>知道的越少（包括我们开发者自己）越安全。</strong></li></ul><h3 id="绝对不去约束用户的密码"><a href="#绝对不去约束用户的密码" class="headerlink" title="绝对不去约束用户的密码"></a>绝对不去约束用户的密码</h3><ul><li><p>最好不要去约束密码的长度、格式等。</p></li><li><p>如果要求密码符合一个特定的模式，其实对于那些不怀好意的人也提供了攻击的途径。</p></li><li><p>如果必须要约束的话，建议只限制最小长度。并把常用的密码或基于字典创建的密码加入黑名单，也是一个好主意。</p></li></ul><h3 id="绝对不通过电子邮件发送用户的密码"><a href="#绝对不通过电子邮件发送用户的密码" class="headerlink" title="绝对不通过电子邮件发送用户的密码"></a>绝对不通过电子邮件发送用户的密码</h3><p>对于一个web应用来说，重置或修改密码时，我们应该在邮件里发送用于设定或修改密码的 <code>URL</code> 。而且这个<code>URL</code>中应该会包含一个唯一的令牌，这个令牌只能在设定或修改密码时使用一次。在设定或修改密码之后，我们就应该把这个令牌置为失效。</p><h2 id="使用-bcrypt-计算用户密码的哈希值"><a href="#使用-bcrypt-计算用户密码的哈希值" class="headerlink" title="使用 bcrypt 计算用户密码的哈希值"></a>使用 <code>bcrypt</code> 计算用户密码的哈希值</h2><blockquote><p>目前，通过大量的审查，最安全的哈希算法是 <code>bcrypt</code> 。</p></blockquote><p>首先，我们明确两个概念，哈希、加密。哈希和加密有什么区别？</p><ul><li><p>加密</p><blockquote><p>加密是双向算法，加密的数据之后通过解密还可以得到。</p></blockquote></li><li><p>哈希</p><blockquote><p>哈希是单向算法，哈希后的数据不能再还原成原始值。<br>哈希算法的用途，</p><ul><li>验证数据的完整性（要求算法速度快）</li><li>用户提高密码等需要单向验证的数据的安全性（要求安全性高，甚至故意要求时间慢）</li></ul></blockquote></li></ul><p>一般我们在数据库中保存的应该是计算出来的密码的哈希值。这样即使我们的数据库泄露了，他们也只能看到这些无意义的密码的哈希值。</p><p>哈希的算法有很多种，</p><ul><li><p><code>MD5</code></p><blockquote><p><code>MD5</code>即<code>Message-Digest Algorithm 5</code>（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有<code>MD5</code>实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，<code>MD5</code>的前身有<code>MD2</code>、<code>MD3</code>和<code>MD4</code>。</p></blockquote></li><li><p><code>SHA1</code></p><blockquote><p>安全哈希算法（<code>Secure Hash Algorithm</code>）主要适用于数字签名标准 （<code>Digital Signature Standard DSS</code>）里面定义的数字签名算法（<code>Digital Signature Algorithm DSA</code>）。对于长度小于<code>2^64</code>位的消息，<code>SHA1</code>会产生一个<code>160</code>位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。 <code>SHA1</code>有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要,(但会有<code>1x10 ^ 48</code>分之一的机率出现相同的消息摘要,一般使用时忽略)。</p></blockquote></li><li><p><code>bcrypt</code></p><blockquote><p><code>bcrypt</code>是专门为密码存储而设计的算法，基于<code>Blowfish</code>加密算法变形而来，由<code>Niels Provos</code>和<code>David Mazières</code>发表于<code>1999</code>年的<code>USENIX</code>。　<code>bcrypt</code>最大的好处是有一个参数（<code>work factor</code>)，可用于调整计算强度，而且<code>work factor</code>是包括在输出的摘要中的。随着攻击者计算能力的提高，使用者可以逐步增大<code>work factor</code>，而且不会影响已有用户的登陆。　<code>bcrypt</code>经过了很多安全专家的仔细分析，使用在以安全著称的<code>OpenBSD</code>中，一般认为它比<code>PBKDF2</code>更能承受随着计算能力加强而带来的风险。<strong>bcrypt也有广泛的函数库支持，因此我们建议使用这种方式存储密码</strong>。</p></blockquote></li><li><p><code>scrypt</code></p><blockquote><p>scrypt不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用<code>rainbow table</code>进行暴力攻击更加困难。<strong>scrypt没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持</strong> 。但是，<code>scrypt</code>在算法层面只要没有破绽，它的安全性应该高于<code>PBKDF2</code>和<code>bcrypt</code>。</p></blockquote></li></ul><p>目前，通过大量的审查，最安全的哈希算法是 <code>bcrypt</code> 。与 <code>MD5</code> 和 <code>SHA1</code> 不同， <code>bcrypt</code> 算法会自动加盐，来防止潜在的彩虹表攻击。 <code>bcrypt</code> 算法会花费大量的时间反复处理数据，来生成安全的哈希值。在这个过程中，处理数据的次数叫工作因子（<code>work factor</code>）。工作因子的值越高，破解密码哈希值的时间会成指数倍增长。</p><p><code>bcrypt</code> 算法永不过时，如果计算机的运算速度变快了，我们只需要提高工作因子即可。</p><p>顺带说一下，任何情况下尽可能的不要使用 <code>md5</code> 算法，至少也要使用 SHA 系列的哈希算法。因为<code>md5</code>算法以目前计算机的计算能力来说显得比较简单，而 <code>md5</code> 的性能优势现在也已经完全可以忽略不计了。</p><h2 id="密码哈希API"><a href="#密码哈希API" class="headerlink" title="密码哈希API"></a>密码哈希API</h2><p>上面我们说到 <code>bcrypt</code> 算法最安全，最适合对我们的密码进行哈希。 <code>PHP</code> 在 <code>PHP5.5.0+</code> 的版本中提供了原生的<code>密码哈希API</code>供我们使用，这个<code>密码哈希API</code>默认使用的就是 <code>bcrypt</code> 哈希算法，从而大大简化了我们计算密码哈希值和验证密码的操作。</p><h3 id="PHP原生密码哈希API"><a href="#PHP原生密码哈希API" class="headerlink" title="PHP原生密码哈希API"></a>PHP原生密码哈希API</h3><p>密码哈希函数：</p><ul><li><p><code>password_get_info</code></p><blockquote><p>返回指定的哈希值的相关信息</p></blockquote></li><li><p><code>password_hash</code></p><blockquote><p>创建密码的哈希（hash）</p></blockquote></li><li><p><code>password_needs_rehash</code></p><blockquote><p>检查给定的哈希是否与给定的选项匹配</p></blockquote></li><li><p><code>password_verify</code></p><blockquote><p>验证密码是否和哈希匹配</p></blockquote></li></ul><h4 id="password-get-info"><a href="#password-get-info" class="headerlink" title="password_get_info"></a>password_get_info</h4><p>说明</p><pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">array</span> <span class="token function">password_get_info</span> <span class="token punctuation">(</span> string <span class="token variable">$hash</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><ul><li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li></ul><p>示例，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">password_get_info</span><span class="token punctuation">(</span><span class="token variable">$hash</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Example</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token punctuation">[</span><span class="token string">"algo"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span>  <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">[</span><span class="token string">"algoName"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span>  <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"bcrypt"</span>  <span class="token punctuation">[</span><span class="token string">"options"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span>  <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token punctuation">[</span><span class="token string">"cost"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span>    <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="password-hash"><a href="#password-hash" class="headerlink" title="password_hash"></a>password_hash</h4><p><strong>说明</strong></p><pre class="line-numbers language-php"><code class="language-php">string <span class="token function">password_hash</span> <span class="token punctuation">(</span> string <span class="token variable">$password</span> <span class="token punctuation">,</span> integer <span class="token variable">$algo</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">array</span> <span class="token variable">$options</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>password_hash() 使用足够强度的单向散列算法创建密码的哈希（hash）。 password_hash() 兼容 crypt()。 所以， crypt() 创建的密码哈希也可用于 password_hash()。</p><p>当前支持的算法：</p><ul><li><p><code>PASSWORD_DEFAULT</code></p><blockquote><p>使用 <code>bcrypt</code> 算法 (PHP 5.5.0 默认)。 注意，该常量会随着 <code>PHP</code> 加入更新更高强度的算法而改变。 所以，使用此常量生成结果的长度将在未来有变化。 因此，数据库里储存结果的列可超过60个字符（最好是255个字符）。</p></blockquote></li><li><p><code>PASSWORD_BCRYPT</code></p><blockquote><p>使用 <code>CRYPT_BLOWFISH</code> 算法创建哈希。 这会产生兼容使用 “<code>$2y$</code>“ 的 crypt()。 结果将会是 60 个字符的字符串， 或者在失败时返回 <code>FALSE。</code></p></blockquote></li></ul><p>支持的选项：</p><ul><li><p><code>salt</code> - 手动提供哈希密码的盐值（<code>salt</code>）。这将避免自动生成盐值（<code>salt</code>）。</p><blockquote><p>省略此值后，password_hash() 会为每个密码哈希自动生成随机的盐值。这种操作是有意的模式。</p><p><strong>Warning 盐值（salt）选项从 PHP 7.0.0 开始被废弃（deprecated）了。 现在最好选择简单的使用默认产生的盐值。</strong></p></blockquote></li><li><p><code>cost</code> - 代表算法使用的 <code>cost</code>。crypt() 页面上有 <code>cost</code> 值的例子。</p><blockquote><p>省略时，默认值是 10。 这个 <code>cost</code> 是个不错的底线，但也许可以根据自己硬件的情况，加大这个值。</p></blockquote></li></ul><p><strong>参数</strong></p><ul><li><p><code>password</code>, 用户的密码。</p><blockquote><p> 使用 <code>PASSWORD_BCRYPT</code> 做算法，将使 <code>password</code> 参数最长为72个字符，超过会被截断。</p></blockquote></li><li><p><code>algo</code>, 一个用来在散列密码时指示算法的密码算法常量。</p></li><li><p><code>options</code>, 一个包含有选项的关联数组。目前支持两个选项：</p><ul><li><code>salt</code>，在散列密码时加的盐（干扰字符串），</li><li><code>cost</code>，用来指明算法递归的层数。这两个值的例子可在 crypt() 页面找到。<blockquote><p>省略后，将使用随机盐值与默认 <code>cost</code>。</p></blockquote></li></ul></li></ul><p><strong>示例</strong><br>示例1，使用默认算法哈希密码</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/** * 我们想要使用默认算法哈希密码 * 当前是 BCRYPT，并会产生 60 个字符的结果。 * * 请注意，随时间推移，默认算法可能会有变化， * 所以需要储存的空间能够超过 60 字（255字不错） */</span><span class="token keyword">echo</span> <span class="token function">password_hash</span><span class="token punctuation">(</span><span class="token string">"rasmuslerdorf"</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD_DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">// 输出类似于：</span><span class="token comment" spellcheck="true">// $2y$10$.vGA1O9wmRjrwAVXD98HNOgsNpDczlqm3Jq7KnEd1rVAGv3Fykk1a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2，手动设置 <code>cost</code></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/** * 在这个案例里，我们为 BCRYPT 增加 cost 到 12。 * 注意，我们已经切换到了，将始终产生 60 个字符。 */</span><span class="token variable">$options</span> <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'cost'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">password_hash</span><span class="token punctuation">(</span><span class="token string">"rasmuslerdorf"</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD_BCRYPT</span><span class="token punctuation">,</span> <span class="token variable">$options</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">// 输出类似于：</span><span class="token comment" spellcheck="true">// $2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例3，如何选择一个适合当前服务器的 cost</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/** * 这个例子对服务器做了基准测试（benchmark），检测服务器能承受多高的 cost * 在不明显拖慢服务器的情况下可以设置最高的值 * 8-10 是个不错的底线，在服务器够快的情况下，越高越好。 * 以下代码目标为  ≤ 50 毫秒（milliseconds）， * 适合系统处理交互登录。 */</span><span class="token variable">$timeTarget</span> <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 50 毫秒（milliseconds）</span><span class="token variable">$cost</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$cost</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token variable">$start</span> <span class="token operator">=</span> <span class="token function">microtime</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">password_hash</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD_BCRYPT</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"cost"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$cost</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$end</span> <span class="token operator">=</span> <span class="token function">microtime</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125; while (($end - $start) &lt; $timeTarget);</span><span class="token keyword">echo</span> <span class="token string">"Appropriate Cost Found: "</span> <span class="token punctuation">.</span> <span class="token variable">$cost</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出类似于：</p><pre><code>Appropriate Cost Found: 10</code></pre><h4 id="password-needs-rehash"><a href="#password-needs-rehash" class="headerlink" title="password_needs_rehash"></a>password_needs_rehash</h4><p>说明</p><pre class="line-numbers language-php"><code class="language-php">boolean <span class="token function">password_needs_rehash</span> <span class="token punctuation">(</span> string <span class="token variable">$hash</span> <span class="token punctuation">,</span> integer <span class="token variable">$algo</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token keyword">array</span> <span class="token variable">$options</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数</p><ul><li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li><li><code>algo</code>, 一个用来在散列密码时指示算法的密码算法常量。</li><li><code>options</code>, 一个包含有选项的关联数组。目前支持两个选项：<ul><li><code>salt</code>，在散列密码时加的盐（干扰字符串），</li><li><code>cost</code>，用来指明算法递归的层数。这两个值的例子可在 crypt() 页面找到。</li></ul></li></ul><p>示例，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string">'rasmuslerdorf'</span><span class="token punctuation">;</span><span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token string">'$2y$10$YCFsG6elYca568hBi2pZ0.3LDL5wjgxct1N8w/oLR/jfHsiQwCqTS'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// cost 参数可随硬件的提升也不断提升</span><span class="token variable">$options</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'cost'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用纯文本密码 验证存储的散列</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">password_verify</span><span class="token punctuation">(</span><span class="token variable">$password</span><span class="token punctuation">,</span> <span class="token variable">$hash</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">// 检查是否有更新的散列算法可用或 cost 是否已经改变</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">password_needs_rehash</span><span class="token punctuation">(</span><span class="token variable">$hash</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD_DEFAULT</span><span class="token punctuation">,</span> <span class="token variable">$options</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">// 如果是，请创建一个新的哈希值，并替换旧的哈希值</span>        <span class="token variable">$newHash</span> <span class="token operator">=</span> <span class="token function">password_hash</span><span class="token punctuation">(</span><span class="token variable">$password</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD_DEFAULT</span><span class="token punctuation">,</span> <span class="token variable">$options</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">// 用户登录验证完成</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="password-verify"><a href="#password-verify" class="headerlink" title="password_verify"></a>password_verify</h4><p>说明</p><pre class="line-numbers language-php"><code class="language-php">boolean <span class="token function">password_verify</span> <span class="token punctuation">(</span> string <span class="token variable">$password</span> <span class="token punctuation">,</span> string <span class="token variable">$hash</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意 password_hash() 返回的哈希包含了算法、 cost 和盐值。 因此，所有需要的信息都包含内。使得验证函数不需要储存额外盐值等信息即可验证哈希。</p></blockquote><p>参数</p><ul><li><code>password</code>, 用户的密码。</li><li><code>hash</code>, 一个由 password_hash() 创建的散列值。</li></ul><p>示例，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 想知道以下字符从哪里来，可参见 password_hash() 的例子</span><span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token string">'$2y$07$BCryptRequires22Chrcte/VlQH0piJtjXl.0t1XkA8pw9dMXTpOq'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">password_verify</span><span class="token punctuation">(</span><span class="token string">'rasmuslerdorf'</span><span class="token punctuation">,</span> <span class="token variable">$hash</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">echo</span> <span class="token string">'Password is valid!'</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else &amp;#123;</span>    <span class="token keyword">echo</span> <span class="token string">'Invalid password.'</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例程会输出：</p><pre><code>Password is valid!</code></pre><h3 id="PHP5-50-之前的密码哈希-API"><a href="#PHP5-50-之前的密码哈希-API" class="headerlink" title="PHP5.50 之前的密码哈希 API"></a>PHP5.50 之前的密码哈希 API</h3><p>安东尼·费拉拉（PHP原生密码哈希 API的开发者）为PHP5.5.0 以下的版本也提供了 <code>ircmaxell/password-compat</code>组件（<a href="https://packagist.org/packages/ircmaxell/password-compat%EF%BC%89%E3%80%82">https://packagist.org/packages/ircmaxell/password-compat）。</a></p><p>这个组件也实现了PHP密码哈希API中的所有函数，</p><ul><li><p><code>password_get_info</code></p></li><li><p><code>password_hash</code></p></li><li><p><code>password_needs_rehash</code></p></li><li><p><code>password_verify</code></p></li></ul><p>我们可以直接使用 <code>Composer</code> 把这个组件添加到我们的应用中就行了。例如，</p><pre class="line-numbers language-bash"><code class="language-bash">composer require ircmaxell/password-compat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;密码安全的重要性我们就不用再去强调，随着在线攻击的增多，如果我们对密码没有进行合适的处理或做防御措施，我们的应用就会肯定会收到来自各方的威胁和攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20170223/QQTuPian20170223093340.png&quot; alt=&quot;password&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以作为开发者，我们需要对用户的密码做好预防措施。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="密码" scheme="https://weizhimiao.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
    <category term="哈希" scheme="https://weizhimiao.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计中的范式理论小结</title>
    <link href="https://weizhimiao.github.io/2017/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    <id>https://weizhimiao.github.io/2017/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA/</id>
    <published>2017-02-12T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>关系数据库中的关系必须满足一定的要求，数据库的设计范式简单的说就是数据库设计的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库。</p><span id="more"></span><h2 id="范式有哪些"><a href="#范式有哪些" class="headerlink" title="范式有哪些"></a>范式有哪些</h2><p>按照满足设计规范的不同程度,范式又被划分多个等级。目前，主要有六种范式：</p><ul><li>第一范式、</li><li>第二范式、</li><li>第三范式、</li><li>BC范式、</li><li>第四范式、</li><li>第五范式。</li></ul><p>他们的关系是，满足最低要求的叫第一范式，简称1NF。在第一范式基础上进一步满足一些要求的为第二范式，简称2NF。其余依此类推。</p><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><blockquote><p>简单的说，即每一个属性都是原子项，不可分割。<br><strong>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值</strong></p></blockquote><p>1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><blockquote><p>简单的说，第二范式要满足以下的条件：</p><ul><li>首先,要满足第一范式，</li><li>其次,每个非主属性要完全函数依赖与候选键，或者是主键。(即，<strong>数据库表中的每个实例或行必须可以被唯一地区分</strong>)</li></ul></blockquote><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><blockquote><ul><li>首先要满足第二范式，</li><li>其次非主属性之间不存在函数依赖。(即，属性不依赖于其它非主属性)</li></ul></blockquote><p>简而言之，第三范式（3NF）要求 <strong>一个数据库表中不包含已在其它表中已包含的非主关键字信息</strong>。<br>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。<br>那么在其他的信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入其他的信息中。</p><p>简单的说：</p><ul><li>一范式就是属性不可分割。（属性就是表中的字段）</li><li>二范式就是要有主键，要求其他字段都依赖于主键。</li><li>三范式就是要消除传递依赖，方便理解，可以看做是“消除冗余”</li></ul><h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>反范式是通过增加冗余数据或数据分组来提高数据库读性能的过程。<br>在某些情况下， 反范式有助于掩盖关系型数据库软件的低效。<br>关系型的范式数据库即使做过优化， 也常常会带来沉重的访问负载。</p><h2 id="范式与反范式的选择"><a href="#范式与反范式的选择" class="headerlink" title="范式与反范式的选择"></a>范式与反范式的选择</h2><p>范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦，但是操作困难，因为需要联系多个表才能得到所需要数据，而且范式越高性能就会越差。要权衡是否使用更高范式是比较麻烦的。</p><p>但是，反范式数据模型与没有范式化的数据模型不同。 只有在范式化已经达到一定的满意水平并且所需的约束和规则都已经建立起来， 我们才进行反范式化。例如，所有的关系都属于第三范式， 连接的关系和多值依赖得到了妥善处理。</p><p>一般在项目中，用得最多的也就是第三范式，我认为使用到第三范式也就足够了，性能好而且方便管理数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关系数据库中的关系必须满足一定的要求，数据库的设计范式简单的说就是数据库设计的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="范式" scheme="https://weizhimiao.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
    <category term="反范式" scheme="https://weizhimiao.github.io/tags/%E5%8F%8D%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>keepalived实现Nginx双机高可用</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2017-02-11T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><code>Keepalived</code> 是一个基于<code>VRRP</code>协议来实现的<code>LVS</code>服务高可用方案，可以利用其来避免单点故障。一个<code>LVS</code>服务至少会有2台服务器运行<code>Keepalived</code>，一台为主服务器（<code>MASTER</code>），一台为备份服务器（<code>BACKUP</code>），但是对外表现为一个<code>虚拟IP</code>，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管<code>虚拟IP</code>，继续提供服务，从而保证服务的高可用性。</p><span id="more"></span><h2 id="keepalived的工作原理"><a href="#keepalived的工作原理" class="headerlink" title="keepalived的工作原理"></a><code>keepalived</code>的工作原理</h2><p><code>Keepalived</code>是 <code>VRRP</code> 的完美实现，因此在介绍 <code>keepalived</code> 之前，先介绍一下 <code>VRRP</code> 的原理。</p><h3 id="VRRP-简介"><a href="#VRRP-简介" class="headerlink" title="VRRP 简介"></a>VRRP 简介</h3><p><code>VRRP（Virtual Router Redundancy Protocol）</code>虚拟路由冗余协议,在 <code>VRRP</code> 中有两组重要的概念：</p><ul><li><p><code>VRRP</code> 路由器 和 虚拟路由器，</p><blockquote><ul><li><code>VRRP</code>路由器 是指运行<code>VRRP</code>的路由器，是物理实体，</li><li>虚拟路由器是指<code>VRRP</code>协议创建的，是逻辑概念。</li></ul><p>一组<code>VRRP</code>路由器协同工作，共同构成一台虚拟路由器。</p></blockquote></li><li><p>主控路由器 和 备份路由器。</p><blockquote><p><code>VRRP</code> 中存在着一种选举机制，用以选出提供服务的路由即主控路由，其他的则成了备份路由。当主控路由失效后，备份路由中会重新选举出一个主控路由，来继续工作，来保障不间断服务。</p></blockquote></li></ul><p>在现实的网络环境中，两台需要通信的主机大多数情况下并没有直接的物理连接。对于这样的情况，通常的解决方法有以下两种：</p><ul><li>在主机上使用动态路由协议(RIP、OSPF等)</li><li>在主机上配置静态路由</li></ul><p>很明显，在主机上配置动态路由是非常不切实际的，因为管理、维护成本以及是否支持等诸多问题。配置静态路由就变得十分流行，但路由器(或者说默认网关<code>default gateway</code>)却经常成为单点故障。<code>VRRP</code>的目的就是为了解决静态路由单点故障问题，<code>VRRP</code>通过一竞选(<code>election</code>)协议来动态的将路由任务交给<code>LAN</code>中虚拟路由器中的某台<code>VRRP</code>路由器。</p><h3 id="VRRP-工作流程"><a href="#VRRP-工作流程" class="headerlink" title="VRRP 工作流程"></a>VRRP 工作流程</h3><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="(1).初始化："></a>(1).初始化：</h4><p>路由器启动时，如果路由器的优先级是255(最高优先级，路由器拥有路由器地址)，要发送<code>VRRP</code>通告信息，并发送广播ARP信息通告路由器IP地址对应的MAC地址为路由虚拟MAC，设置通告信息定时器准备定时发送<code>VRRP</code>通告信息，转为<code>MASTER</code>状态；否则进入<code>BACKUP</code>状态，设置定时器检查定时检查是否收到<code>MASTER</code>的通告信息。</p><h4 id="2-Master"><a href="#2-Master" class="headerlink" title="(2).Master"></a>(2).Master</h4><ul><li>设置定时通告定时器；</li><li>用<code>VRRP</code> <code>虚拟MAC</code>地址响应路由器<code>IP</code>地址的<code>ARP</code>请求；</li><li>转发目的<code>MAC</code>是<code>VRRP</code>虚拟<code>MAC</code>的数据包；</li><li>如果是虚拟路由器<code>IP</code>的拥有者，将接受目的地址是虚拟路由器<code>IP</code>的数据包，否则丢弃；</li><li>当收到<code>shutdown</code>的事件时删除定时通告定时器，发送优先权级为0的通告包，转初始化状态；</li><li>如果定时通告定时器超时时，发送<code>VRRP</code>通告信息；</li><li>收到<code>VRRP</code>通告信息时，如果优先权为0，发送<code>VRRP</code>通告信息；否则判断数据的优先级是否高于本机，或相等而且实际<code>IP</code>地址大于本地实际<code>IP</code>，设置定时通告定时器，复位主机超时定时器，转<code>BACKUP</code>状态；否则的话，丢弃该通告包；</li></ul><h4 id="3-Backup"><a href="#3-Backup" class="headerlink" title="(3).Backup"></a>(3).Backup</h4><ul><li>设置主机超时定时器；</li><li>不能响应针对虚拟路由器<code>IP</code>的<code>ARP</code>请求信息；</li><li>丢弃所有目的<code>MAC</code>地址是虚拟路由器<code>MAC</code>地址的数据包；</li><li>不接受目的是虚拟路由器<code>IP</code>的所有数据包；</li><li>当收到<code>shutdown</code>的事件时删除主机超时定时器，转初始化状态；</li><li>主机超时定时器超时的时候，发送<code>VRRP</code>通告信息，广播<code>ARP</code>地址信息，转<code>MASTER</code>状态；</li><li>收到<code>VRRP</code>通告信息时，如果优先权为<code>0</code>，表示进入<code>MASTER</code>选举；否则判断数据的优先级是否高于本机，如果高的话承认<code>MASTER</code>有效，复位主机超时定时器；否则的话，丢弃该通告包；</li></ul><h3 id="ARP查询处理"><a href="#ARP查询处理" class="headerlink" title="ARP查询处理"></a>ARP查询处理</h3><p>ARP（Address Resolution Protocol），即地址解析协议。是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址.</p><p>所以当内部主机通过<code>ARP</code>查询虚拟路由器<code>IP</code>地址对应的<code>MAC</code>地址时，<code>MASTER</code>路由器回复的<code>MAC</code>地址为虚拟的<code>VRRP</code>的<code>MAC</code>地址，而不是实际网卡的 <code>MAC</code>地址，这样在路由器切换时让内网机器觉察不到；</p><p>而在路由器重新启动时，也不能主动发送本机网卡的实际<code>MAC</code>地址。如果虚拟路由器开启的ARP代理 (<code>proxy_arp</code>)功能，代理的<code>ARP</code>回应也回应<code>VRRP</code>虚拟MAC地址；</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170207/ShiLiJiaGouShiYiTu.png" alt="示例架构示意图"></p><ul><li><code>Master</code> 和 <code>BackUp</code> 两台服务器作为负载均衡器，<code>BackUp</code> 为 <code>Master</code> 的热备份。</li><li><code>Node_x</code> 作为我们的业务机</li></ul><h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><ul><li><code>CentOS 6.8 X86_64</code></li><li><code>keepalived</code>、<code>ipvsadm</code>,实现 <code>Master</code> 和 <code>BackUp</code> 双机高可用。</li><li><code>Nginx</code>,在 <code>Master</code> 和 <code>BackUp</code> 上作为 7层负载均衡器，在 <code>Node_x</code> 节点作为 web 服务器来使用。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>1、同步各服务器的时间：</p><pre><code>ntpdate 202.120.2.101</code></pre></li><li><p>2、网络设置</p><blockquote><ul><li><strong>Master</strong>：192.168.1.201</li><li><strong>BackUp</strong>：192.168.1.202</li><li><strong>Node_1</strong>：192.168.1.210</li></ul></blockquote></li></ul><ul><li>3、安装 <code>Nginx</code></li></ul><p>分别在 <code>Master</code>、<code>BackUp</code>、<code>Node_1</code>节点上安装 <code>Nginx</code>。</p><p>先安装<code>nginx</code>的<code>yum</code>源</p><pre><code>rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm</code></pre><p>查看：</p><pre><code>yum info nginx</code></pre><p>安装：</p><pre><code>yum install nginx</code></pre><ul><li>4、安装 <code>keepalived</code></li></ul><p>分别在 <code>Master</code>、<code>BackUp</code> 上安装 <code>keepalived</code></p><pre><code>yum install -y keepalived</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p><code>Master</code>、<code>BackUp</code> 节点上 <code>Nginx</code> 配置(负载均衡)：</p><pre><code>cat /etc/nginx/conf.d/default.confupstream app &#123;  server 192.168.1.210:80;# server 192.168.1.xxx:80;&#125;server &#123;  listen       80;  server_name  localhost;  location / &#123;              proxy_pass http://app;  &#125;&#125;</code></pre><p><code>Master</code>、<code>BackUp</code> 节点上分别启动</p><pre><code>service nginx start</code></pre></li><li><p><code>Node_1</code> 节点上 <code>Nginx</code> 配置（web服务器）：</p><pre><code>cat /etc/nginx/conf.d/default.confserver &#123;  listen       80;  server_name  localhost;  location / &#123;      root   /usr/share/nginx/html;      index  index.html index.htm;  &#125;&#125;</code></pre><p>启动 <code>Nginx</code></p><pre><code>service nginx start</code></pre></li><li><p><code>Master</code> 节点 <code>keepalived</code> 配置</p><pre><code>cat /etc/keepalived/keepalived.confglobal_defs &#123;    router_id NodeA  &#125;  vrrp_instance VI_1 &#123;    state MASTER    #设置为主服务器    interface eth0  #监测网络接口    virtual_router_id 51  #主、备必须一样    priority 100   #(主、备机取不同的优先级，主机值较大，备份机值较小,值越大优先级越高)    advert_int 1   #VRRP Multicast广播周期秒数    authentication &#123;    auth_type PASS  #VRRP认证方式，主备必须一致    auth_pass 1111   #(密码)    virtual_ipaddress &#123;        192.168.1.200/24  #VRRP HA虚拟地址    &#125;&#125;  </code></pre></li><li><p><code>BackUp</code> 节点 <code>keepalived</code> 配置</p><pre><code>cat /etc/keepalived/keepalived.confglobal_defs &#123;    router_id NodeB  &#125;  vrrp_instance VI_1 &#123;    state BACKUP    #设置为主服务器    interface eth0  #监测网络接口    virtual_router_id 51  #主、备必须一样    priority 90   #(主、备机取不同的优先级，主机值较大，备份机值较小,值越大优先级越高)    advert_int 1   #VRRP Multicast广播周期秒数    authentication &#123;    auth_type PASS  #VRRP认证方式，主备必须一致    auth_pass 1111   #(密码)    virtual_ipaddress &#123;        192.168.1.200/24  #VRRP HA虚拟地址    &#125;&#125;  </code></pre><p>分别启动主节点和备用节点的 <code>keepalived</code></p><pre><code>service keepalived start</code></pre></li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>1、分别查看 <code>keepalived</code> 、<code>Nginx</code> 是否启动</li></ul><p><strong><code>Nginx</code>:</strong></p><pre><code>[root@localhost ~]# service nginx statusnginx (pid  1185) 正在运行...</code></pre><p>或：</p><pre><code>[root@localhost ~]# ps aux | grep nginxroot      1185  0.0  0.0   8596   740 ?        Ss   Feb06   0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.confnginx     1188  0.0  0.1   8600  1584 ?        S    Feb06   0:00 nginx: worker process                   root      2115  0.0  0.0   5724   548 pts/0    S+   Feb06   0:00 tail -f /var/log/nginx/access.logroot      2635  0.0  0.0   6052   780 pts/2    S+   00:05   0:00 grep nginx</code></pre><p><strong><code>keepalived</code>:</strong></p><pre><code>[root@localhost ~]# service keepalived statuskeepalived (pid  1925) 正在运行...</code></pre><p>或:</p><pre><code>[root@localhost ~]# ps aux | grep keepalivedroot      1925  0.0  0.1  17200  1092 ?        Ss   Feb06   0:00 /usr/sbin/keepalived -Droot      1927  0.0  0.2  17256  2584 ?        S    Feb06   0:00 /usr/sbin/keepalived -Droot      1928  0.0  0.1  17256  1896 ?        S    Feb06   0:01 /usr/sbin/keepalived -Droot      3553  0.0  0.0   6052   780 pts/2    S+   00:09   0:00 grep keepalived</code></pre><blockquote><p>为了确保稳定性，<code>keepalived</code> 守护程序分为3个不同的进程。父进程，负责监控两个子进程，两个子进程，一个负责<code>VRRP</code>框架，另一个负责健康检查。</p></blockquote><p>开启 <code>Master</code> 上 <code>keepalived</code> ,<code>Master</code> 会广播ARP消息</p><pre><code>[root@localhost ~]# tail -f /var/log/messagesFeb  7 04:50:06 localhost Keepalived[9864]: Starting Keepalived v1.2.13 (03/19,2015)Feb  7 04:50:06 localhost Keepalived[9865]: Starting Healthcheck child process, pid=9867Feb  7 04:50:06 localhost Keepalived[9865]: Starting VRRP child process, pid=9868Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Netlink reflector reports IP 192.168.1.201 addedFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Netlink reflector reports IP fe80::a00:27ff:fe89:8c8 addedFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering Kernel netlink reflectorFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering Kernel netlink command channelFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Registering gratuitous ARP shared channelFeb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP 192.168.1.201 addedFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Opening file &#39;/etc/keepalived/keepalived.conf&#39;.Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: Configuration is using : 35102 BytesFeb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP fe80::a00:27ff:fe89:8c8 addedFeb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Registering Kernel netlink reflectorFeb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Registering Kernel netlink command channelFeb  7 04:50:06 localhost Keepalived_vrrp[9868]: Using LinkWatch kernel netlink reflector...Feb  7 04:50:06 localhost Keepalived_vrrp[9868]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Opening file &#39;/etc/keepalived/keepalived.conf&#39;.Feb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Configuration is using : 5225 BytesFeb  7 04:50:06 localhost Keepalived_healthcheckers[9867]: Using LinkWatch kernel netlink reflector...Feb  7 04:50:07 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Transition to MASTER STATEFeb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Entering MASTER STATEFeb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) setting protocol VIPs.Feb  7 04:50:08 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200Feb  7 04:50:08 localhost avahi-daemon[1013]: Registering new address record for 192.168.1.200 on eth0.IPv4.Feb  7 04:50:08 localhost Keepalived_healthcheckers[9867]: Netlink reflector reports IP 192.168.1.200 addedFeb  7 04:50:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200</code></pre><p>同样，开启 <code>BackUp</code> 上 <code>keepalived</code> 时的日志信息</p><pre><code>[root@localhost ~]# tail -f /var/log/messagesFeb  7 04:40:45 localhost Keepalived[3771]: Starting Keepalived v1.2.13 (03/19,2015)Feb  7 04:40:45 localhost Keepalived[3772]: Starting Healthcheck child process, pid=3774Feb  7 04:40:45 localhost Keepalived[3772]: Starting VRRP child process, pid=3775Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: Netlink reflector reports IP 192.168.1.202 addedFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Netlink reflector reports IP fe80::a00:27ff:fec9:2d9 addedFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering Kernel netlink reflectorFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering Kernel netlink command channelFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Registering gratuitous ARP shared channelFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Opening file &#39;/etc/keepalived/keepalived.conf&#39;.Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Netlink reflector reports IP 192.168.1.202 addedFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Configuration is using : 35100 BytesFeb  7 04:40:45 localhost Keepalived_vrrp[3775]: Using LinkWatch kernel netlink reflector...Feb  7 04:40:45 localhost Keepalived_vrrp[3775]: VRRP sockpool: [ifindex(2), proto(112), unicast(0), fd(10,11)]Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Netlink reflector reports IP fe80::a00:27ff:fec9:2d9 addedFeb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Registering Kernel netlink reflectorFeb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Registering Kernel netlink command channelFeb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Opening file &#39;/etc/keepalived/keepalived.conf&#39;.Feb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Configuration is using : 5223 BytesFeb  7 04:40:45 localhost Keepalived_healthcheckers[3774]: Using LinkWatch kernel netlink reflector...Feb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Transition to MASTER STATEFeb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Received higher prio advertFeb  7 04:40:46 localhost Keepalived_vrrp[3775]: VRRP_Instance(VI_1) Entering BACKUP STATE</code></pre><blockquote><p>在日志的最后三行，是 <code>keepalived</code> 选举 <code>Master状态</code> 的记录<br>在启动 BackUp 节点的 <code>keepalived</code> 时，Master 的日志中会新增如下内容：</p></blockquote><pre><code>Feb  7 04:50:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Received lower prio advert, forcing new electionFeb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200Feb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Received lower prio advert, forcing new electionFeb  7 04:51:13 localhost Keepalived_vrrp[9868]: VRRP_Instance(VI_1) Sending gratuitous ARPs on eth0 for 192.168.1.200Feb  7 04:54:26 localhost dhclient[9723]: parse_option_buffer: malformed option dhcp.x-display-manager (code 49): option length exceeds option buffer length.</code></pre><ul><li>2、通过浏览器（<code>192.168.1.100</code>） 访问 <code>http://192.168.1.200</code></li></ul><p>我们通过查看 <code>Node_1</code> 节点的 访问日志</p><pre><code>[root@localhost ~]# tail -f /var/log/nginx/access.log192.168.1.201 - - [06/Feb/2017:22:51:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</code></pre><p>发现 访问路径为 ： <code>浏览器（192.168.1.100）</code> –&gt; <code>Master(192.168.1.201)</code> –&gt; <code>Node_1(192.168.1.210)</code></p><p>这时我们 关闭 <code>Master</code>(<code>192.168.1.201</code>) 的网卡，</p><pre><code>service network stop</code></pre><p>之后，再次通过 <code>浏览器（192.168.1.100）</code> 访问 <code>http://192.168.1.200</code>，再次查看 <code>Node_1</code> 节点的 访问日志</p><pre><code>[root@localhost ~]# tail -f /var/log/nginx/access.log192.168.1.201 - - [06/Feb/2017:22:51:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;192.168.1.202 - - [06/Feb/2017:23:02:49 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</code></pre><p>我们发现 访问路径已经切换成： <code>浏览器（192.168.1.100）</code> –&gt; <code>BackUp(192.168.1.202)</code> –&gt; <code>Node_1</code>(<code>192.168.1.210</code>)</p><p>再次开启，<code>Master(192.168.1.201)</code> 的网卡，</p><pre><code>service network restart</code></pre><p>使用<code>浏览器（192.168.1.100）</code> 访问 <code>http://192.168.1.200</code>，<code>Node_1</code> 节点的 访问日志</p><pre><code>[root@localhost ~]# tail -f /var/log/nginx/access.log192.168.1.201 - - [06/Feb/2017:23:02:27 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;192.168.1.202 - - [06/Feb/2017:23:02:49 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;192.168.1.201 - - [06/Feb/2017:23:03:46 +0800] &quot;GET / HTTP/1.1&quot; 200 14 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot; &quot;-&quot;</code></pre><p>访问路径有变回到， <code>浏览器（192.168.1.100）</code> –&gt; <code>BackUp(192.168.1.202)</code> –&gt; <code>Node_1(192.168.1.210)</code></p><p>至此，使用 <code>keepalived</code> 实现一个双机高可用的基本架构就算搭建完成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Keepalived&lt;/code&gt; 是一个基于&lt;code&gt;VRRP&lt;/code&gt;协议来实现的&lt;code&gt;LVS&lt;/code&gt;服务高可用方案，可以利用其来避免单点故障。一个&lt;code&gt;LVS&lt;/code&gt;服务至少会有2台服务器运行&lt;code&gt;Keepalived&lt;/code&gt;，一台为主服务器（&lt;code&gt;MASTER&lt;/code&gt;），一台为备份服务器（&lt;code&gt;BACKUP&lt;/code&gt;），但是对外表现为一个&lt;code&gt;虚拟IP&lt;/code&gt;，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管&lt;code&gt;虚拟IP&lt;/code&gt;，继续提供服务，从而保证服务的高可用性。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>keepalived配置整理</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/</id>
    <published>2017-02-11T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>keepalived只有一个配置文件 keepalived.conf ，里面主要包括以下几个配置区域，分别是</p><ul><li><p><strong>global_defs</strong></p><blockquote><p>主要是配置故障发生时的通知对象以及机器标识</p></blockquote></li><li><p>static_ipaddress</p><blockquote><p>配置的是是本节点的IP信息。（如果当前服务器上已经配置了IP，那么这这个区域可以不用配置）</p></blockquote></li><li><p>static_routes</p><blockquote><p>配置的是是本节点的路由信息。（如果当前服务器上已经配置了路由，那么这这个区域可以不用配置）</p></blockquote></li><li><p>vrrp_script</p><blockquote><p>用来做健康检查的，当时检查失败时会将<code>vrrp_instance</code>的<code>priority</code>减少相应的值。</p></blockquote></li><li><p><strong>vrrp_instance</strong></p><blockquote><p>用来定义对外提供服务的VIP区域及其相关属性。</p></blockquote></li><li><p>vrrp_sync_group</p><blockquote><p>用来定义<code>vrrp_intance</code>组，使得这个组内成员动作一致。</p></blockquote></li><li><p><strong>virtual_server</strong></p><blockquote><p>虚拟服务器，来源<code>vrrp_instance</code> 中配置的 的虚拟IP地址，后面加空格加端口号</p></blockquote></li><li><p>virtual_server_group</p><blockquote><p>用来定义<code>virtual_server</code> 组，一般在超大型的LVS中用到，一般LVS用不过这东西。</p></blockquote></li></ul><span id="more"></span><h2 id="配置说明："><a href="#配置说明：" class="headerlink" title="配置说明："></a>配置说明：</h2><ul><li>注释以“＃”或“！”开头到行尾，可以从一行的任何位置开始。</li><li>关键字 <code>include</code> 允许在主配置文件中包含其他配置文件。</li><li>keepalived 还支持条件配置。(根据在启动 keepalived 时的命令行选项 -i 后面的参数，来确定指定命令是否生效)<blockquote><p>这样做的目的是允许单个配置文件用于多个系统，keepalived 中多个系统上的配置文件有区别的配置，可能只有以下几个配置，</p><ul><li>router_id，</li><li>vrrp实例优先级，</li><li>以及可能的接口名称。</li></ul></blockquote></li></ul><p>条件配置具体方法，示例</p><pre><code>global_defs&#123;  @main router_id main_router  @backup router_id backup_router&#125;&#125;</code></pre><p>以“@”开头的任何配置行都是条件配置行。 ‘@’字符紧接着的（即没有任何空格）字符串，会与使用 <code>-i</code> 命令行选项指定的字符串进行比较，如果不匹配匹配，则这条配置行被会被忽略。如，上面的配置，当使用 <code>/usr/local/keepalived/sbin/keepalived -f /etc/keepalived/keepalived.conf -i main</code> 启动 <code>keepalived</code> 时，则 <code>router_id</code> 将设置为 <code>main_router</code>。当使用 <code>-i backup</code> 参数启动时，则 <code>router_id</code> 将设置为 <code>backup_router</code>。</p><p><strong>注意</strong>：如果不使用 <code>-i</code> 或者 <code>-i</code> 后面是其他不匹配的参数启动时，则 <code>router_id</code> 将不会被设置。</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>包含的子块有，</p><ul><li>Global definitions，</li><li>static_ipaddress，</li><li>static_routes</li></ul><h3 id="Global-definitions"><a href="#Global-definitions" class="headerlink" title="Global definitions"></a>Global definitions</h3><h4 id="global-defs-区块"><a href="#global-defs-区块" class="headerlink" title="global_defs 区块"></a>global_defs 区块</h4><p>示例：</p><pre><code>global_defs &#123;   # 故障发生时给谁发邮件通知。   notification_email &#123;     acassen@firewall.loc     # ....   &#125;   # 通知邮件从哪个地址发出。   notification_email_from Alexandre.Cassen@firewall.loc   smtp_server 192.168.200.1   smtp_connect_timeout 30   router_id LVS_DEVEL   vrrp_skip_check_adv_addr   vrrp_strict   vrrp_garp_interval 0   vrrp_gna_interval 0&#125;</code></pre><ul><li><p>notification_email 故障发生时给谁发邮件通知。</p></li><li><p>notification_email_from 通知邮件从哪个地址发出。</p></li><li><p>smtp_server 通知邮件的smtp地址。</p><blockquote><p>格式：smtp_server 127.0.0.1 [<PORT>] # 带可选端口号的IP地址或域名（默认为25）</PORT></p></blockquote></li><li><p>smtp_helo_name</p><blockquote><p>格式：smtp_helo_name <HOST_NAME> # 在HELO消息中使用的名称（默认为本地主机名）</HOST_NAME></p></blockquote></li><li><p>smtp_connect_timeout 连接smtp服务器的超时时间。</p></li><li><p>router_id 标识本节点的字条串，通常为hostname，但不一定非得是hostname。故障发生时，邮件通知会用到。</p></li></ul><ul><li><p>vrrp_mcast_group4 224.0.0.18 # 可选, 默认为 224.0.0.18</p></li><li><p>vrrp_mcast_group6 ff02::12   # 可选, 默认为 ff02::12</p></li><li><p>default_interface p33p1.3    # 设置静态地址的默认接口，默认为eth0</p></li><li><p> lvs_sync_daemon <INTERFACE> <VRRP_INSTANCE> [id <SYNC_ID>] [maxlen <LEN>] [port <PORT>] [ttl <TTL>] [group <IP addr>]</IP></TTL></PORT></LEN></SYNC_ID></VRRP_INSTANCE></INTERFACE></p><blockquote><ul><li>＃绑定接口，vrrp实例  </li><li>＃syncid for lvs syncd</li><li>＃syncid（0 to 255）for lvs syncd</li><li>＃maxlen（1..65507）最大包长度</li><li>＃port（1..65535）要使用的UDP端口号</li><li>＃ttl（1..255）</li><li>＃group - 组播组地址（IPv4或IPv6）</li><li>＃注意：maxlen，port，ttl和group仅在Linux 4.3或更高版本上可用。</li></ul></blockquote></li><li><p>lvs_flush＃在启动时刷新任何现有的LVS配置</p></li><li><p>vrrp_garp_master_delay 10    # 秒，默认值5 ,0表示没有设置秒数</p><blockquote><p>在转换到MASTER之后的第二组ARP的延迟</p></blockquote></li><li><p>vrrp_garp_master_repeat 1    # default 5</p><blockquote><p>在转换到MASTER之后一次发送的ARP消息的数量</p></blockquote></li><li><p>vrrp_garp_lower_prio_delay 10</p><blockquote><p>当 MASTER 接收的较低优先级的 advert 延迟第二组ARP发送</p></blockquote></li><li><p>vrrp_garp_lower_prio_repeat 1</p><blockquote><p>当MASTER接收到较低优先级的广播之后，一次发送的RP消息的数量</p></blockquote></li><li><p>vrrp_garp_master_refresh 60  # secs, default 0 (no refreshing)</p><blockquote><p>MASTER 刷新<code>gratuitous ARPs</code>的最小时间间隔</p></blockquote></li><li><p>vrrp_garp_master_refresh_repeat 2 # default 1</p><blockquote><p>在 MASTER 状态时发送的<code>gratuitous ARPs</code>消息的数量</p></blockquote></li><li><p>vrrp_garp_interval 0.001          # decimal, seconds (resolution usecs). Default 0.</p><blockquote><p>接口发送的<code>gratuitous ARPs</code>的延迟时间（毫秒）</p></blockquote></li><li><p>vrrp_gna_interval 0.000001        # decimal, seconds (resolution usecs). Default 0.</p><blockquote><p>接口发送的 主动NA消息 之间的延迟（ms）</p></blockquote></li><li><p>vrrp_lower_prio_no_advert [<BOOL>]</BOOL></p><blockquote><p>如果收到较低优先级的广告，请不要发送另一个广告。 默认为false，除非设置了strict_mode。</p></blockquote></li><li><p>vrrp_version &lt;2 or 3&gt;        # default version 2</p><blockquote><p>设置要使用的默认VRRP版本</p></blockquote></li><li><p>vrrp_iptables keepalived     # default INPUT</p><blockquote><ul><li>＃指定 iptables链 以确保版本3实例不对其不拥有的地址做出响应。</li><li>＃注意：指定的 链 必须存在于 <code>iptables</code>/<code>ip6tables</code>配置中，并且链从<code>iptables</code>配置中的适当点调用。</li><li>＃可能需要在接受任何<code>ESTABLISHED</code>，<code>RELATED</code>数据包之后进行此过滤，因为<code>IPv4</code>可能选择<code>VIP</code>作为传出连接的源地址。</li></ul></blockquote></li><li><p>vrrp_iptables keepalived_in keepalived_out</p><blockquote><ul><li>＃或用于出站过滤</li><li>＃注意，出站过滤将不适用于IPv4，因为可以选择VIP作为出站连接的源地址。 对于IPv6，由于地址已过时，因此不太可能。</li></ul></blockquote></li><li><p>vrrp_iptables</p><blockquote><p>或者不添加任何iptables规则：</p></blockquote></li><li><p>vrrp_ipset [keepalived [keepalived6 [keepalived_if6]]]</p><blockquote><ul><li>＃Keepalived可以选择使用iptables结合使用ipetsets。</li><li>＃如果是这样，那么可以指定 ipset 名称，默认如下。</li><li>＃如果未指定名称，则不使用 ipsets，否则将通过向先前指定的名称添加“<code>_if</code>”和/或“<code>6</code>”来构造任何省略的名称。</li></ul></blockquote></li></ul><ul><li>vrrp_check_unicast_src<blockquote><p>＃以下启用检查在单播模式下，VRRP数据包的源地址是我们的单播对等体之一。</p></blockquote></li></ul><ul><li>vrrp_skip_check_adv_addr     # Default - don’t skip<blockquote><ul><li>＃查看接收到的VRRP报文中的所有地址可能比较耗时。</li><li>＃设置此标志表示如果广告来自与接收的上一个广告相同的主路由器，则不执行检查。</li></ul></blockquote></li></ul><ul><li>vrrp_strict<blockquote><p>＃严格遵守VRRP协议。 这将禁止：</p><ul><li>0 VIPs</li><li>unicast peers (单播对等体)</li><li>IPv6 addresses in VRRP version 2(VRRP版本2中的IPv6地址)</li></ul></blockquote></li></ul><hr><p>如果vrrp或检查程序超时，则可以使用以下4个选项。 这可以通过备份vrrp实例成为主，即使是因为主或备份系统太忙，无法处理vrrp数据包，但主服务器仍然运行的情况。</p><ul><li>vrrp_priority &lt;-20 to 19&gt;    # 设置vrrp子进程优先级 。 （负值增加优先级）</li><li>checker_priority &lt;-20 to 19&gt; # 设置 子进程检查器优先级</li><li>vrrp_no_swap                 # 设置vrrp子进程不可交换</li><li>checker_no_swap              # 设置 子进程检查器不可交换</li></ul><hr><p>如果 <code>Keepalived</code> 已构建与SNMP支持，以下关键字可用</p><blockquote><p>注意：Keepalived, checker 和 RFC支持 可以单独启用/禁用</p></blockquote><ul><li>snmp_socket udp:1.2.3.4:705  # 指定用于连接到SNMP主代理的套接字（默认<code>unix:/var/agentx/master</code>）<pre><code>                         # 除非使用网络命名空间，默认为udp：`udp:localhost:705`</code></pre></li><li>enable_snmp_keepalived       # 启用SNMP处理KEEPALIVED MIB的vrrp元素</li><li>enable_snmp_checker          # 启用SNMP处理KEEPALIVED MIB的checker元素</li><li>enable_snmp_rfc              # 启用SNMP处理 RFC2787 和 RFC6527 VRRP MIB</li><li>enable_snmp_rfcv2            # 启用SNMP处理 RFC2787 VRRP MIB</li><li>enable_snmp_rfcv3            # 启用SNMP处理 RFC6527 VRRP MIB</li><li>enable_traps                 # 启用SNMP陷阱</li></ul><hr><p>如果Keepalived已构建与DBus支持，以下关键字可用</p><ul><li><p>enable_dbus                  # 启用DBus接口</p></li><li><p>script_user username [groupname] # 如果未指定groupname，则其默认为用户的组</p><blockquote><ul><li>＃指定要在其下运行脚本的默认<code>用户名</code>/<code>组名</code>。</li><li>＃如果未指定此选项，则用户默认为 <code>keepalived_script</code>（如果该用户存在），否则为<code>root</code>。</li></ul></blockquote></li><li><p>enable_script_security       # 如果非必要，请不要配置为以<code>root</code>身份运行的脚本。</p></li></ul><h4 id="其它全局配置"><a href="#其它全局配置" class="headerlink" title="其它全局配置"></a>其它全局配置</h4><ul><li>net_namespace NAME         # 用于在单独的网络命名空间中运行keepalived<blockquote><ul><li>＃设置运行的网络命名空间<code>/var/run/keepalived </code>目录将创建为非共享挂载点，例如pid文件。</li><li> syslog条目将<code>_NAME</code>附加到 <code>ident</code>。</li></ul><p><strong>注意：</strong> 不能在配置重新加载时更改命名空间</p></blockquote></li></ul><ul><li><p>namespace_with_ipsets        </p><blockquote><p>＃<code>Linux 3.13</code>之前，网络命名空间找不到 <code>ipetsets</code> ，因此如果运行在早期版本的内核，默认情况下，如果使用命名空间和<code>vrrp_ipsets</code>没有指定， <code>ipsets</code> 是被禁用的。 此选项覆盖默认值，并允许将 <code>ipsets</code> 与 <code>3.11</code> 之前的内核上的命名空间一起使用。</p></blockquote></li><li><p>instance NAME               </p><blockquote><p>＃如果 <code>keepalived</code> 的多个实例在同一命名空间中运行，这将创建 pid 文件，其中 NAME 是文件名的一部分，在<code>/var/run/keepalived</code>中。</p><p>注意：不能在配置重新加载时更改实例名称</p></blockquote></li></ul><ul><li><p>use_pid_dir              # 在 <code>/var/run/keepalived</code> 创建 <code>pid</code> 文件</p></li><li><p>linkbeat_use_polling         # 轮询检测媒体链路故障，否则尝试使用 <code>ETHTOOL</code> 或 <code>MII</code> 接口</p></li></ul><h3 id="Static-routes-addresses-rules"><a href="#Static-routes-addresses-rules" class="headerlink" title="Static routes/addresses/rules"></a>Static routes/addresses/rules</h3><p>Keepalived可以配置静态地址，路由和规则。 如果我们的计算机上已有IP和路由，并且可以互相ping通，则不需要此部分。<br>规则和路由的语法与<code>ip rule add/ip route add</code>相同。</p><pre><code>static_ipaddress&#123;        192.168.1.1/24 dev eth0 scope global        ...&#125;</code></pre><pre><code>static_routes&#123;  192.168.2.0/24 via 192.168.1.100 dev eth0  192.168.100.0/24 table 6909 nexthop via 192.168.101.1 dev wlan0 onlink weight 1  nexthop  via  192.168.101.2  dev  wlan0 onlink weight 2  192.168.200.0/24  dev  p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 realms PQA/0x14 rto_min 108 initcwnd 109 initrwnd 110 features ecn  2001:470:69e9:1:2::4  dev  p33p1.2 table 6909 tos 0x04 protocol bird scope link priority 12 mtu 1000 hoplimit 100 advmss 101 rtt 102 rttvar 103 reordering 104 window 105 cwnd 106 ssthresh lock 107 rto_min 108 initcwnd 109  initrwnd  110  features ecn  ...&#125;</code></pre><pre><code>static_rules&#123;  from 192.168.2.0/24 table 1  to 192.168.2.0/24 table 1  from  192.168.28.0/24  to 192.168.29.0/26 table small iif p33p1 oif wlan0 tos 22 fwmark 24/12 preference 39 realms 30/20 goto 40  to 1:2:3:4:5:6:7:0/112 from 7:6:5:4:3:2::/96 table 6908  ...&#125;</code></pre><h2 id="VRRPD配置"><a href="#VRRPD配置" class="headerlink" title="VRRPD配置"></a>VRRPD配置</h2><p>包含的子块有，</p><ul><li>VRRP script(s),VRRP脚本</li><li>VRRP synchronization group(s), VRRP同步组</li><li>VRRP gratuitous ARP ,</li><li>unsolicited neighbour advert delay group(s), 主动邻居广播延迟组</li><li>VRRP instance(s),VRRP实例</li></ul><h3 id="VRRP-script-s"><a href="#VRRP-script-s" class="headerlink" title="VRRP script(s)"></a>VRRP script(s)</h3><p>添加要定期执行的脚本。 VRRP instances 会根据 脚本的退出码来调整优先级</p><pre><code>vrrp_script &lt;SCRIPT_NAME&gt; &#123;  script &lt;STRING&gt;|&lt;QUOTED-STRING&gt; # 脚本的路径执行  interval &lt;INTEGER&gt;  # 脚本调用之间的间隔，默认1秒  timeout &lt;INTEGER&gt;   # 脚本运行超时时间  weight &lt;INTEGER:-254..254&gt;  # 按此权重调整优先级，默认为2  rise &lt;INTEGER&gt;              # 转换为OK状态，所需的成功数量  fall &lt;INTEGER&gt;              # 转换为KO状态，所需的成功数量  user USERNAME [GROUPNAME]   # 运行脚本的 用户/组名 （组默认为用户组）  init_fail                   # 假设脚本最初处于失败状态&#125;</code></pre><h3 id="VRRP-synchronization-group-s-，VRRP同步组"><a href="#VRRP-synchronization-group-s-，VRRP同步组" class="headerlink" title="VRRP synchronization group(s)，VRRP同步组"></a>VRRP synchronization group(s)，VRRP同步组</h3><pre><code>#VG_1, 一起故障转移的IP组的名称vrrp_sync_group VG_1 &#123;   group &#123;     inside_network   # vrrp_instance的名称（见下文）     outside_network  # One for each movable IP     ...   &#125;   # 通知脚本和警报（可选）   #   ＃filenames的脚本在转换时运行，可以不加引号（如果只是文件名）或加引号（如果它有参数）用户名和组名指定脚本应该运行的用户和组。   ＃如果指定了username，则组默认为用户的组。   ＃如果未指定username，则它们默认为全局 script_user 和 script_group 到 MASTER 转换   notify_master /path/to_master.sh [username [groupname]]   # 转换成 BACKUP 状态   notify_backup /path/to_backup.sh [username [groupname]]   # 转换成 FAULT   notify_fault &quot;/path/fault.sh VG_1&quot; [username [groupname]]   # for ANY state transition.   # &quot;notify&quot; script is called AFTER the   # notify_* script(s) and is executed   # with 3 arguments provided by Keepalived   # (so don’t include parameters in the notify line).   # arguments   ＃ 对于任何状态的转换。   ＃ “notify”脚本在 notify_* 脚本之后调用，并使用 Keepalived 提供的3个参数执行（不包括通知行中的参数）。   ＃ 参数：   #    $1 = &quot;GROUP&quot;|&quot;INSTANCE&quot;   #    $2 = 组或实例的名称   #    $3 = 转型目标状态 (&quot;MASTER&quot;|&quot;BACKUP&quot;|&quot;FAULT&quot;)   notify /path/notify.sh [username [groupname]]   # 在状态转换期间使用global_defs中的地址发送电子邮件通知。   smtp_alert   global_tracking     # 所有VRRP共享相同的跟踪配置&#125;</code></pre><h3 id="VRRP-gratuitous-ARP-and-unsolicited-neighbour-advert-delay-group-s"><a href="#VRRP-gratuitous-ARP-and-unsolicited-neighbour-advert-delay-group-s" class="headerlink" title="VRRP gratuitous ARP and unsolicited neighbour advert delay group(s)"></a>VRRP gratuitous ARP and unsolicited neighbour advert delay group(s)</h3><p>指定发送 gratuitous ARPs 和未经请求的邻居 advert 的延迟的设置。 这是为了防止上游交换机无法处理 ARPs/NAs 泛滥。</p><ul><li>当限制适用于单个物理接口时使用接口。</li><li>当一组接口链接到同一交换机时使用接口，则限制适用于整个交换机。</li></ul><p>如果设置了全局<code>vrrp_garp_interval</code>或<code>vrrp_gna_interval</code>，那么在<code>garp_group</code>中未指定的任何接口时，将继承全局设置。</p><pre><code>garp_group &#123;  # 设置免费ARP之间的间隔（以秒，微秒为单位）  garp_interval &lt;DECIMAL&gt;  # 设置非请求 NA 之间的默认间隔（以秒，微秒为单位）  gna_interval &lt;DECIMAL&gt;  # 应用间隔的物理接口  interface &lt;STRING&gt;  # 聚合延迟的接口列表。  interfaces &#123;     &lt;STRING&gt;     &lt;STRING&gt;     ...     &#125;&#125;</code></pre><h3 id="VRRP-instance-s"><a href="#VRRP-instance-s" class="headerlink" title="VRRP instance(s)"></a>VRRP instance(s)</h3><p>描述了<code>vrrp_sync_group</code>中组的每个实例的IP。 这里描述两个IP（在<code>inside_network</code>和在<code>outer_network</code>），在机器“<code>my_hostname</code>”，属于组<code>VG_1</code>并且将在任何状态更改时一起转换。</p><pre><code># 除inside_network外，还需要为outer_network编写另一个块。vrrp_instance inside_network &#123;  # 初始状态，MASTER | BACKUP  # 一旦其他机器启动，将进行选举，具有最高优先级的机器将变为MASTER。  # 所以这里的配置并不重要。  state MASTER  # 为 inside_network 配置网络接口, 由 vrrp 绑定  interface eth0  # 使用VRRP虚拟MAC。  use_vmac [&lt;VMAC_INTERFACE&gt;]  # 从基本接口（而不是VMAC接口）发送/恢复VRRP消息  vmac_xmit_base  native_ipv6         # 强制实例使用IPv6（混合IPv4和IPv6配置时）。  # 忽略VRRP接口故障（默认未设置）  dont_track_primary  # 可选，监视  # 如果任何一个下降，进入FAULT状态。  track_interface &#123;    eth0    eth1    eth2 weight &lt;-254..254&gt;    ...  &#125;  # 向接口添加跟踪脚本（&lt;SCRIPT_NAME&gt;是vrrp_script条目的名称）  track_script &#123;      &lt;SCRIPT_NAME&gt;      &lt;SCRIPT_NAME&gt; weight &lt;-254..254&gt;  &#125;  # 默认 vrrpd 绑定的 IP 是接口上的主 IP 。 （可选的）  # 如果要隐藏 vrrpd 的位置，请将此 IP 当做 src_addr 用于组播或单播 vrrp 数据包。 （  # 因为它是多播，vrrpd 将获得答复数据包，无论使用什么 src_addr ）。  mcast_src_ip &lt;IPADDR&gt;  unicast_src_ip &lt;IPADDR&gt;  version &lt;2 or 3&gt;            # VRRP版本在接口上运行                              # default是全局参数vrrp_version。  # 不要通过 VRRP 组播组发送 VRRP adverts  # 相反，它使用单播将 adverts 发送到以下IP地址列表。 在不支持多播的网络环境中使用VRRP FSM和功能可能很酷！  # 指定的IP地址可以是IPv4和IPv6。  unicast_peer &#123;    &lt;IPADDR&gt;    ...  &#125;  # 接口特定设置，与全局参数相同; 默认为全局参数  garp_master_delay 10  garp_master_repeat 1  garp_lower_prio_delay 10  garp_lower_prio_repeat 1  garp_master_refresh 60  garp_master_refresh_repeat 2  garp_interval 100  gna_interval 100  lower_prio_no_advert [&lt;BOOL&gt;]  # 从0到255的任意唯一编号，用于区分在同一NIC（和相同的套接字）上运行的vrrpd的多个实例。  virtual_router_id 51  # 用于选择MASTER，最高优先级的会被选举出来。  # 超过50个以上的其它机器的设置，会被选为 MASTER  priority 100  # VRRP广告间隔（以秒为单位）（例如0.92）（使用默认值）  advert_int 1  # 注意：在2004年，RFC3768 从 VRRPv2 规范中删除了身份验证。  # 此选项的使用不符合规定，可能会导致问题;  # 所以尽可能避免使用，除非使用单播。  authentication &#123;     # 验证块      # PASS||AH      #   PASS - 简单密码（建议）      #   AH - IPSEC（不推荐）      auth_type PASS      # 访问vrrpd的密码。      # 应在所有机器上相同。      # 只使用前八（8）个字符。      auth_pass 1234  &#125;  # 设置虚拟IP地址，所有的机器上应该都使用相同的配置  virtual_ipaddress &#123;      &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt; label &lt;LABEL&gt;      192.168.200.17/24 dev eth1      192.168.200.18/24 dev eth2 label eth2:1  &#125;  # 从可选的VRRP中排除VRRP IP。  # 对于在同一接口上有大量（例如200）的IP的情况。 要减少广告中发送的数据包数量，我们可以从广告中排除大多数IP。  # 为virtual_ipaddress添加或者删除。  # 因为virtual_ipaddress中的所有地址必须是同一系列，所以如果我们希望能够添加IPv4和IPv6地址的混合，也可以使用，virtual_ipaddress_excluded 来进行配置。  virtual_ipaddress_excluded &#123;   &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt;   &lt;IPADDR&gt;/&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt;      ...  &#125;  # 设置接口上的promote_secondaries标志，以便在删除其中一个时，停止删除同一CIDR中的其他地址。例如，如果在接口上同时配置了10.1.1.2/24和10.1.1.3/24，一旦删除了一个，除非接口上设置了 promote_secondaries 标志，否则其他地址也将会被删除。  prompte_secondaries  # 当转换成 MASTER 时添加下面的routes，当转换成 BACKUP 时，会删除下面的routes 配置  # 有关详细信息，请参阅static_routes  virtual_routes &#123;      # src &lt;IPADDR&gt; [to] &lt;IPADDR&gt;/&lt;MASK&gt; via|gw &lt;IPADDR&gt; [or &lt;IPADDR&gt;] dev &lt;STRING&gt; scope &lt;SCOPE&gt; table &lt;TABLE&gt;      src 192.168.100.1 to 192.168.109.0/24 via 192.168.200.254 dev eth1      192.168.110.0/24 via 192.168.200.254 dev eth1      192.168.111.0/24 dev eth2      192.168.112.0/24 via 192.168.100.254      192.168.113.0/24 via 192.168.200.254 or 192.168.100.254 dev eth1      blackhole 192.168.114.0/24      0.0.0.0/0 gw 192.168.0.1 table 100  # To set a default gateway into table 100.  &#125;  # 当转换成 MASTER 时添加下面的 rules ，当转换成 BACKUP 时，会删除下面的 rules 配置  # 有关详细信息，请参阅static_rules  virtual_rules &#123;      from 192.168.2.0/24 table 1      to 192.168.2.0/24 table 1  &#125;  # VRRPv3有一个 接受模式，以允许虚拟路由器在没有地址所有者时接收发往VIP的数据包。 这是默认设置，除非设置了strict模式。  # 作为扩展，这也适用于VRRPv2（RFC 3768没有定义接受模式）。  accept          # 接受数据包到非地址所有者  no_accept       # 丢弃数据包到非地址所有者。  # 当较高优先级机器联机时，VRRP通常抢占较低优先级机器。 “nopreempt”允许较低优先级机器维护主机角色，即使较高优先级机器恢复在线时也是如此。  # 注意：要使其工作，此条目的初始状态必须为BACKUP。  nopreempt  preempt             # 用于向后兼容   # 请参见全局vrrp_skip_check_adv_addr的描述，它设置默认值。 默认为vrrp_skip_check_adv_addr   skip_check_adv_addr [on|off|true|false|yes|no]      # 如果没有指定，默认开启   # 请参见全局vrrp_strict的描述   # 如果未指定vrrp_strict，则它使用vrrp_strict的值   # 如果指定了不带参数的strict_mode，则其默认为on   strict_mode [on|off|true|false|yes|no]   # 启动后的秒数或看到较低优先级主机直到抢占（如果未由“nopreempt”禁用）。   # Range: 0 (default) to 1000   # 注意：要使其工作，此条目的初始状态必须为BACKUP。   preempt_delay 300    # 等待5分钟   # 调试级别，尚未实现。   debug &lt;LEVEL&gt;        # LEVEL是0到4范围内的数字   # 通知脚本，警报如上   notify_master &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]   notify_backup &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]   notify_fault &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]   notify_stop &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]      # 在停止vrrp时执行   notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt; [username [groupname]]   smtp_alert&#125;# 用于SSL_GET检查的参数。# 如果未指定任何参数，则将自动生成SSL上下文。SSL &#123;   password &lt;STRING&gt;   # 密码   ca &lt;STRING&gt;         # ca文件   certificate &lt;STRING&gt;  # 证书文件   key &lt;STRING&gt;        # 密钥文件&#125;          </code></pre><h2 id="LVS-配置"><a href="#LVS-配置" class="headerlink" title="LVS 配置"></a>LVS 配置</h2><p>包含的子块有，</p><ul><li>Virtual server group(s) ,虚拟服务器组</li><li>Virtual server(s) ,虚拟服务器</li></ul><p>子块包含了 ipvsadm（8）的参数。  了解 ipvsadm（8）将会有助于我们的配置。</p><h3 id="Virtual-server-group-s-虚拟服务器组"><a href="#Virtual-server-group-s-虚拟服务器组" class="headerlink" title="Virtual server group(s) ,虚拟服务器组"></a>Virtual server group(s) ,虚拟服务器组</h3><pre><code># 可选配置项# 此组允许real_server上的服务属于多个虚拟服务，并且只进行一次健康检查。# 仅适用于非常大的LVS。virtual_server_group &lt;STRING&gt; &#123;       #VIP port       &lt;IPADDR&gt; &lt;PORT&gt;       &lt;IPADDR&gt; &lt;PORT&gt;       ...       # &lt;IPADDR RANGE&gt; 的格式为 XXX.YYY.ZZZ.WWW-VVV，例如 192.168.200.1-10 范围包括.1到.10地址       &lt;IPADDR RANGE&gt; &lt;PORT&gt;# VIP  VPORT 范围       &lt;IPADDR RANGE&gt; &lt;PORT&gt;       ...       fwmark &lt;INT&gt;  # fwmark       fwmark &lt;INT&gt;       ...  &#125;</code></pre><h3 id="Virtual-server-s-虚拟服务器"><a href="#Virtual-server-s-虚拟服务器" class="headerlink" title="Virtual server(s) ,虚拟服务器"></a>Virtual server(s) ,虚拟服务器</h3><p>virtual_server是一个<code>vip vport (IPADDR PORT pair)</code> 或  <code>fwmark &lt;INT&gt;</code> 的声明。</p><pre><code>(virtual server) group &lt;STRING&gt;# 设置服务virtual_server IP port |virtual_server fwmark int |virtual_server group string&#123;# 延迟定时器用于服务轮询delay_loop &lt;INT&gt;# LVS调度器lb_algo rr|wrr|lc|wlc|lblc|sh|dh# 启用散列条目hashed# 启用 flag-1 调度器 (-b flag-1 in ipvsadm)flag-1# 启用 flag-2 调度器(-b flag-2 in ipvsadm)flag-2# 启用 flag-3 调度器 (-b flag-3 in ipvsadm)flag-3# 启用 sh-port 调度器 (-b sh-port in ipvsadm)sh-port# 启用 sh-fallback 调度器  (-b sh-fallback in ipvsadm)sh-fallback# 为UDP启用单分组调度（在ipvsadm中为-O）ops# LVS转发方法lb_kind NAT|DR|TUN# LVS持久超时，秒persistence_timeout &lt;INT&gt;# LVS粒度掩码（ipvsadm中的-M）persistence_granularity &lt;NETMASK&gt;# 仅实现TCPprotocol TCP# 如果没有设置VS IP地址，则暂停healthchecker的活动ha_suspend# 用于HTTP_GET或SSL_GET的VirtualHost字符串# 例如 virtualhost www.firewall.locvirtualhost &lt;STRING&gt;# 假定所有RS关闭,并且在启动时检查运行状况失败。# 这有助于防止启动时的假的积极操作。 默认情况下禁用Alpha模式。alpha# 在守护程序关闭时，在适当的情况下，考虑降低仲裁和RS通知程序执行。# 默认情况下禁用Omega模式。omega# Minimum total weight of all live servers in# the pool necessary to operate VS with no# quality regression. Defaults to 1.quorum &lt;INT&gt;# Tolerate this much weight units compared to the# nominal quorum, when considering quorum gain# or loss. A flap dampener. Defaults to 0.hysteresis &lt;INT&gt;# 获得 quorum 时启动的脚本。quorum_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;# 丢失quorum时启动的脚本。quorum_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;# 设置 realserver(s)# 在所有 realserver 都关闭时生效sorry_server &lt;IPADDR&gt; &lt;PORT&gt;# 将 inhibit_on_failure 行为应用于前面的 sorry_server 指令sorry_server_inhibit# 每个realserver,一个条目real_server &lt;IPADDR&gt; &lt;PORT&gt;  &#123;      # 相对权重，默认：1      weight &lt;INT&gt;      # 健康检查器检测到故障时，将权重设置为0      inhibit_on_failure      # 当运行状况检查器将服务视为启动时启动的脚本。      notify_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;      # 当运行状况检查器将服务视为停机时启动的脚本。      notify_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;      # 选择一个健康检查      # HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|MISC_CHECK      # HTTP和SSL健康检查程序      HTTP_GET|SSL_GET      &#123;          # 一个url测试          # 可以有多个条目          url &#123;            # 例如 path / , or path /mrtg2/            path &lt;STRING&gt;            # healthcheck需要status_code或status_code和digest            # 摘要用genhash计算            # 例如 digest 9b3a0c85a887a256d6939da88aabd8cd            digest &lt;STRING&gt;            # HTTP标头中返回的状态代码            # 例如 status_code 200            status_code &lt;INT&gt;          &#125;          # 获取重试次数          nb_get_retry &lt;INT&gt;          # 延迟后重试          delay_before_retry &lt;INT&gt;          # ======== 通用连接选项          # 要连接的可选IP地址。          # 默认值为真实服务器的IP          connect_ip &lt;IP ADDRESS&gt;          # 可选，端口，如果没有连接          # 默认值为真实服务器的端口          connect_port &lt;PORT&gt;          # 用于发起连接的可选接口          bindto &lt;IP ADDRESS&gt;          # 用于发起连接的可选源端口          bind_port &lt;PORT&gt;          # 可选，连接超时（秒）。          # 默认值为5秒          connect_timeout &lt;INTEGER&gt;          # 可选，用于标记所有传出检查程序包的fwmark          fwmark &lt;INTEGER&gt;          # 可选的，随机延迟最大N秒后开始初始检查。          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用          warmup &lt;INT&gt;      &#125; # HTTP_GET|SSL_GET      # TCP健康检查器（绑定到IP端口）      TCP_CHECK      &#123;          # ======== 通用连接选项          # 可选，要连接的IP地址。          # 默认值为真实服务器的IP          connect_ip &lt;IP ADDRESS&gt;          # 可选，连接端口          # 默认值为真实服务器的端口          connect_port &lt;PORT&gt;          # 可选，发起连接使用的接口          bindto &lt;IP ADDRESS&gt;          # 可选，发起连接源端口          bind_port &lt;PORT&gt;          # 可选，连接超时（以秒为单位）。          # 默认值为5秒          connect_timeout &lt;INTEGER&gt;          # 可选， 用于标记所有传出检查程序包的fwmark          fwmark &lt;INTEGER&gt;          # 可选， 随机延迟最大N秒后开始初始检查。          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用          warmup &lt;INT&gt;      &#125; #TCP_CHECK      # SMTP健康检查器      SMTP_CHECK      &#123;          # 可选，主机接口检查。          # 如果没有主机指令，则只检查真实服务器的IP地址。          host &#123;            # ======== 通用连接选项            # 可选，要连接的IP地址。            # 默认值为真实服务器的IP            connect_ip &lt;IP ADDRESS&gt;            # 可选，连接端口            # 默认值为25            connect_port &lt;PORT&gt;            # 可选，发起连接使用的接口            bindto &lt;IP ADDRESS&gt;            # 可选，发起连接源端口            bind_port &lt;PORT&gt;            # 可选，每个主机连接超时。            # Default is outer-scope connect_timeout            connect_timeout &lt;INTEGER&gt;            # 可选， 用于标记所有传出检查程序包的fwmark            fwmark &lt;INTEGER&gt;         &#125;         # 连接超时时间         connect_timeout &lt;INTEGER&gt;         # 重试失败检查的次数         retry &lt;INTEGER&gt;         # 重试前延迟秒         delay_before_retry &lt;INTEGER&gt;         # 用于smtp HELO请求的可选字符串         helo_name &lt;STRING&gt;|&lt;QUOTED-STRING&gt;         # 可选， 随机延迟最大N秒后开始初始检查。         # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用         warmup &lt;INT&gt;      &#125; #SMTP_CHECK      # 运行外部程序，进行MISC健康检查      MISC_CHECK      &#123;          # 外部系统脚本或程序          misc_path &lt;STRING&gt;|&lt;QUOTED-STRING&gt;          # 脚本执行超时          misc_timeout &lt;INT&gt;          # 可选， 随机延迟最大N秒后开始初始检查。          # 用于将多个同时检查分散到同一个RS。 默认情况下启用，最大值为delay_loop。 指定 0 为禁用          warmup &lt;INT&gt;          # 如果设置，将会根据  healthchecker 退出状态码动态调整权重如下：          #   exit status 0: svc检查成功，权重不变。          #   exit status 1: svc检查失败.          #   exit status 2-255: svc检查成功，权重更改为小于退出状态2的值。          #   (示例：退出状态为 255 会将权重设置为 253 )          misc_dynamic          # 指定脚本应在其下运行的用户名/组名。 如果未指定GROUPNAME，则使用用户的组          user USERNAME [GROUPNAME]      &#125;  &#125; # realserver 定义&#125; # virtual service</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;keepalived只有一个配置文件 keepalived.conf ，里面主要包括以下几个配置区域，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;global_defs&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是配置故障发生时的通知对象以及机器标识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static_ipaddress&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置的是是本节点的IP信息。（如果当前服务器上已经配置了IP，那么这这个区域可以不用配置）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static_routes&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置的是是本节点的路由信息。（如果当前服务器上已经配置了路由，那么这这个区域可以不用配置）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vrrp_script&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来做健康检查的，当时检查失败时会将&lt;code&gt;vrrp_instance&lt;/code&gt;的&lt;code&gt;priority&lt;/code&gt;减少相应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vrrp_instance&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义对外提供服务的VIP区域及其相关属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vrrp_sync_group&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义&lt;code&gt;vrrp_intance&lt;/code&gt;组，使得这个组内成员动作一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;virtual_server&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟服务器，来源&lt;code&gt;vrrp_instance&lt;/code&gt; 中配置的 的虚拟IP地址，后面加空格加端口号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;virtual_server_group&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来定义&lt;code&gt;virtual_server&lt;/code&gt; 组，一般在超大型的LVS中用到，一般LVS用不过这东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>keepalived安装与配置</title>
    <link href="https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2017/02/11/keepalived%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2017-02-11T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.keepalived.org/download.html">keepalived 源码包下载地址:http://www.keepalived.org/download.html</a></p><h2 id="服务器内核要求"><a href="#服务器内核要求" class="headerlink" title="服务器内核要求"></a>服务器内核要求</h2><p>需要服务器内核支持：</p><ul><li><p>Kernel/User netlink socket</p><blockquote><p>netlink是基于socket的通信机制，由于socket本身的双工性、突发性、不阻塞性等特点，能够很好地满足内核空间与用户空间小量数据的及时交互，因此在Linux 2.6内核开始被广泛使用，例如内核态的netfilter与用户态的iptables的数据交换就是通过netlink机制完成的。</p></blockquote></li><li><p>LinuxVirtualServer</p><blockquote><p>在大部分 linux 发行版中，ipvs 被默认安装。如果没有安装则需要安装。<br>检查当前加载的内核模块，看是否存在 ip_vs 模块。</p></blockquote></li></ul><pre><code>[root@hd-4 ipvsadm-1.24]# lsmod|grep ip_vsip_vs 77569 0</code></pre><span id="more"></span><h3 id="安装-ipvs"><a href="#安装-ipvs" class="headerlink" title="安装 ipvs"></a>安装 ipvs</h3><blockquote><p>Ipvs 具体实现是由 ipvsadm 这个程序来完成，因此判断一个系统是否具备 ipvs 功能，也可以查看 ipvsadm 程序是否被安装。查看 ipvsadm 程序最简单的办法就是在任意路径执行命令 ipvsadm。</p></blockquote><p>ipvs 版本的选择：</p><blockquote><p>由于IPVS与用户空间的接口在不同的Linux内核版本中不同，因此在不同的Linux内核版本中有不同版本的 ipvsadm 用于IPVS。</p><ul><li>对于Linux内核2.6中的IPVS，需要使用ipvsadm 1.24版或更高版本。</li><li>对于Linux内核2.4中的IPVS，需要使用ipvsadm 1.21系列。</li><li>对于Linux内核2.2的IPVS补丁，需要使用ipvsadm版本1.15。</li></ul><p>当前我使用的Linux内核是 <code>2.6.32-642.6.2.el6.i686</code> ,所以选择了 <code>ipvsadm-1.26</code>.</p></blockquote><p><a href="http://www.linuxvirtualserver.org/software/ipvs.html">ipvsadm 下载地址：http://www.linuxvirtualserver.org/software/ipvs.html</a></p><pre><code>[root@localhost ~]# wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz[root@localhost ~]# tar zxvf ipvsadm-1.26.tar.gz[root@localhost ~]# cd ipvsadm-1.26[root@localhost ipvsadm-1.26]# make[root@localhost ipvsadm-1.26]# make install</code></pre><p>装完之后，ipvsadm 产生的文件列表：</p><pre><code>/sbin/ipvsadm/sbin/ipvsadm-save/sbin/ipvsadm-restore/usr/man/man8/ipvsadm.8/usr/man/man8/ipvsadm-save.8/usr/man/man8/ipvsadm-restore.8/etc/rc.d/init.d/ipvsadm</code></pre><p>执行 ipvsadm</p><pre><code>[root@localhost ipvsadm-1.26]# ipvsadmIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</code></pre><p>查看当前加载的内核模块，看是否已经存在 ip_vs 模块。</p><pre><code>[root@localhost ipvsadm-1.26]# lsmod | grep ip_vsip_vs                 103551  0libcrc32c                841  1 ip_vsipv6                  271777  16 ip_vs,ip6t_REJECT,nf_conntrack_ipv6,nf_defrag_ipv6</code></pre><p>至此，ipvs 就已经安装成功。</p><p><strong>安装 ipvs 时，可能会遇到的问题：</strong></p><ul><li><p>1、<code>can&#39;t find file &#39;netlink/netlink.h&#39;</code></p><pre><code>make -C libipvsmake[1]: Entering directory `/root/ipvsadm-1.26/libipvs&#39;gcc -Wall -Wunused -Wstrict-prototypes -g -fPIC -DLIBIPVS_USE_NL  -DHAVE_NET_IP_VS_H -c -o libipvs.o libipvs.c在包含自 libipvs.h：13 的文件中，               从 libipvs.c：23:ip_vs.h:15:29: 错误：netlink/netlink.h：没有那个文件或目录ip_vs.h:16:31: 错误：netlink/genl/genl.h：没有那个文件或目录ip_vs.h:17:31: 错误：netlink/genl/ctrl.h：没有那个文件或目录In file included from libipvs.h:13,               from libipvs.c:23:...</code></pre><p>解决方法：安装 <code>libnl</code> 和 <code>popt</code> 相关的包</p><pre><code># yum install libnl* popt*</code></pre></li><li><p>2、</p></li></ul><pre><code># makemake -C libipvsmake[1]: Entering directory `/var/tmp/ipvsadm-1.24/libipvs&#39;gcc -Wall -Wunused -Wstrict-prototypes -g -O2 -I/usr/src/linux/include  -DHAVE_NET_IP_VS_H -c -o libipvs.o libipvs.cIn file included from libipvs.c:23:libipvs.h:14:23: net/ip_vs.h: No such file or directoryIn file included from libipvs.c:23:libipvs.h:119: error: syntax error before &quot;fwmark&quot;libipvs.h:119: warning: function declaration isn&#39;t a prototypelibipvs.c:27: error: field `svc&#39; has incomplete typelibipvs.c:28: error: field `dest&#39; has incomplete typelibipvs.c: In function `ipvs_init&#39;:libipvs.c:40: error: invalid application of `sizeof&#39; to incomplete type `ip_vs_getinfo&#39;libipvs.c:44: error: `IP_VS_SO_GET_INFO&#39; undeclared (first use in this function)libipvs.c:44: error: (Each undeclared identifier is reported only oncelibipvs.c:44: error: for each function it appears in.)libipvs.c: In function `ipvs_getinfo&#39;:libipvs.c:56: error: invalid application of `sizeof&#39; to incomplete type `ip_vs_getinfo&#39;libipvs.c:57: error: `IP_VS_SO_GET_INFO&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_version&#39;:libipvs.c:64: error: invalid use of undefined type `struct ip_vs_getinfo&#39;libipvs.c: In function `ipvs_flush&#39;:libipvs.c:70: error: `IP_VS_SO_SET_FLUSH&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_add_service&#39;:libipvs.c:79: error: `IP_VS_SO_SET_ADD&#39; undeclared (first use in this function)libipvs.c:79: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_update_service&#39;:libipvs.c:87: error: `IP_VS_SO_SET_EDIT&#39; undeclared (first use in this function)libipvs.c:87: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_del_service&#39;:libipvs.c:95: error: `IP_VS_SO_SET_DEL&#39; undeclared (first use in this function)libipvs.c:95: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_zero_service&#39;:libipvs.c:103: error: `IP_VS_SO_SET_ZERO&#39; undeclared (first use in this function)libipvs.c:103: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_add_dest&#39;:libipvs.c:109: error: dereferencing pointer to incomplete typelibipvs.c:109: error: dereferencing pointer to incomplete typelibipvs.c:112: error: `IP_VS_SO_SET_ADDDEST&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_update_dest&#39;:libipvs.c:119: error: dereferencing pointer to incomplete typelibipvs.c:119: error: dereferencing pointer to incomplete typelibipvs.c:122: error: `IP_VS_SO_SET_EDITDEST&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_del_dest&#39;:libipvs.c:129: error: dereferencing pointer to incomplete typelibipvs.c:129: error: dereferencing pointer to incomplete typelibipvs.c:132: error: `IP_VS_SO_SET_DELDEST&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_set_timeout&#39;:libipvs.c:140: error: `IP_VS_SO_SET_TIMEOUT&#39; undeclared (first use in this function)libipvs.c:141: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_start_daemon&#39;:libipvs.c:148: error: `IP_VS_SO_SET_STARTDAEMON&#39; undeclared (first use in this function)libipvs.c:149: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_stop_daemon&#39;:libipvs.c:156: error: `IP_VS_SO_SET_STOPDAEMON&#39; undeclared (first use in this function)libipvs.c:157: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_get_services&#39;:libipvs.c:166: error: dereferencing pointer to incomplete typelibipvs.c:167: error: invalid application of `sizeof&#39; to incomplete type `libipvs.h&#39;libipvs.c:167: error: invalid use of undefined type `struct ip_vs_getinfo&#39;libipvs.c:172: error: dereferencing pointer to incomplete typelibipvs.c:172: error: invalid use of undefined type `struct ip_vs_getinfo&#39;libipvs.c:174: error: `IP_VS_SO_GET_SERVICES&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_cmp_services&#39;:libipvs.c:189: error: dereferencing pointer to incomplete typelibipvs.c:189: error: dereferencing pointer to incomplete typelibipvs.c:193: error: dereferencing pointer to incomplete typelibipvs.c:193: error: dereferencing pointer to incomplete typelibipvs.c:197: error: dereferencing pointer to incomplete typelibipvs.c:197: error: dereferencing pointer to incomplete typelibipvs.c:201: error: dereferencing pointer to incomplete typelibipvs.c:201: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_sort_services&#39;:libipvs.c:208: error: dereferencing pointer to incomplete typelibipvs.c:208: error: dereferencing pointer to incomplete typelibipvs.c:209: error: invalid application of `sizeof&#39; to incomplete type `libipvs.h&#39;libipvs.c: In function `ipvs_get_dests&#39;:libipvs.c:218: error: dereferencing pointer to incomplete typelibipvs.c:218: error: invalid application of `sizeof&#39; to incomplete type `libipvs.h&#39;libipvs.c:218: error: dereferencing pointer to incomplete typelibipvs.c:224: error: dereferencing pointer to incomplete typelibipvs.c:224: error: dereferencing pointer to incomplete typelibipvs.c:225: error: dereferencing pointer to incomplete typelibipvs.c:225: error: dereferencing pointer to incomplete typelibipvs.c:226: error: dereferencing pointer to incomplete typelibipvs.c:226: error: dereferencing pointer to incomplete typelibipvs.c:227: error: dereferencing pointer to incomplete typelibipvs.c:227: error: dereferencing pointer to incomplete typelibipvs.c:228: error: dereferencing pointer to incomplete typelibipvs.c:228: error: dereferencing pointer to incomplete typelibipvs.c:231: error: `IP_VS_SO_GET_DESTS&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_cmp_dests&#39;:libipvs.c:243: error: dereferencing pointer to incomplete typelibipvs.c:243: error: dereferencing pointer to incomplete typelibipvs.c:247: error: dereferencing pointer to incomplete typelibipvs.c:247: error: dereferencing pointer to incomplete typelibipvs.c: In function `ipvs_sort_dests&#39;:libipvs.c:253: error: dereferencing pointer to incomplete typelibipvs.c:253: error: dereferencing pointer to incomplete typelibipvs.c:254: error: invalid application of `sizeof&#39; to incomplete type `libipvs.h&#39;libipvs.c: At top level:libipvs.c:259: error: syntax error before &quot;fwmark&quot;libipvs.c:260: warning: function declaration isn&#39;t a prototypelibipvs.c: In function `ipvs_get_service&#39;:libipvs.c:264: error: dereferencing pointer to incomplete typelibipvs.c:270: error: dereferencing pointer to incomplete typelibipvs.c:270: error: `fwmark&#39; undeclared (first use in this function)libipvs.c:271: error: dereferencing pointer to incomplete typelibipvs.c:271: error: `protocol&#39; undeclared (first use in this function)libipvs.c:272: error: dereferencing pointer to incomplete typelibipvs.c:272: error: `addr&#39; undeclared (first use in this function)libipvs.c:273: error: dereferencing pointer to incomplete typelibipvs.c:273: error: `port&#39; undeclared (first use in this function)libipvs.c:274: error: `IP_VS_SO_GET_SERVICE&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_get_timeout&#39;:libipvs.c:288: error: dereferencing pointer to incomplete typelibipvs.c:293: error: `IP_VS_SO_GET_TIMEOUT&#39; undeclared (first use in this function)libipvs.c: In function `ipvs_get_daemon&#39;:libipvs.c:309: error: dereferencing pointer to incomplete typelibipvs.c:315: error: `IP_VS_SO_GET_DAEMON&#39; undeclared (first use in this function)libipvs.c: At top level:libipvs.c:33: error: storage size of `ipvs_info&#39; isn&#39;t knownmake[1]: *** [libipvs.o] Error 1make[1]: Leaving directory `/var/tmp/ipvsadm-1.24/libipvs&#39;make: *** [libs] Error 2</code></pre><p>这个问题一般是编译器找不到 服务器 kernel 的源码路径。解决方法是，创建一个当前系统的 kernel 源码路径的 连接到 <code>/usr/src/linux</code>。如，</p><pre><code>ln –sv /usr/src/kernels/2.6.32-642.6.2.el6.i686 /usr/src/linux</code></pre><blockquote><p>注意一定要与当前的运行的内核相一致，因为 <code>/usr/src/kernels</code> 目录下可多个目录。</p><p>若<code>/usr/src/kernel</code>目录下没有内核目录，则需要安装内核开发包：</p><ul><li>用命令<code>uname -a</code>查看内核版本，</li><li>然后可以在这里查找对应的 <code>kernel</code> 开发包(<a href="https://www.kernel.org/pub/linux/kernel/v2.6/">https://www.kernel.org/pub/linux/kernel/v2.6/</a>)</li></ul><p>不推荐使用 <code>yum install -y kernel-devel</code> 安装</p></blockquote><h2 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h2><ul><li>gcc、gcc-c++</li><li>openssl-dev</li></ul><p>报错：</p><pre><code>configure: error:  !!! OpenSSL is not properly installed on your system. !!!  !!! Can not include OpenSSL headers files.            !!!</code></pre><p>安装：</p><pre><code>yum install openssl-devel -y</code></pre><ul><li>libnfnetlink-devel</li></ul><p>报错：</p><pre><code>configure: error:    !!! Please install libnfnetlink headers.              !!!</code></pre><p>安装：</p><pre><code>yum install -y libnfnetlink-devel</code></pre><h2 id="keepalived-安装"><a href="#keepalived-安装" class="headerlink" title="keepalived 安装"></a>keepalived 安装</h2><pre><code>[root@localhost ~]# wget http://www.keepalived.org/software/keepalived-1.3.2.tar.gz[root@localhost ~]# tar zxvf keepalived-1.3.2.tar.gz[root@localhost ~]# cd keepalived-1.3.2[root@localhost keepalived-1.3.2]# ./configure --prefix=/usr/local/keepalived...Keepalived configuration------------------------Keepalived version       : 1.3.2Compiler                 : gccPreprocessor flags       :  -I/usr/include/libnl3  Compiler flags           : -Wall -Wunused -Wstrict-prototypes -Wextra -g -O2   Linker flags             :Extra Lib                : -ldl -lssl -lcrypto  -lnl-3 -lnl-genl-3 -lnl-route-3Use IPVS Framework       : YesIPVS use libnl           : YesIPVS syncd attributes    : NoIPVS 64 bit stats        : Nofwmark socket support    : YesUse VRRP Framework       : YesUse VRRP VMAC            : YesUse VRRP authentication  : YesWith ip rules/routes     : YesSNMP vrrp support        : NoSNMP checker support     : NoSNMP RFCv2 support       : NoSNMP RFCv3 support       : NoDBUS support             : NoSHA1 support             : NoUse Debug flags          : NoStacktrace support       : NoMemory alloc check       : Nolibnl version            : 3Use IPv4 devconf         : NoUse libiptc              : NoUse libipset             : Noinit type                : upstartBuild genhash            : YesBuild documentation      : No[root@localhost keepalived-1.3.2]# make &amp;&amp; make install[root@localhost keepalived-1.3.2]# cd /usr/local/keepalived/[root@localhost keepalived]# tree ..├── bin│   └── genhash├── etc│   ├── init│   │   └── keepalived.conf│   ├── keepalived│   │   ├── keepalived.conf│   │   └── samples│   │       ├── client.pem│   │       ├── dh1024.pem│   │       ├── keepalived.conf.fwmark│   │       ├── keepalived.conf.HTTP_GET.port│   │       ├── keepalived.conf.inhibit│   │       ├── keepalived.conf.IPv6│   │       ├── keepalived.conf.misc_check│   │       ├── keepalived.conf.misc_check_arg│   │       ├── keepalived.conf.quorum│   │       ├── keepalived.conf.sample│   │       ├── keepalived.conf.SMTP_CHECK│   │       ├── keepalived.conf.SSL_GET│   │       ├── keepalived.conf.status_code│   │       ├── keepalived.conf.track_interface│   │       ├── keepalived.conf.virtualhost│   │       ├── keepalived.conf.virtual_server_group│   │       ├── keepalived.conf.vrrp│   │       ├── keepalived.conf.vrrp.localcheck│   │       ├── keepalived.conf.vrrp.lvs_syncd│   │       ├── keepalived.conf.vrrp.routes│   │       ├── keepalived.conf.vrrp.rules│   │       ├── keepalived.conf.vrrp.scripts│   │       ├── keepalived.conf.vrrp.static_ipaddress│   │       ├── keepalived.conf.vrrp.sync│   │       ├── root.pem│   │       └── sample.misccheck.smbcheck.sh│   └── sysconfig│       └── keepalived├── sbin│   └── keepalived└── share    ├── man    │   ├── man1    │   │   └── genhash.1    │   ├── man5    │   │   └── keepalived.conf.5    │   └── man8    │       └── keepalived.8    └── snmp        └── mibs14 directories, 34 files</code></pre><h2 id="keepalived-配置与管理"><a href="#keepalived-配置与管理" class="headerlink" title="keepalived 配置与管理"></a>keepalived 配置与管理</h2><p>简单的配置示例</p><pre><code># cat keepalived.conf! Configuration File for keepalived# 全局配置global_defs &#123;   #指定keepalived在发生切换时需要发送email到的对象，一行一个   notification_email &#123;     acassen@firewall.loc     failover@firewall.loc     sysadmin@firewall.loc   &#125;   notification_email_from Alexandre.Cassen@firewall.loc #指定发件人   smtp_server 192.168.200.1  #指定smtp服务器地址   smtp_connect_timeout 30  #指定smtp连接超时时间   router_id LVS_DEVEL  #运行keepalived机器的一个标识&#125;vrrp_instance VI_1 &#123;    state MASTER  #指定那个为master，那个为backup，如果设置了nopreempt这个值不起作用，主备考priority决定    interface eth0  #设置实例绑定的网卡    virtual_router_id 51  #VPID标记    priority 100  #优先级，高优先级竞选为master    advert_int 1  #检查间隔，默认1秒    authentication &#123;  #设置认证        auth_type PASS   #认证方式        auth_pass 1111   #认证密码    &#125;    virtual_ipaddress &#123;  #设置vip        192.168.200.16        192.168.200.17        192.168.200.18    &#125;&#125;virtual_server 192.168.200.100 443 &#123;    delay_loop 6   #健康检查时间间隔    lb_algo rr  #lvs调度算法rr|wrr|lc|wlc|lblc|sh|dh    lb_kind NAT  #负载均衡转发规则NAT|DR|RUN    nat_mask 255.255.255.0    persistence_timeout 50   #会话保持时间    protocol TCP  #使用的协议    real_server 192.168.201.100 443 &#123;        weight 1        SSL_GET &#123;            url &#123; #检查url，可以指定多个              path /              digest ff20ad2481f97b1754ef3e12ecd3a9cc            &#125;            url &#123;              path /mrtg/              digest 9b3a0c85a887a256d6939da88aabd8cd            &#125;            connect_timeout 3 #连接超时时间            nb_get_retry 3  #重连次数            delay_before_retry 3   #重连间隔时间        &#125;    &#125;&#125;virtual_server 10.10.10.2 1358 &#123;    delay_loop 6    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    sorry_server 192.168.200.200 1358    real_server 192.168.200.2 1358 &#123;        weight 1        HTTP_GET &#123;            url &#123;              path /testurl/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl2/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl3/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            connect_timeout 3            nb_get_retry 3            delay_before_retry 3        &#125;    &#125;    real_server 192.168.200.3 1358 &#123;        weight 1        HTTP_GET &#123;            url &#123;              path /testurl/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334c            &#125;            url &#123;              path /testurl2/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334c            &#125;            connect_timeout 3            nb_get_retry 3            delay_before_retry 3        &#125;    &#125;&#125;virtual_server 10.10.10.3 1358 &#123;    delay_loop 3    lb_algo rr    lb_kind NAT    nat_mask 255.255.255.0    persistence_timeout 50    protocol TCP    real_server 192.168.200.4 1358 &#123;        weight 1        HTTP_GET &#123;            url &#123;              path /testurl/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl2/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl3/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            connect_timeout 3            nb_get_retry 3            delay_before_retry 3        &#125;    &#125;    real_server 192.168.200.5 1358 &#123;        weight 1        HTTP_GET &#123;            url &#123;              path /testurl/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl2/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            url &#123;              path /testurl3/test.jsp              digest 640205b7b0fc66c1ea91c463fac6334d            &#125;            connect_timeout 3            nb_get_retry 3            delay_before_retry 3        &#125;    &#125;&#125;</code></pre><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><pre><code># keepalived -hUsage: keepalived [OPTION...]  -f, --use-file=FILE          使用指定的配置文件  -P, --vrrp                   只能使用VRRP子系统运行  -C, --check                  只能使用Health-checker子系统运行  -l, --log-console            将消息记录到本地控制台  -D, --log-detail             详细日志消息 /var/log/messages  -S, --log-facility=[0-7]     将syslog设置设置为LOG_LOCAL [0-7]  -V, --dont-release-vrrp      不要在守护程序停止时删除VRRP VIP和VROUTE  -I, --dont-release-ipvs      不要在守护程序停止时删除IPVS拓扑  -R, --dont-respawn           不要重新生成子进程  -n, --dont-fork              D不要fork守护进程  -d, --dump-conf              转储配置数据  -p, --pid=FILE               对父进程使用指定的pidfile  -r, --vrrp_pid=FILE          对VRRP子进程使用指定的pidfile  -c, --checkers_pid=FILE      使用指定的pidfile进行checkers子进程  -x, --snmp                   启用SNMP子系统  -v, --version                显示版本号  -h, --help                   显示此帮助消息</code></pre><p>示例，启动 keepalived</p><pre><code># keepalived -D -f /xxx/keepalived.conf</code></pre><p>查看进程列表，keepalived 是否已经启动</p><pre><code>]# ps aux | grep keepalivedroot      1371  0.0  0.1  17200  1092 ?        Ss   18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.confroot      1372  0.0  0.2  17256  2632 ?        S    18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.confroot      1373  0.0  0.1  17256  1840 ?        S    18:00   0:00 keepalived -D -f /etc/keepalived/keepalived.confroot      1390  0.0  0.0   6052   776 pts/0    S+   18:02   0:00 grep keepalived</code></pre><p>查看网络设置，虚拟IP是否已经设置</p><blockquote><p>使用 ifconfig 是看不到 虚拟IP 配置的</p></blockquote><pre><code># ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 08:00:27:bf:25:88 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.103/24 brd 192.168.1.255 scope global eth0    inet 192.168.200.16/32 scope global eth0    inet 192.168.200.17/32 scope global eth0    inet 192.168.200.18/32 scope global eth0    inet6 fe80::a00:27ff:febf:2588/64 scope link       valid_lft forever preferred_lft forever</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.keepalived.org/download.html&quot;&gt;keepalived 源码包下载地址:http://www.keepalived.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务器内核要求&quot;&gt;&lt;a href=&quot;#服务器内核要求&quot; class=&quot;headerlink&quot; title=&quot;服务器内核要求&quot;&gt;&lt;/a&gt;服务器内核要求&lt;/h2&gt;&lt;p&gt;需要服务器内核支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kernel/User netlink socket&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;netlink是基于socket的通信机制，由于socket本身的双工性、突发性、不阻塞性等特点，能够很好地满足内核空间与用户空间小量数据的及时交互，因此在Linux 2.6内核开始被广泛使用，例如内核态的netfilter与用户态的iptables的数据交换就是通过netlink机制完成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LinuxVirtualServer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在大部分 linux 发行版中，ipvs 被默认安装。如果没有安装则需要安装。&lt;br&gt;检查当前加载的内核模块，看是否存在 ip_vs 模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[root@hd-4 ipvsadm-1.24]# lsmod|grep ip_vs
ip_vs 77569 0
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="keepalived" scheme="https://weizhimiao.github.io/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>Github中Webhooks的应用</title>
    <link href="https://weizhimiao.github.io/2017/02/03/Github%E4%B8%ADwebhooks%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2017/02/03/Github%E4%B8%ADwebhooks%E5%BA%94%E7%94%A8/</id>
    <published>2017-02-03T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p><code>Webhooks</code> 是 <code>Github</code> 为我们提供的一种订阅某些时间的功能。当这些事件被触发时，<code>Github</code> 会将信息以<code>POST</code>方式发送到我们指定的<code>URL</code>。通过<code>Webhooks</code> 我们可以记录更新，触发<code>CI构建</code>、更新备份镜像，甚至服务器的自动部署等等我们能够想到的各个地方。</p><p><code>Github</code> 上对于每个账号或者项目上的每个事件最多可以创建20个 <code>Webhooks</code> 。</p><span id="more"></span><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>配置 <code>Webhook</code> 时，我们可以自定义具体的事件。只有定义定义的这些事件才会触发对指定的<code>URL</code>的请求。默认，<code>webhooks</code> 只订阅 <code>push</code> 事件，不过我们也可通过 <code>API</code> 或者 <code>UI</code> 来更改订阅事件的列表。</p><p>每个事件对应于可能发生在我们组织或 <code>Repository</code> 中的一组特定操作。 例如，如果订阅 <code>issues</code> 事件，则每次打开，关闭，标记 <code>issues</code> 时，我们都会收到详细的有效内容。</p><p>可用事件有：</p><table><thead><tr><th>事件名称</th><th>描述</th></tr></thead><tbody><tr><td><code>*</code></td><td>任何时间触发任何事件（通配符事件）。</td></tr><tr><td><code>commit_comment</code></td><td>每次提交被注释时。</td></tr><tr><td><code>create</code></td><td>每次分支或标记被创建时。</td></tr><tr><td><code>delete</code></td><td>每次分支或标记被删除时。</td></tr><tr><td><code>deployment</code></td><td>每次 <code>Repository</code> 被部署。</td></tr><tr><td><code>deployment_status</code></td><td>任何时候，Repository的部署有来自API的状态更新时。</td></tr><tr><td><code>fork</code></td><td>每次<code>Repository</code>被<code>fork</code>时。</td></tr><tr><td><code>gollum</code></td><td>每次<code>Wiki Page</code> 被更新时。</td></tr><tr><td><code>issue_comment</code></td><td>每次 <code>Issue</code> 中的评论被添加、编辑、或删除时。</td></tr><tr><td><code>issues</code></td><td>每次 <code>issue</code> 被分配、未分配，标记，未标记，打开，编辑，重大事件，拆除，关闭或重新打开时。</td></tr><tr><td><code>label</code></td><td>每次标签被创建、编辑、或删除时。</td></tr><tr><td><code>member</code></td><td>每次添加或删除一个协作者用户，或者更改他们的权限时。</td></tr><tr><td><code>membership</code></td><td>任何时候添加或删除团队中用户。（仅组织钩子）</td></tr><tr><td><code>milestone</code></td><td>每次创建、关闭、打开、编辑或删除 <code>milestone</code> （里程碑）时。</td></tr><tr><td><code>organization</code></td><td>任何时候添加，删除或邀请用户加入组织。 仅组织钩子。</td></tr><tr><td><code>page_build</code></td><td>每次页面网站建立时。</td></tr><tr><td><code>project_card</code></td><td>项目卡片创建，更新或删除。</td></tr><tr><td><code>project_column</code></td><td>项目 <code>column</code> 创建，更新，移动或删除时。</td></tr><tr><td><code>project</code></td><td>项目创建、编辑、或删除时。</td></tr><tr><td><code>public</code></td><td><code>Repository</code> 从private更改为public时。</td></tr><tr><td><code>pull_request_review_comment</code></td><td>每次pull请求被创建，编辑或删除差异注释时。</td></tr><tr><td><code>pull_request_review</code></td><td>每次提交Pull请求审核时。</td></tr><tr><td><code>pull_request</code></td><td>每次 pull 请求被打开，关闭，重新打开，编辑，分配，未分配，请求审核，审核请求已移除，已标记，未标记或已同步时。</td></tr><tr><td><code>push</code></td><td>每次 push 时（默认事件）</td></tr></tbody></table><p><code>repository</code>|每次 <code>Repository</code> 被创建、删除、公开或 私有化时。<br><code>release</code>|每次 <code>release</code> 被发布到 <code>Repository</code> 中时<br><code>status</code> |每次从API中更新版本库状态时。<br><code>team</code>   |任何时候创建，删除，修改 <code>Repository</code> 的团队。 仅组织钩子<br><code>team_add</code>|每次添加或修改 <code>Repository</code> 中的 team 成员时。<br><code>watch</code>  |每次用户对<code>Repository</code>加星标时。</p><h2 id="有效载荷"><a href="#有效载荷" class="headerlink" title="有效载荷"></a>有效载荷</h2><p>每个事件类型具有特定的有效载荷格式以及相关的事件信息。 即，不同的事件被触发发送到我们配置的 <code>URL</code> 的 <code>POST</code> 数据格式和内容也会不同。</p><p>例如，一个 <code>commit_comment</code> 事件如果被触发，将会向 URL 发送类似下面的内容。</p><pre><code>&#123;  &quot;action&quot;: &quot;created&quot;,  &quot;comment&quot;: &#123;    &quot;url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/comments/11056394&quot;,    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker/public-repo/commit/9049f1265b7d61be4a8904a9a27120d2064dab3b#commitcomment-11056394&quot;,    &quot;id&quot;: 11056394,    &quot;user&quot;: &#123;      &quot;login&quot;: &quot;baxterthehacker&quot;,      &quot;id&quot;: 6752317,      &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,      &quot;gravatar_id&quot;: &quot;&quot;,      &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,      &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,      &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,      &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,      &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,      &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,      &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,      &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,      &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,      &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,      &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,      &quot;type&quot;: &quot;User&quot;,      &quot;site_admin&quot;: false    &#125;,    &quot;position&quot;: null,    &quot;line&quot;: null,    &quot;path&quot;: null,    &quot;commit_id&quot;: &quot;9049f1265b7d61be4a8904a9a27120d2064dab3b&quot;,    &quot;created_at&quot;: &quot;2015-05-05T23:40:29Z&quot;,    &quot;updated_at&quot;: &quot;2015-05-05T23:40:29Z&quot;,    &quot;body&quot;: &quot;This is a really good change! :+1:&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;id&quot;: 35129377,    &quot;name&quot;: &quot;public-repo&quot;,    &quot;full_name&quot;: &quot;baxterthehacker/public-repo&quot;,    &quot;owner&quot;: &#123;      &quot;login&quot;: &quot;baxterthehacker&quot;,      &quot;id&quot;: 6752317,      &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,      &quot;gravatar_id&quot;: &quot;&quot;,      &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,      &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,      &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,      &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,      &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,      &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,      &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,      &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,      &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,      &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,      &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,      &quot;type&quot;: &quot;User&quot;,      &quot;site_admin&quot;: false    &#125;,    &quot;private&quot;: false,    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker/public-repo&quot;,    &quot;description&quot;: &quot;&quot;,    &quot;fork&quot;: false,    &quot;url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo&quot;,    &quot;forks_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/forks&quot;,    &quot;keys_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/keys&#123;/key_id&#125;&quot;,    &quot;collaborators_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/collaborators&#123;/collaborator&#125;&quot;,    &quot;teams_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/teams&quot;,    &quot;hooks_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/hooks&quot;,    &quot;issue_events_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues/events&#123;/number&#125;&quot;,    &quot;events_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/events&quot;,    &quot;assignees_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/assignees&#123;/user&#125;&quot;,    &quot;branches_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/branches&#123;/branch&#125;&quot;,    &quot;tags_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/tags&quot;,    &quot;blobs_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/blobs&#123;/sha&#125;&quot;,    &quot;git_tags_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/tags&#123;/sha&#125;&quot;,    &quot;git_refs_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/refs&#123;/sha&#125;&quot;,    &quot;trees_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/trees&#123;/sha&#125;&quot;,    &quot;statuses_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/statuses/&#123;sha&#125;&quot;,    &quot;languages_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/languages&quot;,    &quot;stargazers_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/stargazers&quot;,    &quot;contributors_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/contributors&quot;,    &quot;subscribers_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/subscribers&quot;,    &quot;subscription_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/subscription&quot;,    &quot;commits_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/commits&#123;/sha&#125;&quot;,    &quot;git_commits_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/git/commits&#123;/sha&#125;&quot;,    &quot;comments_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/comments&#123;/number&#125;&quot;,    &quot;issue_comment_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues/comments&#123;/number&#125;&quot;,    &quot;contents_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/contents/&#123;+path&#125;&quot;,    &quot;compare_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/compare/&#123;base&#125;...&#123;head&#125;&quot;,    &quot;merges_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/merges&quot;,    &quot;archive_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/&#123;archive_format&#125;&#123;/ref&#125;&quot;,    &quot;downloads_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/downloads&quot;,    &quot;issues_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/issues&#123;/number&#125;&quot;,    &quot;pulls_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/pulls&#123;/number&#125;&quot;,    &quot;milestones_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/milestones&#123;/number&#125;&quot;,    &quot;notifications_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/notifications&#123;?since,all,participating&#125;&quot;,    &quot;labels_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/labels&#123;/name&#125;&quot;,    &quot;releases_url&quot;: &quot;https://api.github.com/repos/baxterthehacker/public-repo/releases&#123;/id&#125;&quot;,    &quot;created_at&quot;: &quot;2015-05-05T23:40:12Z&quot;,    &quot;updated_at&quot;: &quot;2015-05-05T23:40:12Z&quot;,    &quot;pushed_at&quot;: &quot;2015-05-05T23:40:27Z&quot;,    &quot;git_url&quot;: &quot;git://github.com/baxterthehacker/public-repo.git&quot;,    &quot;ssh_url&quot;: &quot;git@github.com:baxterthehacker/public-repo.git&quot;,    &quot;clone_url&quot;: &quot;https://github.com/baxterthehacker/public-repo.git&quot;,    &quot;svn_url&quot;: &quot;https://github.com/baxterthehacker/public-repo&quot;,    &quot;homepage&quot;: null,    &quot;size&quot;: 0,    &quot;stargazers_count&quot;: 0,    &quot;watchers_count&quot;: 0,    &quot;language&quot;: null,    &quot;has_issues&quot;: true,    &quot;has_downloads&quot;: true,    &quot;has_wiki&quot;: true,    &quot;has_pages&quot;: true,    &quot;forks_count&quot;: 0,    &quot;mirror_url&quot;: null,    &quot;open_issues_count&quot;: 2,    &quot;forks&quot;: 0,    &quot;open_issues&quot;: 2,    &quot;watchers&quot;: 0,    &quot;default_branch&quot;: &quot;master&quot;  &#125;,  &quot;sender&quot;: &#123;    &quot;login&quot;: &quot;baxterthehacker&quot;,    &quot;id&quot;: 6752317,    &quot;avatar_url&quot;: &quot;https://avatars.githubusercontent.com/u/6752317?v=3&quot;,    &quot;gravatar_id&quot;: &quot;&quot;,    &quot;url&quot;: &quot;https://api.github.com/users/baxterthehacker&quot;,    &quot;html_url&quot;: &quot;https://github.com/baxterthehacker&quot;,    &quot;followers_url&quot;: &quot;https://api.github.com/users/baxterthehacker/followers&quot;,    &quot;following_url&quot;: &quot;https://api.github.com/users/baxterthehacker/following&#123;/other_user&#125;&quot;,    &quot;gists_url&quot;: &quot;https://api.github.com/users/baxterthehacker/gists&#123;/gist_id&#125;&quot;,    &quot;starred_url&quot;: &quot;https://api.github.com/users/baxterthehacker/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,    &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/baxterthehacker/subscriptions&quot;,    &quot;organizations_url&quot;: &quot;https://api.github.com/users/baxterthehacker/orgs&quot;,    &quot;repos_url&quot;: &quot;https://api.github.com/users/baxterthehacker/repos&quot;,    &quot;events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/events&#123;/privacy&#125;&quot;,    &quot;received_events_url&quot;: &quot;https://api.github.com/users/baxterthehacker/received_events&quot;,    &quot;type&quot;: &quot;User&quot;,    &quot;site_admin&quot;: false  &#125;&#125;</code></pre><p>其它事件的内容和格式，参考(<a href="https://developer.github.com/v3/activity/events/types/">https://developer.github.com/v3/activity/events/types/</a>)</p><p><strong>注意：</strong> 有效负载上限为<code>5 MB</code>。 如果我们的事件产生一个更大的有效载荷，<code>webhook</code> 将不会被触发。 例如，如果同时推送了多个分支或标签，则可能会发生在创建事件上。 所以建议监控我们的有效负载大小以确保 <code>webhooks</code> 能够被触发。</p><h3 id="请求Header"><a href="#请求Header" class="headerlink" title="请求Header"></a>请求Header</h3><p>对 <code>Webhook</code> 配置的 <code>URL</code> 端点发出的 <code>HTTP</code> 请求将包含几个特殊<code>Header</code>头：</p><table><thead><tr><th><code>Header</code></th><th><code>Description</code></th></tr></thead><tbody><tr><td><code>X-GitHub-Event</code></td><td>触发本次请求的事件的名称。</td></tr><tr><td><code>X-Hub-Signature</code></td><td>HMAC对有效负载的十六进制摘要，使用钩子的密钥作为密钥（如果已配置）。</td></tr><tr><td><code>X-GitHub-Delivery</code></td><td>本次请求的唯一ID。</td></tr></tbody></table><p>此外，请求的<code>User-Agent</code>将具有前缀<code>GitHub-Hookshot/</code>。</p><p>请求示例</p><pre><code>POST /payload HTTP/1.1Host: localhost:4567X-Github-Delivery: 72d3162e-cc78-11e3-81ab-4c9367dc0958User-Agent: GitHub-Hookshot/044aaddContent-Type: application/jsonContent-Length: 6615X-GitHub-Event: issues&#123;  &quot;action&quot;: &quot;opened&quot;,  &quot;issue&quot;: &#123;    &quot;url&quot;: &quot;https://api.github.com/repos/octocat/Hello-World/issues/1347&quot;,    &quot;number&quot;: 1347,    ...  &#125;,  &quot;repository&quot; : &#123;    &quot;id&quot;: 1296269,    &quot;full_name&quot;: &quot;octocat/Hello-World&quot;,    &quot;owner&quot;: &#123;      &quot;login&quot;: &quot;octocat&quot;,      &quot;id&quot;: 1,      ...    &#125;,    ...  &#125;,  &quot;sender&quot;: &#123;    &quot;login&quot;: &quot;octocat&quot;,    &quot;id&quot;: 1,    ...  &#125;&#125;</code></pre><h2 id="Ping事件"><a href="#Ping事件" class="headerlink" title="Ping事件"></a><code>Ping</code>事件</h2><p>当我们创建新的 <code>webhooks</code> 时，<code>Github</code> 会向我们配置的 <code>URL</code> 发送一个简单的 <code>ping</code> 事件，以检测我们配置的 <code>URL</code> 是否正确可用。 该事件未存储，因此无法通过<code>Events API</code>检索。 可以通过调用<code>ping</code>端点再次触发<code>ping</code>。</p><p><code>Ping</code>事件有效负载</p><table><thead><tr><th>键</th><th>值</th></tr></thead><tbody><tr><td><code>zen</code></td><td><code>GitHub</code>产生的随机字符串</td></tr><tr><td><code>hook_id</code></td><td>触发<code>ping</code>的<code>webhook</code>的<code>ID</code></td></tr><tr><td><code>hook</code></td><td><code>webhook</code>配置</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Webhooks&lt;/code&gt; 是 &lt;code&gt;Github&lt;/code&gt; 为我们提供的一种订阅某些时间的功能。当这些事件被触发时，&lt;code&gt;Github&lt;/code&gt; 会将信息以&lt;code&gt;POST&lt;/code&gt;方式发送到我们指定的&lt;code&gt;URL&lt;/code&gt;。通过&lt;code&gt;Webhooks&lt;/code&gt; 我们可以记录更新，触发&lt;code&gt;CI构建&lt;/code&gt;、更新备份镜像，甚至服务器的自动部署等等我们能够想到的各个地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; 上对于每个账号或者项目上的每个事件最多可以创建20个 &lt;code&gt;Webhooks&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://weizhimiao.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="git" scheme="https://weizhimiao.github.io/tags/git/"/>
    
    <category term="版本控制" scheme="https://weizhimiao.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之客户端C-服务器S设计与实现</title>
    <link href="https://weizhimiao.github.io/2017/01/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFC-%E6%9C%8D%E5%8A%A1%E5%99%A8S%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/22/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AFC-%E6%9C%8D%E5%8A%A1%E5%99%A8S%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-01-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道<code>Redis</code>是一个典型的<code>C/S</code>设计程序，一个服务器可以与多个客户端建立连接。通过<code>I/O</code>多路复用技术实现的文件事件处理器，<code>Redis</code>服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>所以，对于<code>Redis</code>我们分为这两部分来了解，</p><ul><li><code>Redis</code>服务器维护和管理客户端状态的方法</li><li><code>Redis</code>服务器的运行机制</li></ul><span id="more"></span><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的 <code>redisClient</code> 结构（客户端状态），这个结构保存了客户端当前的状态信息。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisClent<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token comment" spellcheck="true">// 客户端的套接字描述符</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 客户端的名字</span>  robj <span class="token operator">*</span>name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 客户端的标识值（flag）</span>  <span class="token keyword">int</span> flags<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输入缓冲区</span>  sqs querybuf<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 命令与命令参数</span>  robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 命令参数个数</span>  <span class="token keyword">int</span> argc<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//命令的实现函数</span>  <span class="token keyword">struct</span> redisCommand <span class="token operator">*</span>cmd<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出缓冲区</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 身份认证相关属性</span>  <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//</span>  time_t ctime<span class="token punctuation">;</span>  time_t lastinteraction<span class="token punctuation">;</span>  time_t obuf_soft_limit_reached_time<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> redisClient<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Redis</code>服务器状态结构的<code>clients</code>属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构(<code>redisClient</code>)，对客户端执行批量操作或者查找某个指定的客户端，都可以通过遍历 <code>clients</code> 链表来完成</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> redisServer <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span>  <span class="token comment" spellcheck="true">// 一个链表，保存了所有客户端状态</span>  list <span class="token operator">*</span>clients<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如图，是一个与三个客户端进行连接的服务器。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170116/clientsLianBiao.png" alt="clients 链表"></p><h3 id="客户端类型"><a href="#客户端类型" class="headerlink" title="客户端类型"></a>客户端类型</h3><p>按照处理的命令请求的来源，客户端可以分为以下两种：</p><ul><li><p>伪客户端</p><blockquote><p>处理来自<code>AOF</code>文件或者Lua脚本的命令请求。目前<code>Redis</code>会在两个地方用到伪客户端，</p><ul><li>用于载入 <code>AOF</code> 文件并还原数据库状态</li><li>用于执行<code>Lua</code>脚本中包含的<code>Redis</code>命令</li></ul></blockquote></li><li><p>普通客户端</p><blockquote><p>处理来自网络的普通命令请求。</p></blockquote></li></ul><p>两者的主要区别是，在客户端状态结构（<code>redisClient</code>）中的 <code>fd</code> 属性，伪客户端的该属性值为<code>-1</code>，普通客户端的该属性的值是普通客户端的套接字的描述符。</p><h3 id="客户端状态属性"><a href="#客户端状态属性" class="headerlink" title="客户端状态属性"></a>客户端状态属性</h3><p>客户端状态属性主要可以分为两类：</p><ul><li><p>比较通用的属性</p><ul><li>套接字描述，根据客户端端类型的不同，该属性的值可以是<code>-1</code> 或者是大于<code>-1</code> 的整数。</li><li>名字，默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 可以为客户端设置一个名字。</li><li>标识，记录了客户端的角色（<code>role</code>）如，主服务器，从服务器，低版本的从服务器，专门处理<code>Lua</code>脚本的伪客户端；以及客户端目前所处的状态，如客户端正在执行<code>MONITOR</code>命令，客户端正在被<code>BRPOP</code>、<code>BLPOP</code>等命令阻塞，客户端正在执行事务等等。</li><li>输入缓冲区，用于保存客户端发送的命令请求。</li><li>命令与命令参数，保存命令参数以及命令参数个数。</li><li>命令的实现函数，保存命令的实现函数。</li><li>输出缓冲区，保存执行命令所得的命令回复内容。</li><li>身份验证，用于记录客户端是否通过了身份验证。</li><li>时间，记录创建客户端的时间、客户端与服务器最后一次交互的时间、输出缓冲区第一次到达软性限制的时间等等。</li></ul></li><li><p>和特定功能相关的属性</p><ul><li><code>db</code>属性（数据库操作时需要）</li><li><code>dictid</code>属性（数据库操作时需要）</li><li><code>mstate</code>属性（执行事务时需要）</li><li><code>watched_keys</code>属性（执行<code>WATCH</code>命令时需要）</li><li>…</li></ul></li></ul><h3 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾。</p><p>对于Lua脚本的伪客户端，服务器会在初始化时，创建负责执行Lua脚本中包含的<code>Redis</code>命令的伪客户端，并将这个伪客户端关联在服务器状态结构的 <code>lua_client</code> 属性中。且 <code>lua_client</code> 伪客户端会在服务器运行的整个生命周期中会一直存在，只有在服务器关闭时，这个伪客户端才会关闭。</p><p>对于用户载入 <code>AOF</code> 文件还原数据库的伪客户端，会在服务器载入<code>AOF</code>文件时创建，用于执行<code>AOF</code>文件包含的<code>Redis</code>命令，在完成载入操作之后，这个伪客户端就会关闭。</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>对于一个普通客户端可以有多种原因而被关闭，</p><ul><li>客户端进程推出或者被杀死</li><li>客户单向服务器端发送了不符合协议格式的命令请求</li><li>客户端成为了 <code>CLIENT KILL</code> 命令的目标</li><li>客户端空转时间 大于了 <code>timeout</code> 的设置</li><li>客户端发送的命令请求的大小超过了输入缓冲区的大小限制（默认 <code>1GB</code>）</li><li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><code>Redis</code> 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h3 id="一条请求命令的执行过程"><a href="#一条请求命令的执行过程" class="headerlink" title="一条请求命令的执行过程"></a>一条请求命令的执行过程</h3><p>一条命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。，例如，执行 <code>redis&gt; SET KEY VALUE </code>这条命令的执行过程如下：</p><ul><li>1）客户端向服务器发送命令请求 <code>SET KEY VALUE</code></li><li>2）服务器接收并处理客户端发送过来的命令请求 <code>SET KEY VALUE</code>，在数据库中进行设置操作，并返回命令回复 <code>OK</code></li><li>3）服务器将命令回复<code>OK</code>发送给客户端</li><li>4）客户端接收服务器返回的命令回复<code>OK</code>，并将这个回复打印给用户</li></ul><h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingFaSongMingLingQingQiuDeGuoCheng.png" alt="客户端接收并发送命令请求的过程"><br>如图所示，用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令发送服务器。</p><p>示例，假设用户在客户端键入了命令：</p><pre class="line-numbers language-bash"><code class="language-bash">SET KEY VALUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么客户端会将这个命令转换成协议格式</p><pre class="line-numbers language-bash"><code class="language-bash">*3\r\n<span class="token variable">$3</span>\r\nSET\r\n<span class="token variable">$3</span>\r\nKEY\r\n<span class="token variable">$5</span>\r\nVALUE\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将这段协议内容发送给服务器。</p><h4 id="服务器读取命令请求"><a href="#服务器读取命令请求" class="headerlink" title="服务器读取命令请求"></a>服务器读取命令请求</h4><p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求出来器来执行一下操作。</p><ul><li>1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里。</li><li>2）对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及参数的个数，然后分别保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性中。</li><li>3）调用命令执行器，执行客户端指定的命令。</li></ul><p>示例，</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiZhongDeMingLingQingQiu.png" alt="客户端状态中的命令请求"></p><p>服务器将命令请求保存到客户端状态的输入缓冲区。之后，分析程序将对输入缓冲区的协议进行分析，并将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanZhuangTaiDeargvShuXingHeargcShuXing.png" alt="客户端状态的argv属性和argc属性"></p><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>分析程序将分析结果保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性里之后，服务器将通过调用命令执行器来完成执行命令所需的余下步骤。</p><ul><li><p>命令执行器：查找命令实现</p><blockquote><p>根据客户端状态的 <code>argv[0]</code> 参数，在命令表（<code>command table</code>） 中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性中。</p></blockquote></li><li><p>命令执行器：执行预备操作</p><blockquote><p>到目前为止，服务器已经将执行命令所需的命令实现函数（<code>cmd</code>属性）、参数（<code>argv</code>属性）、参数个数（<code>argc</code>属性）都收集齐了。但在真正执行命令前，还需要进行一些预备操作，从而确保命令能够正确的、顺序被执行。这些操作有，</p><ul><li>检查实现函数是否为空</li><li>检查参数个数满足当前实现函数的要求</li><li>检查客户端是否已经通过了身份验证</li><li>如果服务器打开了 <code>maxmemory</code> 功能，那么检查服务器的内从占用情况，并在有需要的情况下回收内存</li><li>如果服务器上一次执行 <code>BGSAVE</code> 命令出错，且打开了 <code>stop-writes-on-bgsave-error</code> 功能，且服务器当前要执行的是一个写命令，则拒绝执行这个命令，并返回错误。</li><li>检查服务器是否正处于某种状态（正在用<code>subscribe</code>命令订阅频道、正在用<code>psubscribe</code>命令订阅模式、正在进行数据载入、正在阻塞、正在执行事务），如果处于某种状态之下，则需要分别当前命令是否可以在该状态下被执行。</li><li>如果服务器打开了监视功能，那么服务器会将要执行的命令和参数等信息，发送给监视器。</li></ul><p>当完成以上操作之后，服务器就可以开始真正执行命令了。</p></blockquote></li><li><p>命令执行器：调用命令的实现函数</p><blockquote><p>因为之前服务器已经将要执行的命令的实现保存到了客户端状态的cmd属性、参数和个数分别保存到了<code>argv</code>属性和<code>argc</code>属性，所以当服务器决定要执行命令时，是需要执行就可以了。<code>client-&gt;cmd-&gt;proc(client);</code>实现函数执行完操作之后，会产生相应的命令回复，这些回复会保存在客户端状态的输出缓冲区里，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p></blockquote></li><li><p>命令执行器：执行后续操作</p><blockquote><p>在执行完函数之后，服务器还需要执行一些后续工作，</p><ul><li>如果服务器开启了慢日志功能，那么检查刚执行的命令是否符合条件</li><li>更新命令的<code>redisCommand</code>结构中<code>milliseconds</code>属性（执行命令耗费时长），和<code>calls</code>属性（被调用次数）</li><li>如果服务器开启<code>AOF</code>持久化功能，将刚执行的命令传播给所有从服务器</li></ul><p>到此，服务器对于当前命令的执行就告一段落了。</p></blockquote></li></ul><h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>前面的命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变成可写状态时，服务器就会执行命令回复处理器，将保存在输出缓冲区中的命令回复发送给客户端。</p><p>当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。</p><h4 id="客户端接收并打印命令回复"><a href="#客户端接收并打印命令回复" class="headerlink" title="客户端接收并打印命令回复"></a>客户端接收并打印命令回复</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170120/KeHuDuanJieShouBingDaYinMingLingHuiFuDeGuoCheng.png" alt="客户端接收并打印显示命令回复的过程"></p><h3 id="serverCron-函数"><a href="#serverCron-函数" class="headerlink" title="serverCron 函数"></a>serverCron 函数</h3><p><code>redis</code>服务器中的<code>serverCron</code>函数负责管理服务器的资源，并保持服务器自身的良好运转，其默认每隔 <code>100 ms</code> 执行一次。</p><p><code>serverCron</code>函数需要做的事情，</p><ul><li>更新服务器的时间缓存（用于获得当前时间时）</li><li>更新<code>LRU</code>时钟（用于计算键的空转事件）</li><li>更新服务器每秒执行命令次数</li><li>更新服务器内存峰值记录</li><li>处理<code>SIGTERM</code>信号</li><li>管理客户端资源</li><li>管理数据库资源</li><li>执行被延迟的<code>BGREWRITEAOF</code></li><li>检查持久化操作的运行状态</li><li>将<code>AOF</code>缓冲区中的内容写入<code>AOF</code>文件</li><li>关闭异步客户端</li><li>增加<code>cronloops</code>计数器值</li></ul><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个<code>redis</code>服务器从启动到能够接受客户端的命令请求，需要经过一些列的初始化和设置过程，如</p><ul><li>初始化服务器状态结构</li><li>载入配置选项</li><li>初始化服务器数据结构</li><li>还原数据库状态</li><li>执行事件循环</li></ul><h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>服务器状态结构指的就是 <code>redisServer</code> 结构，初始化服务器的第一步就是创建一个 <code>struct redisServer</code>类型的实例变量 <code>server</code> 作为服务器的状态，并为结构中的各个属性设置默认值。</p><p>具体初始化工作由 <code>redis.c/initServerConfig</code> 函数完成，<code>initServerConfig</code> 函数完成的主要工作是，</p><ul><li>设置服务器的运行ID</li><li>设置服务器的默认运行频率</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认<code>RDB</code>持久化条件和<code>AOF</code>持久化条件</li><li>创建命令表</li></ul><p>当<code>initServerConfig</code> 函数执行完毕之后，服务器就可以进入初始化的第二阶段–载入配置选项</p><h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>服务器在用 <code>initServerConfig</code> 函数初始化完 <code>server</code> 变量之后，就会载入用户给指定的配置参数和配置文件，并根据用户设定的配置，对 <code>server</code> 变量相关属性进行修改：</p><p>例如，</p><pre class="line-numbers language-bash"><code class="language-bash">$ redis-server --port 10086<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么我们就会修改了服务器默认的运行端口号。</p><pre class="line-numbers language-bash"><code class="language-bash">$ redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照配置文件中的配置，修改 <code>server</code> 变量属性。</p><p>服务器在载入用户指定的配置选项，并对<code>server</code>状态进行更新之后，服务器就可以进入初始化的第三个阶段–初始化服务器数据结构。</p><h4 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h4><p>在之前执行 <code>initServerConfig</code> 函数初始化 <code>server</code> 状态，程序只创建了命令表的一个数据结构，不过了命令表之外，服务器状态还包含其他数据结构。</p><ul><li><code>server.client</code> 链表，记录了所有与服务器相连的客户端的状态结构，链表的每个节点都包含了一个<code>redisClient</code>结构实例。</li><li><code>server.db</code> 数组，包含了服务器的所有数据库。</li><li><code>server.pubsub_channels</code> 字典，保存频道订阅信息。</li><li><code>server.pubsub_patterns</code> 链表，保存模式订阅信息。</li><li><code>server.lua</code>，保存执行<code>lua</code>脚本的<code>Lua</code>环境。</li><li><code>server.slowlog</code> ，保存慢查询日志。</li></ul><p>这些数据结构是通过 <code>iniServer</code> 函数来实现，为这些数据结构分配内存，并设置或关联初始化值。</p><p><code>iniServer</code> 函数除了初始化这些数据结构之外，还会进行一些其他非常重要的设置操作，包括:</p><ul><li>为服务器是指进程信号处理器</li><li>创建共享对象：这些对象包括<code>redis</code>服务器经常用到的一些值（如，包含“OK”回复的字符串对象，包含“ERR”回复的字符串对象，等等），服务器通过重用这些对象来避免反复重复的创建相同的对象。</li><li>打开服务器的监听端口，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接收客户端连接。</li><li>为 <code>serverCron</code> 函数创建时间事件，等待服务器正式运行时实行 <code>serverCron</code> 函数。</li><li>如果<code>AOF</code>持久化功能已经打开，那么打开现有的<code>AOF</code>文件，如果<code>AOF</code>文件不存在，那么创建并打开一个新的<code>AOF</code>文件，为<code>AOF</code>文件写入做好准备。</li><li>初始化后台<code>I/O</code>模块（<code>bio</code>），为将来的<code>I/O</code>操作做好准备。</li></ul><p>当<code>iniServer </code>函数执行完毕之后，服务器会用 <code>ASCII</code>字符在日志中打印出<code>Redis</code>的图标，以及Redis的版本信息。</p><pre class="line-numbers language-bash"><code class="language-bash">root@5254004e45d0:/srv/rorapps/redis/redis-2.8.15<span class="token comment" spellcheck="true"># src/redis-server</span><span class="token punctuation">[</span>16445<span class="token punctuation">]</span> 16 Sep 09:54:32.684 <span class="token comment" spellcheck="true"># Warning: no config file specified, using the default config. In order to specify a config file use src/redis-server /path/to/redis.conf</span><span class="token punctuation">[</span>16445<span class="token punctuation">]</span> 16 Sep 09:54:32.686 * Increased maximum number of <span class="token function">open</span> files to 10032 <span class="token punctuation">(</span>it was originally <span class="token keyword">set</span> to 1024<span class="token punctuation">)</span>.                _._                                                             _.-``__ <span class="token string">''</span>-._                                                   _.-`<span class="token variable"><span class="token variable">`</span>    <span class="token variable">`</span></span><span class="token keyword">.</span>  `_.  <span class="token string">''</span>-._           Redis 2.8.15 <span class="token punctuation">(</span>00000000/0<span class="token punctuation">)</span> 64 bit  .-`<span class="token variable"><span class="token variable">`</span> .-<span class="token variable">`</span></span>`<span class="token variable"><span class="token variable">`</span><span class="token keyword">.</span>  <span class="token variable">`</span></span>``\/    _.,_ <span class="token string">''</span>-._                                    <span class="token punctuation">(</span>    <span class="token string">'      ,       .-<span class="token variable"><span class="token variable">`</span>  <span class="token operator">|</span> <span class="token variable">`</span></span>,    )     Running in stand alone mode |<span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-...-<span class="token variable"><span class="token variable">`</span> __<span class="token punctuation">..</span>.-.<span class="token variable">`</span></span>`-._|'</span>` _.-<span class="token string">'|     Port: 6379 |    <span class="token variable"><span class="token variable">`</span>-._   <span class="token variable">`</span></span>._    /     _.-'</span>    <span class="token operator">|</span>     PID: 16445  <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._  `-./  _.-<span class="token string">'    _.-'</span>                                    <span class="token operator">|</span><span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._    `-.__.-<span class="token string">'    _.-'</span>_.-<span class="token string">'|                                   |    <span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._        _.-'</span>_.-<span class="token string">'    |           http://redis.io          <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._`-.__.-'</span>_.-<span class="token string">'    _.-'</span>                                    <span class="token operator">|</span><span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._    `-.__.-<span class="token string">'    _.-'</span>_.-<span class="token string">'|                                   |    <span class="token variable"><span class="token variable">`</span>-._<span class="token variable">`</span></span>-._        _.-'</span>_.-<span class="token string">'    |                                    <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-._`-.__.-'</span>_.-<span class="token string">'    _.-'</span>                                         <span class="token variable"><span class="token variable">`</span>-._    <span class="token variable">`</span></span>-.__.-<span class="token string">'    _.-'</span>                                                 `-._        _.-<span class="token string">'                                                         `-.__.-'</span>                                               <span class="token punctuation">[</span>16445<span class="token punctuation">]</span> 16 Sep 09:54:32.688 <span class="token comment" spellcheck="true"># Server started, Redis version 2.8.15</span><span class="token punctuation">[</span>16445<span class="token punctuation">]</span> 16 Sep 09:54:32.688 <span class="token comment" spellcheck="true"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><span class="token punctuation">[</span>16445<span class="token punctuation">]</span> 16 Sep 09:54:32.688 * The server is now ready to accept connections on port 6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h4><p>在完成对 <code>server</code> 变量的初始化之后，服务器需要载入 <code>RDB</code> 文件或者 <code>AOF</code> 文件，并根据文件记录的内容来还原服务器的数据库状态。</p><ul><li>如果服务器采用的是 <code>AOF</code>方式的持久化方式，那么服务器将使用<code>AOF</code>文件来还原数据库状态。</li><li>相反的如果服务器没有采用<code>AOF</code>方式的持久化方式，那么服务器使用<code>RDB</code>文件来还原服务器数据库状态。</li></ul><p>当服务器完成数据库的还原操作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>5244<span class="token punctuation">]</span> 21 Nov 22:43:49.084 * DB loaded from disk: 0.067 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h4><p>初始化的最后一步，服务器将打印以下日志，</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>5244<span class="token punctuation">]</span> 21 Nov 22:43:49.084 * The server is now ready to accept connections on port  6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并开始执行服务器的时间循环（<code>loop</code>）<br>。</p><p>至此，服务器的初始化操作就圆满完成。服务器从现在开始就可以接受客户端的连接请求，并处理客户端发来的命令请求了。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道&lt;code&gt;Redis&lt;/code&gt;是一个典型的&lt;code&gt;C/S&lt;/code&gt;设计程序，一个服务器可以与多个客户端建立连接。通过&lt;code&gt;I/O&lt;/code&gt;多路复用技术实现的文件事件处理器，&lt;code&gt;Redis&lt;/code&gt;服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。&lt;/p&gt;
&lt;p&gt;所以，对于&lt;code&gt;Redis&lt;/code&gt;我们分为这两部分来了解，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器维护和管理客户端状态的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt;服务器的运行机制&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之事件原理和实现</title>
    <link href="https://weizhimiao.github.io/2017/01/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-01-13T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：</p><ul><li><p>文件事件(file event)</p><blockquote><p>Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。</p></blockquote></li><li><p>时间事件(time event)</p><blockquote><p>Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。</p></blockquote></li></ul><span id="more"></span><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。</p><p>Redis基于Reactor模式开发了自己的文件事件（网络事件）处理器（file event handler）。其构成可分为四个部分，套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/WenJianShiJianChuLiQiDeSiGeZuChengBuFen.png" alt="事件处理器的四个组成部分"></p><ul><li>因为一个服务器通常会连接多个套接字，所以多个文件事件可能会并发的出现</li><li>I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。（尽管会有多个文件事件同时出现，但是I/O多路复用程序会将之转化成一个有序的队列，依次将其传送给文件事件分派器。并且等上一个套接字处理完毕之后，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字）</li><li>文件事件分派器接受I/O多路复用程序传送过来的套接字，并根据套接字产生的事件类型，调用相应的事件处理器。<blockquote><p>服务器会为执行不同任务的套接字关联不同的事件处理器，如有应答处理器、命令请求处理器、命令回复处理器。</p></blockquote><h3 id="I-O多路复用程序的实现方式"><a href="#I-O多路复用程序的实现方式" class="headerlink" title="I/O多路复用程序的实现方式"></a>I/O多路复用程序的实现方式</h3></li></ul><p>Redis的I/O复用程序的功能都是通过包装了常见的I/O多路复用函数库来实现的</p><ul><li>select</li><li>epoll</li><li>evport</li><li>kqueue</li></ul><p>I/O多路复用函数库的选择</p><blockquote><p>Redis用每个函数库都实现了相同的API，程序会在编译时自动判断当前系统下哪种多路复用函数库性能最高，而选择其作为Redis的I/O多路复用程序的底层实现。</p></blockquote><h3 id="文件事件的类型"><a href="#文件事件的类型" class="headerlink" title="文件事件的类型"></a>文件事件的类型</h3><ul><li><p>AE_READABLE 事件</p><blockquote><p>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作）</p></blockquote></li><li><p>AE_WRITABLE 事件</p><blockquote><p>当套接字变得可写时（客户端对套接字执行read操作）</p></blockquote></li></ul><p>I/O多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件，并且如果一个套接字同时出现这两种事件，那么文件分派器会优先处理 AE_READABLE 事件，然后才会处理 AE_WRITABLE 事件。</p><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><ul><li>连接应答处理器</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiDuiKeHuDuanDeLianJieQingQiuJinXingYingDa.png" alt="服务器对客户端的连接请求进行应答"></p><p>当Redis服务器进行初始化的时候，会将连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来，当有客户端与服务器监听的套接字进行连接时，套接字就会产生 AE_READABLE 事件，引发连接应答处理器执行，并执行相应的套接字应答操作。</p><ul><li>命令请求处理器</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiJieShouKeHuDuanFaLaiDeMingLingQingQiu.png" alt="服务器接收客户端发来的命令请求"><br>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来，当客户端向服务器端发送请求命令的时候，套接字就会产生 AE_READABLE 事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p><p>在客户端与服务器连接的整个过程中，服务器都会一直为客户端套接字的 AE_READABLE 事件关联命令请求处理器。</p><ul><li>命令回复处理器</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiXiangKeHuDuanFaSongMingLingHuiFu.png" alt="服务器向客户端发送命令回复"></p><p>当客户端有命令回复需要传送给客户端的时候，服务器会将客户端套接字的 AE_WRITABLE 事件和命令回复处理器关联起来，当客户端准备好接受服务器传回的命令回复时，就会产生 AE_WRITABLE 事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p><h3 id="一次完整的客户端与服务器连接事件的示例"><a href="#一次完整的客户端与服务器连接事件的示例" class="headerlink" title="一次完整的客户端与服务器连接事件的示例"></a>一次完整的客户端与服务器连接事件的示例</h3><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/KeHuDuanHeFuWuQiDeTongXinGuoCheng.png" alt="客户端和服务器的通信过程"></p><p>假设一个Redis服务器正在运行，那么这个服务器的监听套接字的 AE_READABLE 事件应该正在处于监听状态下，而该事件所对应的处理器为连接应答处理器。</p><p>这是如果有一个Redis客户端向服务器发起连接，那么监听套接字将会产生 AE_READABLE 事件，I/O多路复用程序将会将这个 AE_READABLE 事件传送给文件事件分派器，文件分派器将其分给连接应答处理器触发其执行。</p><p>应答处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端的套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p><p>之后，假设客户端向主服务器发送命令请求，那么客户端套接字将产生 AE_READABLE 事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</p><p>执行程序执行完毕将会有对应的回复，为了将这些命令回复传送给客户端，服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将会产生 AE_WRITABLE 事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到套接字之后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。</p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件</li><li>周期性事件</li></ul><blockquote><p>目前版本的Redis只使用周期性事件，而没有使用定时事件。</p></blockquote><h3 id="时间事件的组成"><a href="#时间事件的组成" class="headerlink" title="时间事件的组成"></a>时间事件的组成</h3><p>一个时间事件由以下三个属性组成，</p><ul><li><p>id，服务器为时间事件生成的全局唯一的ID（标志号）。该ID是自增的，即新的事件ID总是比旧事件ID要大。</p></li><li><p>when，毫秒精度的时间戳，记录了事件的到达（arrive）时间</p></li><li><p>timeProc，时间事件处理器，一个函数</p></li></ul><p>不管是定期时间事件和还是周期性时间事件，其组成都是由这三个属性构成。其不同取决于时间事件处理器的返回值</p><ul><li>如果事件处理器返回 AE_NOMARE ,那么这个事件就是定时事件。该事件在第一次之后就会被删除，之后不在到达。</li><li>如果事件处理器返回 非AE_NOMARE 的整数值，那么这个事件就是周期性事件，该事件在到达之后，服务器会根据这个返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后可以再次到达。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Redis 服务器将所有的时间事件都放在了一个无序列表中，每当时间事件执行器运行时，它就会遍历成哥链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/YongLianBiaoLianJieQiLaiDeSanGeShiJianShiJian.png" alt="时间事件实现"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>持续运行的Redis服务器需要定期的对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定的运行，这些定期操作是由 serverCron 函数负责执行。它的主要工作有，</p><ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等</li><li>清理数据库中过期的键</li><li>关闭和清理连接失效的客户端</li><li>尝试进行AOF或RDB持久化操作</li><li>如果服务器是主服务器，那么对从服务器进行定期数据同步</li><li>如果处于集群模式，对集群进行定期同步和连接测试</li></ul><p>Redis以周期性时间事件方式来运行 serverCron 函数，直至服务器关闭为止。</p><h2 id="文件事件和时间事件的关系"><a href="#文件事件和时间事件的关系" class="headerlink" title="文件事件和时间事件的关系"></a>文件事件和时间事件的关系</h2><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/ShiJianChuLiJiaoDuXiaDeFuWuQiYunXingLiuCheng.png" alt="事件角度下的服务器运行流程"></p><p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件。并且由于文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器也不会终端正在执行的事件处理，也不会对事件进行抢占。</p><h3 id="Redis事件调度和执行的几条规则"><a href="#Redis事件调度和执行的几条规则" class="headerlink" title="Redis事件调度和执行的几条规则"></a>Redis事件调度和执行的几条规则</h3><ul><li><p>由于文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍然未有任何事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时，服务器就可以开始处理到达的时间事件了。</p></li><li><p>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间一般会比设定的时间稍晚一些。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis服务器是一个事件驱动程序，其主要处理的事件主要可分为以下两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件事件(file event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间事件(time event)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis服务器中的一些操作（如，serverCron函数）需要在指定的时间点执行，而时间事件就是对这类定时操作的抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis的持久化方式</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F/</id>
    <published>2017-01-12T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png" alt="redis持久化原理"></p><p>Redis提供了两种持久化的方式，</p><ul><li><p>RDB 持久化方式</p><blockquote><p>将数据库中的键值对及状态保存在持久化文件中</p></blockquote></li><li><p>AOF 持久化方式</p><blockquote><p>而AOF保存的是服务器所执行过的所有写命令</p></blockquote></li></ul><span id="more"></span><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/FuWuQiZaiRuWenJianShiDePanDuanLiuCheng.png" alt="服务器载入文件时的判断流程"></p><p>值得提一下的是，因为AOF文件的更新频率通常比RDB文件的更新频率更高，所以如果服务器有开启AOF持久化功能时，服务器就会优先使用AOF文件来还原数据库，其次才是RDB文件。</p><h2 id="RDB-持久化方式"><a href="#RDB-持久化方式" class="headerlink" title="RDB 持久化方式"></a>RDB 持久化方式</h2><h3 id="RDB文件结构简析"><a href="#RDB文件结构简析" class="headerlink" title="RDB文件结构简析"></a>RDB文件结构简析</h3><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/RDBWenJianJieGou.png" alt="RDB文件结构"></p><h3 id="redis服务器保存和载入RDB文件的方法"><a href="#redis服务器保存和载入RDB文件的方法" class="headerlink" title="redis服务器保存和载入RDB文件的方法"></a>redis服务器保存和载入RDB文件的方法</h3><p>redis中创建RDB文件的两个命令</p><ul><li><p>SAVE<br>SAVE命令会由Redis服务器主进程来执行RDB文件的创建，所以在执行SAVE时，Redis服务器会有阻塞，知道RDB文件创建完毕为止，且在阻塞期间服务器不能处理任何命令请求。</p></li><li><p>BGSAVE<br>BGSAVE命令则会派生出一个子进程，然后由子进程负责创建RDB文件，而Redis服务器主进程（父进程）可以继续处理各种命令请求。</p></li></ul><p>创建RDB文件的实际工作由rdb.c/rdbSave函数来完成，SAVE和BGSAVE命令都会以不同的形式调用这个函数。</p><p>RDB文件载入时的服务器状态</p><blockquote><p>RDB文件的载入只有在服务器启动时才会被执行，所以Redis中没有专门载入RDB文件的命令，只要Redis启动时没有开启AOF功能，且检测到RDB文件的存在，就会自动载入RDB文件。且服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成。</p></blockquote><h3 id="redis服务器自动保存功能的实现原理"><a href="#redis服务器自动保存功能的实现原理" class="headerlink" title="redis服务器自动保存功能的实现原理"></a>redis服务器自动保存功能的实现原理</h3><p>通过上面我们知道，Redis服务器有两个命令，SAVE和BGSAVE，来执行保存数据库状态的操作。<br>SAVE是阻塞的，BGSAVE是非阻塞的。Redis中借助BGSAVE命令，每隔一段时间自动执行一次BGSAVE命令来实现数据库状态的自动保存功能。</p><p>具体实现是通过设置服务器配置的save选项，按照一定的周期去执行BGSAVE命令。如</p><pre><code>save 900 1save 300 10save 60 10000</code></pre><p>那么只要满足上面这三个条件的任何一条，BGSAVE就会被执行。</p><ul><li>服务器在900s之内，对数据库进行了至少1次修改</li><li>服务器在300s之内，对数据库进行了至少10次修改</li><li>数据库在60s之内，对数据库进行了10000次修改</li></ul><h2 id="AOF-持久化方式"><a href="#AOF-持久化方式" class="headerlink" title="AOF 持久化方式"></a>AOF 持久化方式</h2><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFChiJiuHua.png" alt="AOF持久化方式"></p><h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>当AOF持久化功能处于打开的状态时，服务器在执行完一个写命令，先将被执行的写命令追加到服务器状态的 aof_buf 的缓冲区。Redis服务器会在每次事件循环结束之前，都会调用“flushAppendOnlyFile”函数来判断是否需要将 aof_buf 缓冲区中内容保存到AOF文件里面。</p><p>flushAppendOnlyFile 函数判断是否保存的依据和配置（appendfsync）</p><ul><li>always,将aof_buf 将缓冲区中所有内容写入并同步到AOF文件</li><li>everysec,将缓冲区中所有内容写入AOF文件，但至少间隔一秒同步一次(默认值)</li><li>no,将缓冲区中所有内容写入AOF文件，但不对AOF文件进行同步，何时同步则由系统决定</li></ul><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170112/AOFWenJianZaiRuGuoCheng.png" alt="AOF文件载入过程"></p><h3 id="AOF重写的原理和实现"><a href="#AOF重写的原理和实现" class="headerlink" title="AOF重写的原理和实现"></a>AOF重写的原理和实现</h3><p>随着服务器运行时间的增加，AOF文件中的内容会越来越多，相应的文件体积就会越来越大，但其实文件中很大一部分信息是冗余信息。</p><p>例如，我们对一个键进行了n次的写操作，AOF文件中相对应就会产生n次的写操作命令。但其实AOF文件中的对于该键的前n-1次的写操作命令都可认为是冗余操作命令，只需保留最后一条的写操作命令即可。</p><p>所以，Redis提供了AOF文件重写（rewrite）功能，来清除这些冗余命令，以控制AOF文件的大小。具体实现思路为，Redis服务器先创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态是相同的，但新的AOF文件不会包含任何浪费空间的冗余命令。</p><h4 id="Redis服务器AOF重写的实现"><a href="#Redis服务器AOF重写的实现" class="headerlink" title="Redis服务器AOF重写的实现"></a>Redis服务器AOF重写的实现</h4><ul><li><p>虽然该功能名称叫 AOF文件重写 ，但是具体的实现却并没有对现有AOF文件进行任何读取、分析、或者写入操作，而是通过读取当前服务器的数据库状态来实现的。</p></li><li><p>通过读取当前数据库中键值的状态，尽量生成最少的能与之对应redis命令，然后将该redis命令写入新的AOF文件中，直至将当前数据库状态全部生成完毕。</p></li><li><p>另外，在执行AOF重写的期间，Redis会维护一个AOF重写缓冲区，该缓冲区会在子进程创建AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态完全一致。</p></li><li><p>最后，服务器用新的AOF替换旧的AOF文件，以此来完成AOF文件的重写操作。</p></li></ul><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>由于生成新的AOF文件时会进行大量的写入操作，所以在进行AOF重写的时候，会造成长时间的阻塞，所以redis将AOF重写程序放在子进程里执行，这样就可避免主进程长时间的阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道Redis是一个内存数据库，它所有的数据库状态都存储在内存中，所以如果想要在服务器故障、重启之后数据还在，就需要一个将这些数据持久化的一个功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20170112/redisChiJiuHuaYuanLi.png&quot; alt=&quot;redis持久化原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;Redis提供了两种持久化的方式，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RDB 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将数据库中的键值对及状态保存在持久化文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AOF 持久化方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而AOF保存的是服务器所执行过的所有写命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis之Redis数据库的实现</title>
    <link href="https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2017/01/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis%E4%B9%8BRedis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-01-12T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>Redis这个<code>key-value</code>的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。</p><span id="more"></span><h2 id="数据结构与对象"><a href="#数据结构与对象" class="headerlink" title="数据结构与对象"></a>数据结构与对象</h2><p>Redis底层的实现，主要用到的数据结构有简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等。但REdis没有直接用这些数据结构来实现数据库的设计。而是基于这些数据结构创建了一个对象系统。</p><p>使用这种对象系统的好处</p><ul><li>对不同的使用场景，可以为对象设置多种不同的数据结构实现，从而可以优化对象在不同场景下的使用效率</li><li>基于对象方便实现基于引用计数技术的内存回收机制</li></ul><p>键值对的具体组成：</p><ul><li>键 =&gt; 自字符串对象</li><li>值<ul><li>字符串对象</li><li>列表对象</li><li>哈希对象</li><li>集合对象</li><li>有序集合对象</li></ul></li></ul><h2 id="数据库的实现"><a href="#数据库的实现" class="headerlink" title="数据库的实现"></a>数据库的实现</h2><p>Redis服务器的所有数据库都保存在”redisSeriver”结构中的“db” 的数组中。而db的结构则主要由“dict”和“expires”另个字典构成，dict字典负责保存键值对，而expires字典负责保存键的过期时间。</p><p>redisSeriver结构</p><pre><code>struct redisSeriver&#123;  //...  redisDb *db;  //...&#125;;</code></pre><p>redisDb结构</p><pre><code>typeed struct redisDb&#123;  //...  //数据库键值字典，保存数据库中所有键值对（又称之为，键空间）  dict *dict;  //过期字典，保存键的过期时间  dict *expires;&#125; redisDb;</code></pre><h3 id="服务器保存键值对的方法"><a href="#服务器保存键值对的方法" class="headerlink" title="服务器保存键值对的方法"></a>服务器保存键值对的方法</h3><p>键值字典和用户所见的数据库是直接对应的</p><ul><li>该字典里的键就是我们数据库的键（每个键都是一个字符串对象）</li><li>字典的值就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任一种对象。</li></ul><p>相应的操作</p><ul><li><p>当添加新键值对时</p><blockquote><p>实际就是将一个新键值对添加到该“dict”键值字典中，其键为字符串对象，值为任意的一个Redis对象</p></blockquote></li><li><p>删除键</p><blockquote><p>实际上就是在该“dict”键值字典中删除键对应的键值对对象</p></blockquote></li><li><p>更新键</p></li><li><p>对该键取值</p></li></ul><p>当我们对这些键值进行这些读写操作的时候，redis还会执行一些额外的（维护）操作。这些操作有</p><ul><li>当读取一个键后，会更新服务器键空间命中次数（hit）或不命中次数（miss）</li><li>读取一个键后，还会更新该键的LRU（最后一次使用时间）</li><li>当读取一个键时，发现该键已经过期，那么出返回结果还需要删除这个键</li><li>如果有客户端watch这个键，那么操作过这个键之后还需要将这个键标记为“dirty”，让watch这个键的客户端知道该键已经被修改过</li><li>当每次修改过一个键之后，都会对“dirty”计数器的值增1，以便触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知的功能，那么修改了键之后，还需要按配置发送相应的通知。</li></ul><h3 id="服务器保存键值对过期时间的方法"><a href="#服务器保存键值对过期时间的方法" class="headerlink" title="服务器保存键值对过期时间的方法"></a>服务器保存键值对过期时间的方法</h3><p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p><p>redis有四个不同的命令来设置键的过期时间</p><ul><li>EXPIRE <key> <ttl> (秒级)</ttl></key></li><li>PEXPIRE <key> <ttl> (毫秒级)</ttl></key></li><li>EXPIREAT <key> <timestamp> (秒级)</timestamp></key></li><li>PEXPIREAT <key> <timestamp> (毫秒级)</timestamp></key></li></ul><p>实际上，EXPIRE、PEXPIRE、EXPIREAT三个命令最终都是使用PEXPIREAT命令来实现的。</p><p>redisDb结构中，expires字典保存了数据库中所有键的过期时间。</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象</li><li>过期字典的值是一个long类型的整数，这个整数保存着过期时间（一个毫秒精度的UNIX时间戳）</li></ul><h3 id="服务器删除过期键值对的方法"><a href="#服务器删除过期键值对的方法" class="headerlink" title="服务器删除过期键值对的方法"></a>服务器删除过期键值对的方法</h3><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><ul><li>1、检查给定的键是否存在于过期字典，如果存在，那么取得键的过期时间</li><li>2、检查当前UNIX时间戳是否大于取得的键的过期时间，如果大于的，那么该键已过期；否则该键未过期。</li></ul><h4 id="一般的常见的过期键删除机制"><a href="#一般的常见的过期键删除机制" class="headerlink" title="一般的常见的过期键删除机制"></a>一般的常见的过期键删除机制</h4><ul><li>定时删除，在设置键的时候设定一个定时器，让其在定时器结束时执行对键的删除操作</li><li>惰性删除，设置后不管，当需要再次获取该键时，先检查该键是否已经过期，如果过期的话，执行删除操作，没有过期的话，返回键值</li><li>定期删除，每隔一段时间，对所有键检查一次，有过期的则主动删除</li></ul><h4 id="Redis采用的过期键删除机制（惰性-定期）"><a href="#Redis采用的过期键删除机制（惰性-定期）" class="headerlink" title="Redis采用的过期键删除机制（惰性+定期）"></a>Redis采用的过期键删除机制（惰性+定期）</h4><ul><li><p>惰性删除策略的实现</p><blockquote><p>redis在所有读写数据库的Redis命令之前都会执行一个叫”expireIfNeeded”的函数对要操作的键进行检查</p></blockquote><ul><li>如果要操作的键已经过期，那么”expireIfNeeded”函数将该键从数据库中删除</li><li>如果未过期，那么”expireIfNeeded”函数不做操作</li></ul></li></ul><p>注：对所操作键存在与否的判断先与是否过期的判断</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20170111/redisGuoQiJianShanChuLiuCheng.png" alt="img"></p><ul><li>定期删除策略的实现<blockquote><p>redis中会有一个周期性运行的操作函数“serverCron”。过期键的定期删除是由一个叫“activeExpireCycle”的函数实现。当serverCron函数运行时，activeExpireCycle 函数就会被调用。它会在规定的时间内分多次遍历服务器中各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p></blockquote></li></ul><h4 id="redis集群中过期键的删除"><a href="#redis集群中过期键的删除" class="headerlink" title="redis集群中过期键的删除"></a>redis集群中过期键的删除</h4><p>在Redis集群中 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，而从服务器即使发现过期键也不会自作主张的将其删除，而是等待主节点发来DEL命令，显式的进行删除。这种统一的、中心化的过期键策略可以保证主从服务器数据一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis这个&lt;code&gt;key-value&lt;/code&gt;的存储系统，由于其高性能，支持主从复制和丰富的数据结构等特性，目前已经广泛应用于我们的各个场景之中。所以了解整理其相关的一些内容，用以加深我们对其的了解，方便之后更好的使用它实现我们的各种功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构下使用Nginx变量对应用程序进行性能追踪[转]</title>
    <link href="https://weizhimiao.github.io/2016/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E4%BD%BF%E7%94%A8Nginx%E5%8F%98%E9%87%8F%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E8%BF%BD%E8%B8%AA[%E8%BD%AC]/"/>
    <id>https://weizhimiao.github.io/2016/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E4%BD%BF%E7%94%A8Nginx%E5%8F%98%E9%87%8F%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E8%BF%BD%E8%B8%AA[%E8%BD%AC]/</id>
    <published>2016-12-29T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>使用变量来对应用程序性能进行管理</strong></em></p><p>变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约<a href="http://nginx.org/en/docs/varindex.html">150个变量</a>可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 <strong>应用程序跟踪</strong> 和 <strong>应用程序性能管理（APM）</strong> ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。</p><span id="more"></span><h2 id="应用程序交付环境"><a href="#应用程序交付环境" class="headerlink" title="应用程序交付环境"></a>应用程序交付环境</h2><p>在我们的示例应用程序交付环境中，NGINX Plus作为我们应用程序的反向代理。 应用程序本身包括一个Web前端，后面是多个微服务。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161229/nginx-proxies-app-with-frontend-and-microservices.png" alt="示例应用程序交付环境"></p><h2 id="跟踪端到端-End‑to‑End-请求"><a href="#跟踪端到端-End‑to‑End-请求" class="headerlink" title="跟踪端到端(End‑to‑End)请求"></a>跟踪端到端(End‑to‑End)请求</h2><p><code>NGINX Plus R10</code>（和<code>NGINX 1.11.0</code>）引入 <code>$request_id</code> 变量，它是随机生成的32个十六进制字符串，在每个HTTP请求到达时自动分配给它们（例如<code>444535f9378a3dfa1b8604bc9e05a303</code>）。 这个看似简单的机制解锁了一个强大的工具，可用于跟踪和故障排除。 通过配置<code>NGINX Plus</code>和所有后端服务传递<code>$request_id</code>值，您可以跟踪每个请求端到端。 这个示例配置是为我们的前端<code>NGINX Plus</code>服务器。</p><pre><code>upstream app_server &#123;    server 10.0.0.1:80;&#125;server &#123;    listen 80;    add_header X-Request-ID $request_id; # Return to client    location / &#123;        proxy_pass http://app_server;        proxy_set_header X-Request-ID $request_id; # Pass to app server    &#125;&#125;</code></pre><p>要配置NGINX Plus进行请求跟踪，我们首先定义 <code>upstream</code> 块中应用程序服务器的网络位置。 为了简单起见，我们在这里只显示一个应用程序服务器，但通常使用几个应用程序服务器来实现高可用性和负载平衡。</p><p><code>server</code>块定义了<code>NGINX Plus</code>如何处理传入的HTTP请求。 <code>listen</code>指令告诉<code>NGINX Plus</code>侦听端口80，但生产环境配置通常使用<code>SSL/TLS</code>来保护传输中的数据。</p><p><code>add_header</code>指令将<code>$request_id</code>值作为响应中的自定义<code>header</code>头发送回客户端。 这对于测试以及生成自己的日志（如移动应用程序）的客户端应用程序非常有用，以便客户端可以精确匹配服务器的错误日志。</p><p>最后，<code>location</code> 块应用于整个应用程序空间（<code>/</code>），<code>proxy_pass</code>指令简单地代理所有请求到应用程序服务器。 <code>proxy_set_header</code>指令通过添加传递给应用程序的HTTP头来修改代理请求。 在这种情况下，我们创建一个名为<code>X-Request-ID</code>的头，并为其分配<code>$request_id</code>变量的值。 因此，我们的应用程序接收由<code>NGINX Plus</code>生成的request ID。</p><h2 id="记录端到端的-request-id"><a href="#记录端到端的-request-id" class="headerlink" title="记录端到端的$request_id"></a>记录端到端的<code>$request_id</code></h2><p>我们的应用程序跟踪的目标是确定请求处理生命周期中的性能瓶颈，作为应用程序性能管理的一部分。 我们可以通过在处理过程中记录重要的事件来做到这一点，方便我们以后分析它们的异常或不合理的延迟。</p><h3 id="配置NGINX-Plus"><a href="#配置NGINX-Plus" class="headerlink" title="配置NGINX Plus"></a>配置NGINX Plus</h3><p>我们从配置前端<code>NGINX Plus</code>服务器开始，将<code>$request_id</code>包含在用于<code>access_trace.log</code>文件的自定义日志记录格式<code>trace</code>中。</p><pre><code>log_format trace &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                 &#39;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;                 &#39;&quot;$http_x_forwarded_for&quot; $request_id&#39;;upstream app_server &#123;    server 10.0.0.1;&#125;server &#123;    listen 80;    add_header X-Request-ID $request_id; # Return to client    location / &#123;        proxy_pass http://app_server;        proxy_set_header X-Request-ID $request_id;        # Pass to app server        access_log /var/log/nginx/access_trace.log trace; # Log $request_id    &#125;&#125;</code></pre><h3 id="配置后端应用程序"><a href="#配置后端应用程序" class="headerlink" title="配置后端应用程序"></a>配置后端应用程序</h3><p>将<code> Request ID</code> 传递到我们的应用程序有时也会用到。 在这个例子中，我们有一个由<code>uWSGI</code>管理的<code>Python应用程序</code>。 让我们修改应用程序入口点，以获取<code>Request ID </code>作为日志变量。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> uwsgi <span class="token keyword">import</span> set_logvar<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>    set_logvar<span class="token punctuation">(</span><span class="token string">'requestid'</span><span class="token punctuation">,</span> environ<span class="token punctuation">[</span><span class="token string">'X_REQUEST_ID'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们可以修改<code>uWSGI</code>配置，将<code>Request ID</code>包含在标准日志文件中。</p><pre><code>log-format = %(addr) - %(user) [%(ltime)] &quot;%(method) %(uri) %(proto)&quot; %(status)%(size) &quot;%(referer)&quot; &quot;%(uagent)&quot; %(requestid)</code></pre><p>通过这种配置，我们现在可以生成日志文件，这些文件可以跨多个系统，我们可以通过<code>requestid</code>来查看我们单次<code>request</code>的调用链。</p><p>来自<code>NGINX</code>的日志示例：</p><pre><code>172.17.0.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.1&quot; 200 90 &quot;-&quot; &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</code></pre><p>来自应用程序的日志示例：</p><pre><code>192.168.91.1 - - [02/Aug/2016:14:26:50 +0000] &quot;GET / HTTP/1.0&quot; 200 123 &quot;-&quot; &quot;-&quot; 5f222ae5938482c32a822dbf15e19f0f</code></pre><p>通过将 <code>Request ID</code> 字段与事务匹配，<code>Splunk</code> 和 <code>Kibana</code> 之类的工具允许我们识别性能瓶颈。 例如，我们可以搜索花费两秒钟以上时间完成的请求。 然而，在常规时间戳中的默认时间精度为一秒不足以用于大多数真实环境的分析。</p><h2 id="高精度时序"><a href="#高精度时序" class="headerlink" title="高精度时序"></a>高精度时序</h2><p>为了准确地测量端到端请求，我们需要具有毫秒级精度的时间戳。 通过在日志条目中包括<code>$msec</code>变量，我们在每个条目的时间戳上获得毫秒的精度。 向应用程序日志添加毫秒时间戳允许我们查找花费 本该不超过200毫秒完成，但却花了2秒的请求。</p><p>但是即使这样，我们也没有得到全部的图片，因为<code>NGINX Plus</code>只在处理每个请求结束时写入<code>$msec</code>时间戳。 幸运的是，有几个其他<code>NGINX Plus</code>定时变量，毫秒精度，让我们更深入地了解处理本身：</p><ul><li><p><code>$request_time</code> – 完全请求时间，从NGINX Plus从客户端读取第一个字节，并在NGINX Plus发送响应主体的最后一个字节时结束</p></li><li><p><code>$upstream_connect_time</code> – 花费在与<code>upstream</code>服务器建立连接的时间</p></li><li><p><code>$upstream_header_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应头的第一个字节之间的时间</p></li><li><p><code>$upstream_response_time</code> – 建立到<code>upstream</code>服务器的连接和接收响应主体的最后一个字节之间的时间</p></li></ul><p>有关这些时序变量的详细信息，请参阅[使用NGINX日志记录应用程序性能监视](Using NGINX Logging for Application Performance Monitoring)。</p><p>我们可以扩展我们的<code>log_format</code>指令，将所有这些高精度定时变量包含在我们的跟踪日志格式中。</p><pre><code>log_format trace &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status &#39;                 &#39;$body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;                 &#39;&quot;$http_x_forwarded_for&quot; $request_id $msec $request_time &#39;                 &#39;$upstream_connect_time $upstream_header_time $upstream_response_time&#39;;</code></pre><p>使用我们首选的日志分析工具，我们可以提取变量值并执行以下计算，以了解<code>NGINX Plus</code>在连接到应用程序服务器之前处理请求的时间：</p><pre><code>NGINX Plus processing time = $request_time - $upstream_connect_time - $upstream_response_time</code></pre><p>我们还可以搜索<code>$upstream_response_time</code>的最高值，查看它们是否与特定URI或上游服务器相关联。 然后可以进一步检查具有相同请求ID的应用程序日志条目。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>利用新的<code>$request_id</code>变量和一些毫秒精度的时间变量可以提供对应用程序性能瓶颈的深入了解，提高应用程序性能管理，而无需使用什么重量级代理和插件。</p><p><a href="https://www.nginx.com/blog/application-tracing-nginx-plus/">【原文】:https://www.nginx.com/blog/application-tracing-nginx-plus/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用变量来对应用程序性能进行管理&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;变量是NGINX配置的一个重要且有时被忽视的方面。 Nginx 有大约&lt;a href=&quot;http://nginx.org/en/docs/varindex.html&quot;&gt;150个变量&lt;/a&gt;可用，Nginx 变量可用来方便每个部分的配置。 在本博客中，我们讨论如何使用NGINX变量来进行 &lt;strong&gt;应用程序跟踪&lt;/strong&gt; 和 &lt;strong&gt;应用程序性能管理（APM）&lt;/strong&gt; ，重点是发现应用程序中的性能瓶颈。 这篇文章适用于开源的 NGINX 软件和 NGINX Plus。 为了简洁，我们将参考NGINX Plus，除非两个产品之间有差异。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="APM" scheme="https://weizhimiao.github.io/tags/APM/"/>
    
    <category term="应用性能跟踪" scheme="https://weizhimiao.github.io/tags/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>贪婪和懒惰匹配模式使用小结</title>
    <link href="https://weizhimiao.github.io/2016/11/29/%E8%B4%AA%E5%A9%AA%E5%92%8C%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/11/29/%E8%B4%AA%E5%A9%AA%E5%92%8C%E6%87%92%E6%83%B0%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2016-11-29T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。<br>简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。</p><p>举例来说，</p><p>我们要匹配以字符<code>a</code>开始，以<code>b</code>结束的字符串：假如我们要搜索的字符串是<code>aabab</code>，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：</p><ul><li><code>aabab</code>(贪婪模式)</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png" alt="贪婪"></p><ul><li><code>aab</code>(懒惰模式)(为什么不是<code>ab</code>？)</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png" alt="懒惰"></p><span id="more"></span><h2 id="正则表达式的这两种匹配模式的实现"><a href="#正则表达式的这两种匹配模式的实现" class="headerlink" title="正则表达式的这两种匹配模式的实现"></a>正则表达式的这两种匹配模式的实现</h2><ul><li><strong>贪婪</strong> <code>a.*b</code> 一般当一个正则表达式能够匹配出多种结果时，默认将会匹配出尽可能多的字符串。</li></ul><ul><li><strong>懒惰</strong> <code>a.*?b</code>只要表达式中的限定符后面加上一个问号。例如，（<code>.*?</code>）,则会匹配出符合条件的最短的字符。</li></ul><h2 id="懒惰模式的匹配原理"><a href="#懒惰模式的匹配原理" class="headerlink" title="懒惰模式的匹配原理"></a>懒惰模式的匹配原理</h2><p>简单的来说，就是在匹配喝不匹配都可以的情况下，优先不匹配，记录备选状态，并将匹配控制权交给正则表达式的下一个匹配字符。当后面的匹配失败时，回溯，进行匹配。</p><h2 id="常用的懒惰限定符"><a href="#常用的懒惰限定符" class="headerlink" title="常用的懒惰限定符"></a>常用的懒惰限定符</h2><table><thead><tr><th>懒惰限定符代码/语法</th><th>描述</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复1次或多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td><code>&#123;n,m&#125;?</code></td><td>重复n到m次，但尽可能少重复</td></tr><tr><td><code>&#123;n,&#125;?</code></td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab"><a href="#示例中，采用a-b表达式进行匹配时，匹配的结果为什么不是ab" class="headerlink" title="示例中，采用a.*?b表达式进行匹配时，匹配的结果为什么不是ab"></a>示例中，采用<code>a.*?b</code>表达式进行匹配时，匹配的结果为什么不是<code>ab</code></h2><p>如果我们只考虑<code>.*?</code>这个表达式，<code>aabab</code>字符串中将会匹配出两组字符，一组是<code>aab</code>(1<del>3字符)，另一组时<code>ab</code>（第2</del>3个字符）。但为什么结果是<code>aab</code>?按照懒惰模式匹配，他应该匹配出符合条件的最短的字符（最短的字符应该是<code>ab</code>）。</p><p>简单的说，正则表达式有一条规则，比懒惰/贪婪规则优先级更高：<em><strong>最先开始的匹配拥有最高优先权</strong></em>。</p><p><strong>提示：</strong></p><p>在实际开发中，涉及贪婪模式与懒惰模式的地方是很多的。在一定的情况下，使用懒惰模式可以减少回溯，提高效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所谓的贪婪/懒惰匹配模式，就是指正则表达式在匹配字符串是的两种不同的匹配策略。&lt;br&gt;简单的说就是，贪婪匹配模式在正则匹配时会尽量匹配出尽可能多的字符；而懒惰匹配模式则相反，它会匹配尽可能少的字符。&lt;/p&gt;
&lt;p&gt;举例来说，&lt;/p&gt;
&lt;p&gt;我们要匹配以字符&lt;code&gt;a&lt;/code&gt;开始，以&lt;code&gt;b&lt;/code&gt;结束的字符串：假如我们要搜索的字符串是&lt;code&gt;aabab&lt;/code&gt;，那么分别按照贪婪和懒惰两种模式来匹配，将会得到以下结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aabab&lt;/code&gt;(贪婪模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-0@2x.png&quot; alt=&quot;贪婪&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aab&lt;/code&gt;(懒惰模式)(为什么不是&lt;code&gt;ab&lt;/code&gt;？)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161214/QQ20161214-1@2x.png&quot; alt=&quot;懒惰&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="正则表达式" scheme="https://weizhimiao.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Memcached</title>
    <link href="https://weizhimiao.github.io/2016/11/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Memcached/"/>
    <id>https://weizhimiao.github.io/2016/11/27/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Memcached/</id>
    <published>2016-11-27T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p><span id="more"></span><h3 id="Memcached的高并发支持原理"><a href="#Memcached的高并发支持原理" class="headerlink" title="Memcached的高并发支持原理"></a>Memcached的高并发支持原理</h3><ul><li>多路复用I/O模型</li><li>多线程模式</li></ul><p>Memcached 使用了多路复用I/O模型（如，epoll、select等）。</p><p>传统的阻塞I/O中，系统可能会因为某个用户连接还没有做好I/O准备而一直等待，知道这个连接做好I/O准备。如果在这是有其他的用户连接到服务器，很可能会因为系统阻塞而得不到响应。</p><p>而多路复用I/O是一种消息通知模式，用户连接做好I/O准备后，系统会通知我们这个连接可以进行I/O操作了，这样系统就不会阻塞在某个用户连接了。因此就能够支持更高的并发。</p><p>此外，Memcached使用了多线程模式，在开启Memcached服务器时，通过使用 <code>-t</code> 参数指定要开启的线程数。（但，并不是线程数越多越好，一般设置为CPU核数，这样效率最高。）</p><h3 id="Memcached内存分配算法了解"><a href="#Memcached内存分配算法了解" class="headerlink" title="Memcached内存分配算法了解"></a>Memcached内存分配算法了解</h3><p>Memcached 在存储数据时，使用的是Slab内存分配算法。这种算法可以减少生成的内存碎片，提高使用效率。但这种算法也导致Memcached只能够使用不大于1MB的内存（所以，Memcache默认只能存储不大于1MB的数据）。</p><h3 id="Slab分配算法原理"><a href="#Slab分配算法原理" class="headerlink" title="Slab分配算法原理"></a>Slab分配算法原理</h3><p>Slab分配算法把每1MB大小的内存块称之为一个slab页，每次向系统申请一个slab页（所以，slab是一次申请内存的最小单位），然后再通过分割算法将这个slab页分割成若干小块的chunk，然后把这些chunk分配给用户使用。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161128/slabNaCunFenPeiYuanLi.png" alt="img"></p><p>默认情况下，Memcached可分为40种slab页，每种slab页的chunk块大小都不相同。</p><p>当保存数据时Memcached向Slab层申请内存时，Slab层找到一个一个合适的slab页，然后分配其中一个空闲的chunk块给Memcached使用。</p><h3 id="Memcached过期数据删除机制"><a href="#Memcached过期数据删除机制" class="headerlink" title="Memcached过期数据删除机制"></a>Memcached过期数据删除机制</h3><p>Memcached 为每一个item都设置了一个过期时间，但不是到期了之后就把item从内存中删除，而是访问item时，先进行判断，如果到期有效期，才把item从内存中删掉。</p><h3 id="Memcached淘汰数据算法"><a href="#Memcached淘汰数据算法" class="headerlink" title="Memcached淘汰数据算法"></a>Memcached淘汰数据算法</h3><blockquote><p>当内存不足时，Memcached会把访问比较少的或者一段时间没有访问的item淘汰（并不是主动去遍历那些过期的item），以便腾出内存空间存放新的item。</p></blockquote><p>当Memecached使用的内存数大于设置的内存数之后，为了腾出空间来存放新的数据项，Memcached采用的是LRU算法(最近最少使用算法)来淘汰旧的数据项。</p><p>数据淘汰流程：</p><ul><li>1、当Memcached第一次申请内存失败时，就开始算法进行淘汰数据。</li><li>2、首先从数据项列表（item_list）尾部开始遍历。</li><li>3、在列表中查找一个引用计数器（refcount）为0的item，把此item占用的内存释放掉。</li><li>4、再次申请内存，如果失败的话，继续进行淘汰算法。</li><li>5、查找3小时没有访问过的item，并将这些item释放掉。</li><li>6、再次申请内存，如果还是失败的话，就返回NULL（申请内存失败）。</li></ul><p><strong>Tips：</strong></p><p>1、为什么从数据项列表尾部开始遍历？</p><p>因为，Memcached会把刚刚访问过的item放到item列表头部，所以尾部的item就是没有被访问过的（或者是很少被访问到的），这就是LRU的精髓。</p><h3 id="Memcached多线程模型"><a href="#Memcached多线程模型" class="headerlink" title="Memcached多线程模型"></a>Memcached多线程模型</h3><p>Memcached 是一个多线程的缓存服务器程序。在Memcached内部，线程分为：</p><ul><li>主线程（main thread）：负责接收客户端连接，并把连接分配给工作线程处理；</li><li>工作线程（worker thread）：处理主线程分配过来的客户端连接请求。</li></ul><p>Memcached 多线程模型原理如图所示。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png" alt="Memcached多线程模型原理"></p><p>主线程主要负责侦听客户端连接，在客户端连接到Memcached时，Memcached接收到来的请求，并把连接push到工作线程的CQ队列中，并向工作线程发送一个信号，告诉工作线程有新的客户端连接需要处理。</p><p>当工作线程收到主线程的信号后，便会把CQ队列上的客户端连接注册到libevent进行侦听，libevent会侦听客户端连接的读写请求，病调用相关的回调函数进行处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161128/memcachedDuoXianChengMoXingYuanLiTu.png&quot; alt=&quot;Memcached多线程模型原理&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="memcached" scheme="https://weizhimiao.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>Linux中借助lockf简单实现和应用文件锁机制</title>
    <link href="https://weizhimiao.github.io/2016/11/16/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2016/11/16/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2016-11-16T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。</p><span id="more"></span><h2 id="实现-lockf"><a href="#实现-lockf" class="headerlink" title="实现(lockf)"></a>实现(lockf)</h2><p>在Linux中我们可以借助lockf命令来实现文件锁机制</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>tar -xzf lockf_linux.tar.gzcd lockf_linuxmake &amp;&amp; make install</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>lockf --help  -k 锁定文件，如果当前文件被锁，则输出 lockf:/tmp/create/lock :already locked  -s 锁定文件，不输出任何信息 silent  -t second ：超时时间，超时就退出</code></pre><h3 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h3><pre><code>lockf -s -t 0 /tmp/create.lock /usr/local/bin/php -f xxx.php</code></pre><blockquote><p>先判断/tmp/create.lock 文件是否被锁，被锁则立即退出，否则将会执行后面的脚本。</p></blockquote><p>第一次运行会给<code>/tmp/create.lock</code> 文件上锁，并执行后面的命令，</p><p>当第二次运行该命令时，<code>/tmp/create.lock</code> 文件已经被锁，命令将会直接退出，而不会去执行后面的<code>/usr/local/bin/php -f xxx.php</code> 的脚本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件锁机制的作用：防止多个程序同时对一个不允许同时操作的工作做操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="文件锁机制" scheme="https://weizhimiao.github.io/tags/%E6%96%87%E4%BB%B6%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Bash脚本15分钟进阶教程[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/Bash%E8%84%9A%E6%9C%AC15%E5%88%86%E9%92%9F%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/"/>
    <id>https://weizhimiao.github.io/2016/11/16/Bash%E8%84%9A%E6%9C%AC15%E5%88%86%E9%92%9F%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。</p><ul><li>脚本安全</li><li>脚本函数</li><li>变量注解</li><li>用$()代替反单引号(`)</li><li>用<code>[[]]</code>(双层中括号)替代[]</li><li>正则表达式/Globbing</li><li>字符串操作</li><li>避免使用临时文件</li><li>内置变量</li><li>调试</li><li>什么时候不应该使用bash脚本</li></ul><span id="more"></span><h2 id="脚本安全"><a href="#脚本安全" class="headerlink" title="脚本安全"></a>脚本安全</h2><p>我的所有bash脚本都以下面几句为开场白：</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true">#!/bin/bash</span>    <span class="token keyword">set</span> -o nounset    <span class="token keyword">set</span> -o errexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样做会避免两种常见的问题：</p><ul><li>引用未定义的变量(缺省值为“”)</li><li>执行失败的命令被忽略</li></ul><p>需要注意的是，有些Linux命令的某些参数可以强制忽略发生的错误，例如“mkdir -p” 和 “rm -f”。</p><p>还要注意的是，在“errexit”模式下，虽然能有效的捕捉错误，但并不能捕捉全部失败的命令，在某些情况下，一些失败的命令是无法检测到的。(更多细节请参考<a href="https://groups.google.com/forum/?fromgroups#!topic/gnu.bash.bug/-9ySnEo1WrQ">这个帖子</a>。)</p><h2 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h2><p>在bash里你可以定义函数，它们就跟其它命令一样，可以随意的使用；它们能让你的脚本更具可读性：</p><pre class="line-numbers language-bash"><code class="language-bash">    ExtractBashComments<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        <span class="token function">egrep</span> <span class="token string">"^#"</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    <span class="token function">cat</span> myscript.sh <span class="token operator">|</span> ExtractBashComments <span class="token operator">|</span> <span class="token function">wc</span>    comments<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>ExtractBashComments <span class="token operator">&lt;</span> myscript.sh<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些例子：</p><pre class="line-numbers language-bash"><code class="language-bash">    SumLines<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;  # iterating over stdin - similar to awk      </span>        local sum<span class="token operator">=</span>0        local line<span class="token operator">=</span>””        <span class="token keyword">while</span> <span class="token function">read</span> line <span class="token punctuation">;</span> <span class="token keyword">do</span>            sum<span class="token operator">=</span><span class="token punctuation">$((</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;sum&amp;#125; + $&amp;#123;line&amp;#125;))</span>        <span class="token keyword">done</span>        <span class="token keyword">echo</span> $<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;sum&amp;#125;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    SumLines <span class="token operator">&lt;</span> data_one_number_per_line.txt    log<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;  # classic logger</span>       local prefix<span class="token operator">=</span><span class="token string">"[<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%Y/%m/%d\ %H:%M:%S<span class="token variable">)</span></span>]: "</span>       <span class="token keyword">echo</span> <span class="token string">"$&amp;#123;prefix&amp;#125; <span class="token variable">$@</span>"</span> <span class="token operator">></span><span class="token operator">&amp;</span>2    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    log <span class="token string">"INFO"</span> <span class="token string">"a message"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽可能的把你的bash代码移入到函数里，仅把全局变量、常量和对“main”调用的语句放在最外层。</p><h2 id="变量注解"><a href="#变量注解" class="headerlink" title="变量注解"></a>变量注解</h2><p>Bash里可以对变量进行有限的注解。最重要的两个注解是：</p><pre class="line-numbers language-bash"><code class="language-bash">local<span class="token punctuation">(</span>函数内部变量<span class="token punctuation">)</span>readonly<span class="token punctuation">(</span>只读变量<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># a useful idiom: DEFAULT_VAL can be overwritten</span>    <span class="token comment" spellcheck="true">#       with an environment variable of the same name</span>    <span class="token function">readonly</span> DEFAULT_VAL<span class="token operator">=</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;DEFAULT_VAL:-7&amp;#125;</span>    myfunc<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>       <span class="token comment" spellcheck="true"># initialize a local variable with the global default</span>       local some_var<span class="token operator">=</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;DEFAULT_VAL&amp;#125;</span>       <span class="token punctuation">..</span>.    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，你可以将一个以前不是只读变量的变量声明成只读变量：</p><pre class="line-numbers language-bash"><code class="language-bash">x<span class="token operator">=</span>5x<span class="token operator">=</span>6<span class="token function">readonly</span> xx<span class="token operator">=</span>7   <span class="token comment" spellcheck="true"># failure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尽量对你bash脚本里的所有变量使用local或readonly进行注解。</p><h2 id="用-代替反单引号"><a href="#用-代替反单引号" class="headerlink" title="用$()代替反单引号(`)"></a>用$()代替反单引号(`)</h2><p>反单引号很难看，在有些字体里跟正单引号很相似。$()能够内嵌使用，而且避免了转义符的麻烦。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># both commands below print out: A-B-C-D</span><span class="token keyword">echo</span> <span class="token string">"A-<span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> B-\<span class="token variable">`</span></span>echo C-\\\<span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> D\\\<span class="token variable">`</span></span>\``"</span><span class="token keyword">echo</span> <span class="token string">"A-<span class="token variable"><span class="token variable">$(</span><span class="token keyword">echo</span> B-<span class="token punctuation">$(</span>echo C-<span class="token punctuation">$(</span>echo D<span class="token variable">)</span></span>))"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="用-双层中括号-替代"><a href="#用-双层中括号-替代" class="headerlink" title="用[[]](双层中括号)替代[]"></a>用<code>[[]]</code>(双层中括号)替代[]</h2><p>使用[[]]能避免像异常的文件扩展名之类的问题，而且能带来很多语法上的改进，而且还增加了很多新功能：</p><table><thead><tr><th>操作符</th><th>功能说明</th></tr></thead><tbody><tr><td>&#124;&#124;</td><td>逻辑or(仅双中括号里使用)</td></tr><tr><td>&amp;&amp;</td><td>逻辑and(仅双中括号里使用)</td></tr><tr><td>&lt;</td><td>字符串比较(双中括号里不需要转移)</td></tr><tr><td>-lt</td><td>数字比较</td></tr><tr><td>=</td><td>字符串相等</td></tr><tr><td>==</td><td>以Globbing方式进行字符串比较(仅双中括号里使用，参考下文)</td></tr><tr><td>=~</td><td>用正则表达式进行字符串比较(仅双中括号里使用，参考下文)</td></tr><tr><td>-n</td><td>非空字符串</td></tr><tr><td>-z</td><td>空字符串</td></tr><tr><td>-eq</td><td>数字相等</td></tr><tr><td>-ne</td><td>数字不等</td></tr></tbody></table><p>单中括号：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span> <span class="token string">"$&amp;#123;name&amp;#125;"</span> \<span class="token operator">></span> <span class="token string">"a"</span> -o $<span class="token operator">&amp;</span>#123<span class="token punctuation">;</span>name<span class="token operator">&amp;</span>#125<span class="token punctuation">;</span> \<span class="token operator">&lt;</span> <span class="token string">"m"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>双中括号</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"$&amp;#123;name&amp;#125;"</span> <span class="token operator">></span> <span class="token string">"a"</span> <span class="token operator">&amp;&amp;</span> <span class="token string">"$&amp;#123;name&amp;#125;"</span> <span class="token operator">&lt;</span> <span class="token string">"m"</span>  <span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="正则表达式-Globbing"><a href="#正则表达式-Globbing" class="headerlink" title="正则表达式/Globbing"></a>正则表达式/Globbing</h2><p>使用双中括号带来的好处用下面几个例子最能表现：</p><pre class="line-numbers language-bash"><code class="language-bash">t<span class="token operator">=</span><span class="token string">"abc123"</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$t</span>"</span> <span class="token operator">==</span> abc* <span class="token punctuation">]</span><span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># true (globbing比较)</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$t</span>"</span> <span class="token operator">==</span> <span class="token string">"abc*"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># false (字面比较)</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$t</span>"</span> <span class="token operator">=</span>~ <span class="token punctuation">[</span>abc<span class="token punctuation">]</span>+<span class="token punctuation">[</span>123<span class="token punctuation">]</span>+ <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># true (正则表达式比较)</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$t</span>"</span> <span class="token operator">=</span>~ <span class="token string">"abc*"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># false (字面比较)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，从bash 3.2版开始，正则表达式和globbing表达式都不能用引号包裹。如果你的表达式里有空格，你可以把它存储到一个变量里：</p><pre class="line-numbers language-bash"><code class="language-bash">r<span class="token operator">=</span><span class="token string">"a b+"</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"a bbb"</span> <span class="token operator">=</span>~ <span class="token variable">$r</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按Globbing方式的字符串比较也可以用到case语句中：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">case</span> <span class="token variable">$t</span> <span class="token keyword">in</span>abc*<span class="token punctuation">)</span>  <span class="token operator">&lt;</span>action<span class="token operator">></span> <span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Bash里有各种各样操作字符串的方式，很多都是不可取的。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre class="line-numbers language-bash"><code class="language-bash">    f<span class="token operator">=</span><span class="token string">"path1/path2/file.ext"</span>      len<span class="token operator">=</span><span class="token string">"$&amp;#123;#f&amp;#125;"</span> # <span class="token operator">=</span> 20 <span class="token punctuation">(</span>字符串长度<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 切片操作: $&amp;#123;&lt;var>:&lt;start>&amp;#125; or $&amp;#123;&lt;var>:&lt;start>:&lt;length>&amp;#125;</span>    slice1<span class="token operator">=</span><span class="token string">"$&amp;#123;f:6&amp;#125;"</span> # <span class="token operator">=</span> <span class="token string">"path2/file.ext"</span>    slice2<span class="token operator">=</span><span class="token string">"$&amp;#123;f:6:5&amp;#125;"</span> # <span class="token operator">=</span> <span class="token string">"path2"</span>    slice3<span class="token operator">=</span><span class="token string">"$&amp;#123;f: -8&amp;#125;"</span> # <span class="token operator">=</span> <span class="token string">"file.ext"</span><span class="token punctuation">(</span>注意：<span class="token string">"-"</span>前有空格<span class="token punctuation">)</span>    pos<span class="token operator">=</span>6    len<span class="token operator">=</span>5    slice4<span class="token operator">=</span><span class="token string">"$&amp;#123;f:$&amp;#123;pos&amp;#125;:$&amp;#123;len&amp;#125;&amp;#125;"</span> # <span class="token operator">=</span> <span class="token string">"path2"</span><span class="token operator">&lt;</span>/length<span class="token operator">></span><span class="token operator">&lt;</span>/start<span class="token operator">></span><span class="token operator">&lt;</span>/var<span class="token operator">></span><span class="token operator">&lt;</span>/start<span class="token operator">></span><span class="token operator">&lt;</span>/var<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="替换操作-使用globbing"><a href="#替换操作-使用globbing" class="headerlink" title="替换操作(使用globbing)"></a>替换操作(使用globbing)</h3><pre class="line-numbers language-bash"><code class="language-bash">    f<span class="token operator">=</span><span class="token string">"path1/path2/file.ext"</span>      single_subst<span class="token operator">=</span><span class="token string">"$&amp;#123;f/path?/x&amp;#125;"</span>   # <span class="token operator">=</span> <span class="token string">"x/path2/file.ext"</span>    global_subst<span class="token operator">=</span><span class="token string">"$&amp;#123;f//path?/x&amp;#125;"</span>  # <span class="token operator">=</span> <span class="token string">"x/x/file.ext"</span>    <span class="token comment" spellcheck="true"># 字符串拆分</span>    <span class="token function">readonly</span> DIR_SEP<span class="token operator">=</span><span class="token string">"/"</span>    array<span class="token operator">=</span><span class="token punctuation">(</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;f//$&amp;#123;DIR_SEP&amp;#125;/ &amp;#125;)</span>    second_dir<span class="token operator">=</span><span class="token string">"$&amp;#123;arrray[1]&amp;#125;"</span>     # <span class="token operator">=</span> path2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除头部或尾部-使用globbing"><a href="#删除头部或尾部-使用globbing" class="headerlink" title="删除头部或尾部(使用globbing)"></a>删除头部或尾部(使用globbing)</h3><pre class="line-numbers language-bash"><code class="language-bash">    f<span class="token operator">=</span><span class="token string">"path1/path2/file.ext"</span>    <span class="token comment" spellcheck="true"># 删除字符串头部</span>    extension<span class="token operator">=</span><span class="token string">"$&amp;#123;f#*.&amp;#125;"</span>  # <span class="token operator">=</span> <span class="token string">"ext"</span>    <span class="token comment" spellcheck="true"># 以贪婪匹配方式删除字符串头部</span>    filename<span class="token operator">=</span><span class="token string">"$&amp;#123;f##*/&amp;#125;"</span>  # <span class="token operator">=</span> <span class="token string">"file.ext"</span>    <span class="token comment" spellcheck="true"># 删除字符串尾部</span>    dirname<span class="token operator">=</span><span class="token string">"$&amp;#123;f%/*&amp;#125;"</span>    # <span class="token operator">=</span> <span class="token string">"path1/path2"</span>    <span class="token comment" spellcheck="true"># 以贪婪匹配方式删除字符串尾部</span>    root<span class="token operator">=</span><span class="token string">"$&amp;#123;f%%/*&amp;#125;"</span>      # <span class="token operator">=</span> <span class="token string">"path1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="避免使用临时文件"><a href="#避免使用临时文件" class="headerlink" title="避免使用临时文件"></a>避免使用临时文件</h2><p>有些命令需要以文件名为参数，这样一来就不能使用管道。这个时候 &lt;() 就显出用处了，它可以接受一个命令，并把它转换成可以当成文件名之类的什么东西：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载并比较两个网页</span><span class="token function">diff</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>wget -O - url1<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>wget -O - url2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还有一个非常有用处的是”here documents”，它能让你在标准输入上输入多行字符串。下面的’MARKER’可以替换成任何字词。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 任何字词都可以当作分界符</span><span class="token function">command</span>  <span class="token operator">&lt;&lt;</span> <span class="token string">MARKER...$&amp;#123;var&amp;#125;<span class="token variable"><span class="token variable">$(</span>cmd<span class="token variable">)</span></span>...MARKER</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果文本里没有内嵌变量替换操作，你可以把第一个MARKER用单引号包起来：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">command</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'MARKER'...no substitution is happening here.$ (dollar sign) is passed through verbatim....MARKER</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$0</td><td>脚本名称</td></tr><tr><td>$n</td><td>传给脚本/函数的第n个参数</td></tr><tr><td>$$</td><td>脚本的PID</td></tr><tr><td>$!</td><td>上一个被执行的命令的PID(后台运行的进程)</td></tr><tr><td>$?</td><td>上一个命令的退出状态(管道命令使用${PIPESTATUS})</td></tr><tr><td>$#</td><td>传递给脚本/函数的参数个数</td></tr><tr><td>$@</td><td>传递给脚本/函数的所有参数(识别每个参数)</td></tr><tr><td>$*</td><td>传递给脚本/函数的所有参数(把所有参数当成一个字符串)</td></tr></tbody></table><p><strong>提示</strong></p><blockquote><p>使用$*很少是正确的选择。</p></blockquote><blockquote><p>$@能够处理空格参数，而且参数间的空格也能正确的处理。</p></blockquote><blockquote><p>使用$@时应该用双引号括起来，像”$@”这样。</p></blockquote><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>对脚本进行语法检查：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -n myscript.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跟踪脚本里每个命令的执行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -v myscripts.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跟踪脚本里每个命令的执行并附加扩充信息：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -x myscript.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以在脚本头部使用set -o verbose和set -o xtrace来永久指定-v和-o。当在远程机器上执行脚本时，这样做非常有用，用它来输出远程信息。</p><h2 id="什么时候不应该使用bash脚本"><a href="#什么时候不应该使用bash脚本" class="headerlink" title="什么时候不应该使用bash脚本"></a>什么时候不应该使用bash脚本</h2><ul><li>你的脚本太长，多达几百行</li><li>你需要比数组更复杂的数据结构</li><li>出现了复杂的转义问题</li><li>有太多的字符串操作</li><li>不太需要调用其它程序和跟其它程序管道交互</li><li>担心性能</li></ul><p>这个时候，你应该考虑一种脚本语言，比如Python或Ruby。</p><p>[转自 <a href="http://blog.sae.sina.com.cn/archives/3606]">http://blog.sae.sina.com.cn/archives/3606]</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的技术技巧最初是来自谷歌的“Testing on the Toilet” (TOTT)。这里是一个修订和扩增版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本安全&lt;/li&gt;
&lt;li&gt;脚本函数&lt;/li&gt;
&lt;li&gt;变量注解&lt;/li&gt;
&lt;li&gt;用$()代替反单引号(`)&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;[[]]&lt;/code&gt;(双层中括号)替代[]&lt;/li&gt;
&lt;li&gt;正则表达式/Globbing&lt;/li&gt;
&lt;li&gt;字符串操作&lt;/li&gt;
&lt;li&gt;避免使用临时文件&lt;/li&gt;
&lt;li&gt;内置变量&lt;/li&gt;
&lt;li&gt;调试&lt;/li&gt;
&lt;li&gt;什么时候不应该使用bash脚本&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>sudo使用场景分析[转]</title>
    <link href="https://weizhimiao.github.io/2016/11/16/sudo%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/11/16/sudo%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</id>
    <published>2016-11-16T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。</p><ul><li><p>情景一：用户无权限执行 root 命令</p></li><li><p>情景二：vim 编辑后发现忘记使用 sudo</p></li><li><p>情景三：执行 root 命令忘记加 sudo</p></li><li><p>情景四：shell 内置命令如何使用 sudo</p></li><li><p>情景五：sudo 操作记录日志</p></li></ul><span id="more"></span><h2 id="情景一：用户无权限执行-root-命令"><a href="#情景一：用户无权限执行-root-命令" class="headerlink" title="情景一：用户无权限执行 root 命令"></a>情景一：用户无权限执行 root 命令</h2><p>普通用户登录 shell 之后，如果自身没有权限访问某个文件或执行某个命令时，若该用户获得root授权，那么就可以在需要执行的命令之前加上 sudo，临时切换到root用户的权限，完成相关的操作。在sudo于1980年前后被写出之前，一般用户管理系统的方式是利用su切换为超级用户。但是使用su的缺点之一在于必须要先告知超级用户的密码，而sudo使一般用户不需要知道超级用户的密码即可获得权限。</p><p>那么哪些用户可以临时获得 root 权限呢？这就需要在 <code>/etc/sudoers</code> 文件中进行配置：</p><p>授权给单个用户：</p><pre><code># User privilege specificationguohl   ALL=(ALL) ALL</code></pre><p>上面这个例子中：</p><ul><li><p>guohl：允许使用 sudo 的用户名</p></li><li><p>ALL：允许从任何终端（任何机器）使用 sudo</p></li><li><p>(ALL)：允许以任何用户执行 sudo 命令</p></li><li><p>ALL：允许 sudo 权限执行任何命令</p></li></ul><p>如果我们想让用户 test 只能在本主机（主机名为guohl-pc）以 root 账户执行/bin/chown、/bin/chmod 两条命令，那么就应该这样配置：</p><pre><code># User privilege specificationtest   guohl-pc=(root) /bin/chown,/bin/chmod</code></pre><p>如果test 登录之后运行 sudo 命令，不满足上面三个条件命令均失败。</p><p>授权给用户组:</p><pre><code># Allow members of group sudo to execute any command# (Note that later entries override this, so you might need to move it further down)%sudo ALL=(ALL) ALL和授权给单个用户类似，只不过将用户名在这里换成%组名，所有在该组中的用户都按照此规则进行授权。对于该例，所有在 sudo 组内的用户都有在任何终端（第一个ALL）、以任何用户（第二个ALL）、执行任何命令（第三个ALL）的权限，查看 /etc/group 文件可以知道哪些用户属于 sudo 组。</code></pre><p>举例:</p><p>如果当前帐号在 /etc/sudoers 文件中被授予 sudo 的权限，那么你就可以将任何 root 命令作为 sudo 命令的参数，使用 root 权限来执行该命令。举例来说，挂载一个文件系统只能由 root 来执行，但是一个普通用户也可以使用 sudo 来挂载：</p><pre><code>$sudo mount /dev/sda7 /mnt[sudo] password for guohailin:</code></pre><p>首次使用会要求你输入当前用户的密码，系统确实输入正确即以 root 权限来执行 mount 命令，接下来一段时间（默认为5分钟）再次使用 sudo 命令就不需要输密码了。</p><h2 id="情景二：vim-编辑后发现忘记使用-sudo"><a href="#情景二：vim-编辑后发现忘记使用-sudo" class="headerlink" title="情景二：vim 编辑后发现忘记使用 sudo"></a>情景二：vim 编辑后发现忘记使用 sudo</h2><p>我们经常会遇到这样的一个囧境：使用 <code>vim</code> 对某个文件进行编辑，编辑完之后，按 ESC 之后回到普通模式，再按 <code>:wq</code> 准备保存退出时，发现没有权限对该文件进行修改，我们在使用 <code>vim</code> 命令时忘记在前面加 <code>sudo</code> 了。我就经常出现这种问题，之前的做法是只能不保存强退，再加上 <code>sudo</code> 重新编辑。</p><p>但是今后我们再也不需要用这么愚蠢的做法了，我们可以在 vim 的普通模式下，按 <code>:w !sudo tee % </code>，这样就可以 root 权限来保存文件了，你也无需因为自己一时忘记加个 sudo 而沮丧懊恼了！</p><h2 id="情景三：执行-root-命令忘记加-sudo"><a href="#情景三：执行-root-命令忘记加-sudo" class="headerlink" title="情景三：执行 root 命令忘记加 sudo"></a>情景三：执行 root 命令忘记加 sudo</h2><p>我们还会遇到这样稍微好一点的情形：输入一个长长的命令，按 Enter 之后出现无权限操作，因为我们忘记加 sudo 了。大多人的做法是按 ↑ 回到上一条命令，在该命令之前加上 sudo，再执行该命令。</p><p>以后，我们无需这样了，只要输入 <code>sudo !!</code> 即可，这里的 <code>!!</code> 代表上一条命令。如：</p><pre><code>$ head -n 4 /etc/sudoershead: cannot open `/etc/sudoers&#39; for reading: Permission denied$ sudo !!sudo head -n 4 /etc/sudoers# /etc/sudoers## This file MUST be edited with the &#39;visudo&#39; command as root.#</code></pre><h2 id="情景四：shell-内置命令如何使用-sudo"><a href="#情景四：shell-内置命令如何使用-sudo" class="headerlink" title="情景四：shell 内置命令如何使用 sudo"></a>情景四：shell 内置命令如何使用 sudo</h2><p>shell 是一个交互式的应用程序，在执行外部命令时通过 fork 来创建一个子进程，再通过 exec 来加载外部命令的程序来执行，但是如果一个命令是 shell 内置命令，那么只能直接由 shell 来运行。sudo 的意思是，以别的用户（如root）的权限来 fork 一个进程，加载程序并运行，因此 sudo 后面不能跟 shell 的内置命令，如：</p><pre><code>$ sudo cd /sys/kernel/debugfssudo: cd: command not found</code></pre><p>在这种情况，我们又没有 root 账户的密码，我们怎样执行该命令呢？有种办法就是使用 sudo 获得root shell 的权限，然后在root shell 中执行该命令。进入root shell 很简单，输入sudo bash 确认本用户的密码即可，此时你会发现命令提示符显示当前是 root。一旦获得root shell，你可以执行任何命令而不需要在每条命令前输入sudo了。</p><p>另外，常用的shell 内置命令在<a href="http://www.thegeekstuff.com/2010/08/bash-shell-builtin-commands/">这里</a> 有简单介绍，我们可以使用 type 命令来查看命令的类型，如：</p><pre><code>$ type lsls is /bin/ls$ type umaskumask is a shell builtin</code></pre><h2 id="情景五：sudo-操作记录日志"><a href="#情景五：sudo-操作记录日志" class="headerlink" title="情景五：sudo 操作记录日志"></a>情景五：sudo 操作记录日志</h2><p>作为一个 Linux 系统的管理员，不仅可以让指定的用户或用户组作为root用户或其它用户来运行某些命令，还能将指定的用户所输入的命令和参数作详细的记录。而sudo的日志功能就可以用户跟踪用户输入的命令，这不仅能增进系统的安全性，还能用来进行故障检修。但是要记录sudo的日志还要一些简单的配置：</p><p>1、创建sudo日志文件</p><p>我们将sudo日志文件放置在 <code>/var/log/sudo.log</code> 文件中：</p><pre><code>  $ sudo touch /var/log/sudo.log</code></pre><p>2、修改 <code>/etc/rsyslog.conf</code> 配置文件</p><p>我使用系统为<code>Ubuntu13.04 </code>为改名字，但有些系统名为<code>/etc/syslog.conf</code>，注意不同发行版之间的差别，在该文件加入下面一行：</p><pre><code>  local2.debug    /var/log/sudo.log    #空白不能用空格，必须用tab</code></pre><p>3、修改 /etc/sudoers 配置文件</p><p>注意网上很多关于sudo日志文件配置都缺少这一步！在该文件中加入下面一行：</p><pre><code>  Defaults    logfile=/var/log/sudo.log</code></pre><p>4、重启 syslog 服务：</p><pre><code>  $ sudo service rsyslog restart</code></pre><p>5、查看 sudo 日志记录：</p><p>经过上面的配置，sudo 的所有成功和不成功的sudo</p><p>命令都记录到文件/var/log/sudo.log 中，例如我运行几条sudo 命令之后，查看该文件的记录如下：</p><pre><code>  $ cat sudo.log  Sep 20 22:10:51 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;      COMMAND=/bin/cat /etc/sudoers  Sep 20 22:11:36 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;      COMMAND=/usr/sbin/service rsyslog restart  Sep 20 22:11:45 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;      COMMAND=/bin/ls  Sep 20 22:12:08 : guohailin : TTY=pts/1 ; PWD=/var/log ; USER=root ;      COMMAND=/bin/ls /root/</code></pre><p>[原文：<a href="http://www.cnblogs.com/hazir/p/sudo_command.html]">http://www.cnblogs.com/hazir/p/sudo_command.html]</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 下使用 sudo 命令，可以让普通用户也能执行一些或者全部的 root 命令。本文就对我们常用到 sudo 操作情景进行简单分析，通过一些例子来了解 sudo 命令相关的技巧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;情景一：用户无权限执行 root 命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景二：vim 编辑后发现忘记使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景三：执行 root 命令忘记加 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景四：shell 内置命令如何使用 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;情景五：sudo 操作记录日志&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="sudo" scheme="https://weizhimiao.github.io/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法与实现（PHP）汇总</title>
    <link href="https://weizhimiao.github.io/2016/11/07/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88PHP%EF%BC%89%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/11/07/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%88PHP%EF%BC%89%E6%B1%87%E6%80%BB/</id>
    <published>2016-11-07T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>堆排序</li><li>桶排序</li><li>基数排序</li><li>希尔排序</li></ul><span id="more"></span><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li><p>思路分析</p><blockquote><p>在排序的一组数中，对当前还未排好的序列，从前后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的数往上冒。</p><p>即，每当两个相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [bubblingSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">bubblingSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//控制需要冒泡的轮数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">//控制每层冒出一个数 需要比较的次数</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$k</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$k</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span><span class="token operator">-</span><span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token variable">$k</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$k</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">bubblingSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li><p>思路分析</p><blockquote><p>在要排序的一组数中，选出最小的一个数与第一个位置的数交换。</p><p>然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [selectSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//双重循环，外层控制循环轮数，内层控制比较次数</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$len</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">//先假设最小的值的位置</span>      <span class="token variable">$p</span> <span class="token operator">=</span> <span class="token variable">$i</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span><span class="token operator">=</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$j</span><span class="token operator">&lt;</span><span class="token variable">$len</span><span class="token punctuation">;</span><span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">//$arr[$p] 是当前已知的最小值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$p</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token comment" spellcheck="true">//比较，发现更小的，记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较</span>          <span class="token variable">$p</span> <span class="token operator">=</span> <span class="token variable">$j</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token comment" spellcheck="true">//已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$p</span> <span class="token operator">!=</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$p</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$p</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li><p>思路分析</p><blockquote><p>在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插入到前面的有序数中，使得这n个数也是排好序的。如此反复循环，直到全部排好顺序。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [insertSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$len</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//内层循环控制，比较并插入</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span><span class="token operator">=</span><span class="token variable">$i</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$j</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$j</span><span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$tmp</span> <span class="token operator">&lt;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token comment" spellcheck="true">//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else&amp;#123;</span>          <span class="token comment" spellcheck="true">//如果碰到不需要移动的元素，由于是已经排序好的数组，则前面的就不需要再次比较了</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><p>思路分析</p><blockquote><p>选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。</p><p>此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [quickSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//先判断是否需要继续进行</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//选择第一个元素作为基准</span>    <span class="token variable">$base_num</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历除了标尺外的所有元素，按照大小关系放入两个数组内</span>    <span class="token comment" spellcheck="true">//初始化两个数组</span>    <span class="token variable">$left_array</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//小于基准值的数组</span>    <span class="token variable">$right_array</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//大于基准的数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$len</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$base_num</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">//放入左边</span>        <span class="token variable">$left_array</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else&amp;#123;</span>        <span class="token comment" spellcheck="true">//放入右边</span>        <span class="token variable">$right_array</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数</span>    <span class="token variable">$left_array</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$left_array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$right_array</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$right_array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//合并</span>    <span class="token keyword">return</span> <span class="token function">array_merge</span><span class="token punctuation">(</span><span class="token variable">$left_array</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$base_num</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$right_array</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li><p>思路分析</p><blockquote><p>采用分治法，将已有序的子序列合并,从而得到完全有序的序列.</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [mergeSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//获取中间参考点值</span>    <span class="token variable">$middle</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$len</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取左边区间</span>    <span class="token variable">$left</span> <span class="token operator">=</span> <span class="token function">array_slice</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$middle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//取右边区间</span>    <span class="token variable">$right</span> <span class="token operator">=</span> <span class="token function">array_slice</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$middle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//调用归并函数</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * 归并函数   * @param  [type] $left  [description]   * @param  [type] $right [description]   * @return [type]        [description]   */</span>  <span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">,</span> <span class="token variable">$right</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token variable">$right</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">,</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else&amp;#123;</span>        <span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">,</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//解决$left遗留元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">,</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//解决$right遗留元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token function">array_push</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">,</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$res</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>思路分析<blockquote><p><strong>建堆</strong>，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。</p><p><strong>调整堆</strong>：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。</p><p><strong>堆排序</strong>：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlgn)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是lgn，调用了n-1次，所以堆排序的时间复杂度是O(nlgn)</p></blockquote></li></ul><ul><li>实现</li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [heapSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token shell-comment comment">#初始化大顶堆</span>      <span class="token function">initHeap</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token shell-comment comment">#开始交换首尾节点,并每次减少一个末尾节点再调整堆,直到剩下一个元素</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$end</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$end</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$end</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$end</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$end</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span>          <span class="token function">ajustNodes</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$end</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * 初始化大顶堆   * 初始化最大堆,从最后一个非叶子节点开始,最后一个非叶子节点编号为 数组长度/2 向下取整   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">initHeap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$start</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$start</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$start</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token function">ajustNodes</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * 调整节点   * @param  [type] $arr   待调整数组   * @param  [type] $start 调整的父节点坐标   * @param  [type] $end   待调整数组结束节点坐标   * @return [type]        [description]   */</span>  <span class="token keyword">function</span> <span class="token function">ajustNodes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token variable">$end</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$maxInx</span> <span class="token operator">=</span> <span class="token variable">$start</span><span class="token punctuation">;</span>      <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token variable">$end</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#待调整部分长度</span>      <span class="token variable">$leftChildInx</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$start</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#左孩子坐标</span>      <span class="token variable">$rightChildInx</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$start</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#右孩子坐标</span>      <span class="token shell-comment comment">#如果待调整部分有左孩子</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$leftChildInx</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token variable">$len</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token shell-comment comment">#获取最小节点坐标</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$maxInx</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$leftChildInx</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>              <span class="token variable">$maxInx</span> <span class="token operator">=</span> <span class="token variable">$leftChildInx</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>          <span class="token shell-comment comment">#如果待调整部分有右子节点</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$rightChildInx</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token variable">$len</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$maxInx</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$rightChildInx</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                  <span class="token variable">$maxInx</span> <span class="token operator">=</span> <span class="token variable">$rightChildInx</span><span class="token punctuation">;</span>              <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>          <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token shell-comment comment">#交换父节点和最大节点</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$start</span> <span class="token operator">!=</span> <span class="token variable">$maxInx</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$start</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$start</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$maxInx</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$maxInx</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span>          <span class="token shell-comment comment">#如果交换后的子节点还有子节点,继续调整</span>          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$maxInx</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token variable">$len</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>              <span class="token function">ajustNodes</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$maxInx</span><span class="token punctuation">,</span> <span class="token variable">$end</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ul><li><p>思路分析</p><blockquote><p>先将数组根据其值的大小放入到桶的相应位置，然后在按照顺序将元素从桶中取出。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [tongSort description]   * @param  [type] $arr [description]   * @param  [type] $max [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">tongSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$max</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//填充木桶</span>        <span class="token variable">$tong</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$max</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$tong</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//开始标示木桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$len</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$tong</span><span class="token punctuation">[</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token variable">$res</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始从木桶中拿出数据</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span> <span class="token variable">$max</span> <span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$tong</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;=</span> <span class="token variable">$tong</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123; </span><span class="token comment" spellcheck="true">//这一行主要用来控制输出多个数</span>            <span class="token variable">$res</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$i</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">return</span> <span class="token variable">$res</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">tongSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul><li><p>思路分析</p><blockquote><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</p><p>然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [countingSort description]   * @param  [type]  $arr       [description]   * @param  boolean $digit_num [description]   * @return [type]             [description]   */</span>  <span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$digit_num</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$digit_num</span> <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123; #如果参数$digit_num不为空，则根据元素的第$digit_num位数进行排序</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>         <span class="token variable">$arr_temp</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">get_specific_digit</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$digit_num</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else &amp;#123;</span>       <span class="token variable">$arr_temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token variable">$max</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$time_arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token shell-comment comment">#储存元素出现次数的数组</span>     <span class="token shell-comment comment">#初始化出现次数数组</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;=</span> <span class="token variable">$max</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token shell-comment comment">#统计每个元素出现次数</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr_temp</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$arr_temp</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token shell-comment comment">#统计每个元素比其小或相等的元素出现次数</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$time_arr</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token shell-comment comment">#利用出现次数对数组进行排序</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token variable">$sorted_arr</span><span class="token punctuation">[</span><span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$arr_temp</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token variable">$time_arr</span><span class="token punctuation">[</span><span class="token variable">$arr_temp</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token variable">$sorted_arr</span><span class="token punctuation">;</span>     <span class="token function">ksort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token shell-comment comment">#忽略这次对key排序的效率损耗</span>     <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>   <span class="token comment" spellcheck="true">/**    * 计算某个数的位数    * @param  [type] $number [description]    * @return [type]         [description]    */</span>   <span class="token keyword">function</span> <span class="token function">get_digit</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>     <span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token variable">$number</span> <span class="token operator">>=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token keyword">return</span> <span class="token variable">$i</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>   <span class="token comment" spellcheck="true">/**    * 获取某个数字的从个位算起的第i位数    * @param  [type] $num [description]    * @param  [type] $i   [description]    * @return [type]      [description]    */</span>   <span class="token keyword">function</span> <span class="token function">get_specific_digit</span><span class="token punctuation">(</span><span class="token variable">$num</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$num</span> <span class="token operator">&lt;</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token keyword">return</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$num</span> <span class="token operator">%</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>   <span class="token comment" spellcheck="true">/**    * 基数排序,以计数排序作为子排序过程    * @param  [type] $arr [description]    * @return [type]      [description]    */</span>   <span class="token keyword">function</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>     <span class="token shell-comment comment">#先求出数组中最大的位数</span>     <span class="token variable">$max</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$max_digit</span> <span class="token operator">=</span> <span class="token function">get_digit</span><span class="token punctuation">(</span><span class="token variable">$max</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;=</span> <span class="token variable">$max_digit</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>       <span class="token function">counting_sort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul><li><p>思路分析：</p><blockquote><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p></blockquote></li><li><p>实现</p></li></ul><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">223</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">455</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">823</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [shellSort description]   * @param  [type] $arr [description]   * @return [type]      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$length</span><span class="token operator">=</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$h</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$h</span><span class="token operator">&lt;</span><span class="token variable">$length</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$h</span><span class="token operator">=</span><span class="token number">3</span><span class="token operator">*</span><span class="token variable">$h</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置间隔</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$h</span><span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token variable">$h</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token variable">$length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span><span class="token operator">=</span><span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">>=</span><span class="token variable">$h</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">-</span><span class="token variable">$h</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">-</span><span class="token operator">=</span><span class="token variable">$h</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>           <span class="token variable">$temp</span> <span class="token operator">=</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">-</span><span class="token variable">$h</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">-</span><span class="token variable">$h</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token variable">$temp</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token variable">$h</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token variable">$h</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单比较"><a href="#简单比较" class="headerlink" title="简单比较"></a>简单比较</h2><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161107/sort_img.png" alt="sort"></p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;桶排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="算法" scheme="https://weizhimiao.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本（二）</title>
    <link href="https://weizhimiao.github.io/2016/11/01/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://weizhimiao.github.io/2016/11/01/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2016-11-01T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p><span id="more"></span><p>1、进程运行前后台切换</p><pre><code>Ctrl+z        # 将进程转入后台运行</code></pre><pre><code>fg                # 将进程转到前台</code></pre><p>示例：</p><pre><code>$ ping www.baidu.comPING www.a.shifen.com (119.75.217.109): 56 data bytes64 bytes from 119.75.217.109: icmp_seq=0 ttl=57 time=6.829 ms64 bytes from 119.75.217.109: icmp_seq=1 ttl=57 time=32.417 ms64 bytes from 119.75.217.109: icmp_seq=2 ttl=57 time=5.999 ms64 bytes from 119.75.217.109: icmp_seq=3 ttl=57 time=21.105 ms^Z[1]  + 1879 suspended  ping www.baidu.com--------------------------------------------------------------$ fg                [1]  + 1879 continued  ping www.baidu.com64 bytes from 119.75.217.109: icmp_seq=4 ttl=57 time=27.063 ms64 bytes from 119.75.217.109: icmp_seq=5 ttl=57 time=5.939 ms64 bytes from 119.75.217.109: icmp_seq=6 ttl=57 time=6.633 ms64 bytes from 119.75.217.109: icmp_seq=7 ttl=57 time=7.462 ms^C--- www.a.shifen.com ping statistics ---8 packets transmitted, 8 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 5.939/14.181/32.417/10.232 ms</code></pre><p>2、截取前5个字符</p><pre><code>$ var=&quot;hello world&quot;$ echo $&#123;var:0:5&#125;hello</code></pre><p>3、一次创建多个目录</p><pre><code>$ mkdir -p data/&#123;test,test1,test2&#125;$ tree datadata├── test├── test1└── test2</code></pre><p>4、获得文本的md5 hash</p><pre><code>echo -n &quot;testText&quot; | md5sum</code></pre><p>5、将tar.gz提取到新目录</p><pre><code>$ tar -zxvf package.tar.gz -C /path/to/new</code></pre><p>6、通过curl获取HTTP头信息</p><pre><code>$ curl -I http://www.baidu.comHTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Tue, 01 Nov 2016 15:00:30 GMTContent-Type: text/htmlContent-Length: 277Last-Modified: Mon, 13 Jun 2016 02:50:08 GMTConnection: Keep-AliveETag: &quot;575e1f60-115&quot;Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transformPragma: no-cacheAccept-Ranges: bytes</code></pre><p>7、快速备份一个文件</p><pre><code>$ ll-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt$ cp test.txt&#123;,.bak&#125;$ ll-rw-r--r--   1 zhimiao  staff   200B  2 29  2016 test.txt-rw-r--r--   1 zhimiao  staff   200B 11  1 23:02 test.txt.bak</code></pre><p>8、利用cat快速输入多行文字（Ctrl+d 退出）</p><pre><code>$ cat &gt; test2.txtweizhadfasdfadsasdfadsfasdfadf(Ctrl+d)$ cat test2.txtweizhadfasdfadsasdfadsfasdfadf</code></pre><p>9、重复运行命令，并显示其输出（默认是2秒运行一次）</p><pre><code>watch ps -efEvery 2.0s: ps -ef                                                                     Tue Nov  1 23:10:06 2016  UID   PID  PPID   C STIME   TTY           TIME CMD    0     1     0   0 10:28    ??         0:05.23 /sbin/launchd    0    47     1   0 10:28    ??         0:01.21 /usr/libexec/UserEventAgent (System)    0    48     1   0 10:28    ??         0:00.42 /usr/sbin/syslogd    0    50     1   0 10:28    ??         0:00.14 /System/Library/PrivateFrameworks/Uninstall.framework/Resources/uninstalld......</code></pre><p>10、递归查找目录中文件中的内容</p><pre><code>$ grep -r &quot;some_text&quot; /path/</code></pre><p>11、将所有的文件名中含有”*.txt”的文件，移入指定目录中</p><pre><code>$ find -iname &quot;*.txt*&quot; -exec mv -v &#123;&#125; /home/user \;</code></pre><p>12、拆分大体积tar.gz文件（拆成每个100MB），然后合并</p><pre><code>$ split -b 100m /path/to/large/archive /path/to/output/files$ cat files* &gt; archive</code></pre><p>13、Shell(Bash)中如何判断是否存在某个命令</p><pre><code># 判断foo命令是否存在$ command -v foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&#39;s not installed.  Aborting.&quot;; exit 1; &#125;$ type foo &gt;/dev/null 2&gt;&amp;1 || &#123; echo &gt;&amp;2 &quot;I require foo but it&#39;s not installed.  Aborting.&quot;; exit 1; &#125;$ hash foo 2&gt;/dev/null || &#123; echo &gt;&amp;2 &quot;I require foo but it&#39;s not installed.  Aborting.&quot;; exit 1; &#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中常用的shell脚本</title>
    <link href="https://weizhimiao.github.io/2016/10/30/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC/"/>
    <id>https://weizhimiao.github.io/2016/10/30/Linux%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC/</id>
    <published>2016-10-30T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161030/bash.png" alt="Linux中常用的shell脚本"></p><span id="more"></span><p>1、对于进程来说，查看其运行时的环境变量</p><pre><code>cat /proc/$PID/environ</code></pre><p>示例</p><pre><code>#首先需要我们运行一个程序# pgrep inotifywait8977# cat /proc/8977/environHOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xterm-256colorSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.1.100 63684 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=rootLS_COLORS=rs=0:di=38;... %sG_BROKEN_FILENAMES=1_=/usr/local/bin/inotifywaitOLDPWD=/data#一般返回的环境变量会有很多，我们采用换行方式查看会更直观# cat /proc/8977/environ | tr &#39;\0&#39; &#39;\n&#39;HOSTNAME=localhost.localdomainSELINUX_ROLE_REQUESTED=TERM=xterm-256colorSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=192.168.1.100 63684 22SELINUX_USE_CURRENT_RANGE=SSH_TTY=/dev/pts/0USER=root....</code></pre><p>2、获得字符串长度</p><pre><code># var=wahaha# echo $&#123;var&#125;wahaha# echo $&#123;#var&#125;6</code></pre><p>3、识别当前使用的是哪种shell</p><pre><code>echo $SHELL/bin/bash</code></pre><p>4、shell脚本检查是执行当前脚本的是否为root用户</p><pre><code># cat check_root.sh#!/bin/bashif [ $UID -ne 0 ]; then    echo &quot;Non root user. Please run as root.&quot;else    echo Root Userfi</code></pre><p>5、修改bash提示字符串（username@hastname:~$）</p><pre><code>#利用PS1环境变量来定制# cat ~/.bashrc | grep PS1PS1=&#39;$&#123;debian_chroot:+$($debian_chroot)&#125;\u@\h:\w\$ &#39;# \u 用户名# \h 主机名# \w 当前工作目录</code></pre><p>6、如何判断一个命令是否执行成功</p><pre><code>当一个命令发生错误并退回时，他会返回一个非0的退出状态；而当命令成功完成后，它会返回数字0.退出状态可以从特殊变量 $? 中获得（在命令执行之后立刻运行 $? ,就可以打印出退出状态）</code></pre><pre><code>#!/bin/bashCMD=&quot;commod&quot;  #commod代表需要检测退出状态的命令$CMDif [ $? -eq 0 ];then  echo &quot;$CMD executed succ&quot;else  echo &quot;$CMD excuted unsucc&quot;fi</code></pre><p>7、shell中数组的定义与操作</p><pre><code>#定义1array_var=(1 2 3 4 5)#定义2array_var[0]=&quot;test&quot;array_var[1]=&quot;test1&quot;array_var[2]=&quot;test2&quot;array_var[3]=&quot;test3&quot;#打印特定索引数组元素echo $&#123;array_var[0]&#125;#以清单形式打印出数组中的所有值echo $&#123;array_var[*]&#125;test test1 test2 test3#也可以echo $&#123;array_var[@]&#125;test test1 test2 test3#输出数组元素个数echo $&#123;#array_var[*]&#125;4</code></pre><p>8、按照指定格式打印系统当前时间</p><pre><code># date &quot;+%Y%m%d&quot;20161029# %a  星期  例，Sat# %A  星期  例，Saturday# %b  月    例，Nov# %B  月    例，November# %d  日   例，31# %D  固定格式(mm/dd/yy)  例，10/18/10# %y  年   例，16# %Y  年   例，2016# %I或%H 小时  例，08# %M  分钟  例，30# %S  秒   例，10# %N  纳秒  例，694394444</code></pre><p>9、shell函数参数传递</p><pre><code>#!/bin/bashfunc()&#123;  echo $1,$2  #访问参数1和参数2  echo &quot;$@&quot;   #以列表方式一次性打印所有参数  echo &quot;$*&quot;   #类似于$@,但是参数被作为单个实体  return 0;   #返回值&#125;# $1,  第一个参数# $2,  第二个参数# $n,  第n个参数# &quot;$@&quot;,   被扩展成&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;等# &quot;$*&quot;,   被扩展成&quot;$1c$2c$3&quot; ，其中c是IFS的第一个字符# &quot;$@&quot;要比&quot;$*&quot;用的多。由于&quot;$*&quot;将所有参数当做单个字符串，因此它很少被使用</code></pre><p>10、利用子shell生成独立进程</p><pre><code># cat sub_shell.sh#!/bin/bashpwd;(cd /bin; pwd);pwd;# ./sub_shell.sh/root/shell/bin/root/shell# 我们可以发现（）中的子shell对于当前shell没有影响，它所有的改变仅限于（）内部</code></pre><p>11、运行命令直至成功</p><pre><code>repeat()&#123;  while true  do    $@  &amp;&amp; return  done&#125;# 原理：该函数通过$@接收传参。如果命令执行成功，则返回并退出循环，否则一直循环# Tips：将该函数加入的shell的rc文件中，方便我们使用# 示例：使用repeat（）从网上下载一个文件，直至成功repeat wget -c http://xxxx.com/example.tar.gz</code></pre><p>12、删除多余的空行</p><pre><code># cat -s file &gt;&gt; newfile</code></pre><p>13、文件查找</p><pre><code># find /home -name &quot;*.txt&quot;# find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)...</code></pre><p>14、排序、去重</p><pre><code># 排序  sort# 去重  uniqsort file.txt | uniq</code></pre><pre><code># cat check_sorted.sh#!/bin/bash# 功能：检查文件是否已经排序过sort -C filename;if [ $? -eq 0 ]then  echo Sortedelse  echo Unsortedfi</code></pre><p>15、交互输出自动化实现</p><pre><code>#!/bin/bash# 文件名：enter.shread -p &quot;Enter number:&quot; no ;read -p &quot;Enter name&quot; name ;echo You have entered $no $name;</code></pre><pre><code>#利用echo -e来生成输入序列echo -e &quot;1\nhello\n&quot; | ./enter.sh</code></pre><p>16、利用并行进程加速命令执行</p><pre><code>#!/bin/bashPIDARRAY=()for file in File1.ios File2.iosdo  md5sum $file &amp;  PIDARRAY+=(&quot;$!&quot;)donewait $&#123;PIDARRAY[@]&#125;# 原理：利用bash的操作符&amp;，它使得shell将命令置于后台并继续执行脚本。使用 $! 来获得进程的PID（在bash中 $! 保存最近一个后台进程的PID）。将这些进程PID放入PIDARRAY数组中。使用wait命令等待这些进程执行完成。</code></pre><p>17、查找并删除内容重复的文件</p><pre><code>#创建测试文件testfile，testfile1，testfile2，newfile ;其中testfile1和testfile2都是testfile的副本# echo &quot;hello&quot; &gt;&gt; testfile# cp testfile testfile1# cp testfile testfile2# echo hello world &gt;&gt; newfile# cat remove_duplicates.sh#!/bin/bashls -lS --time-style=long-iso | awk &#39;BEGIN &#123;    getline; getline;    name1=$8; size=$5;&#125;&#123;    name2=$8    if(size==$5)&#123;        &quot;md5sum &quot;name1 | getline; csum1=$1;        &quot;md5sum &quot;name2 | getline; csum2=$1;        if(csum1==csum2)&#123;            print name1;            print name2;        &#125;    &#125;    size=$5;    name1=name2;&#125;&#39; | sort -u &gt; duplicate_filescat duplicate_files | xargs -I &#123;&#125; md5sum &#123;&#125; | sort | uniq -w 32 | awk &#39;&#123;print &quot;^&quot;$2&quot;$&quot; &#125;&#39; | sort -u &gt; duplicate_sampleecho Removing...comm duplicate_files duplicate_sample -2 -3 | tee /dev/stderr | xargs rmrm -f duplicate_files duplicate_sampleecho Removed duplicates files successfully# 执行脚本# ./remove_duplicates.shRemoving...testfiletestfile1Removed duplicates files successfully# 如上testfile、testfile1、testfile2这三个相同内容的文件，只保留了testfile2.# 脚本原理说明：# ls -lS 将当前目录下的所有文件按照文件大小进行排序，并列出文件的详细信息# awk命令的执行步骤：awk首先会执行BEGIN&#123;&#125;语句块，处理完&#123;&#125;中所有的命令后，在执行END&#123;&#125;语句块# 在awk中，外部的命令的输出可以用这样的方式来读取，&quot;cmd&quot; | getline ，随后我们就可以用 $0 来获取命令的输出 ，在$1,$2,$3...$n 获取命令输出中的每一列# BEGIN&#123;&#125;语句块中有两个getline;是因为 ls -lS --time-style=long-iso 命令的输出的第一行是文件的数量，所以我们直接跳过，来获取下一行数据# comm 通常只接受排过序的文件。所以在之前需要使用 sort -u 进行排序# tee 命令在这有一个妙用：它将文件名在传递给rm命令的同时，也起到了print的效果。tee将来自stdin的行写入文件，同事将其发送到stdout</code></pre><p>18、解析文本中的电子邮件地址和URL</p><pre><code># 正则表达式#   mail：[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;#   URL： (http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;# wget www.sina.com.cn/index.html# 解析index.html中的email# egrep -o &quot;[a-zA-Z0-9.]+@[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,4&#125;&quot; index.htmljubao@vip.sina.comjubao@vip.sina.com# 解析index.html中的URL# egrep -o &quot;(http|https)://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;&quot; index.htmlhttp://www.sina.com.cnhttp://www.sina.com.cnhttp://auto.sina.com.cnhttp://www.sina.com.cn...http://hq.sinajs.cnhttp://rm.sina.com.cnhttp://d4.sina.com.cnhttp://d1.sina.com.cnhttp://i1.sinaimg.cnhttp://news.sina.com.cnhttp://login.sina.com.cnhttp://login.sina.com.cn</code></pre><p>19、以纯文本形式下载网页</p><pre><code>lynx:是一款基于命令行的web浏览器。我们可以利用它获取纯文本形式的网页命令：# lynx -dump http://www.sina.com.cn-dump 选项表示将网页内容以ASCII编码形式打印另，lynx会将页面中所有的超链接（&lt;a href=&quot;link&quot;&gt;）作为文本的页脚，单独放置在标题为 References 的文本区域。如果我们需要匹配除某个页面中所有的超链接也可以使用该方法，也省的我们用正则匹配</code></pre><p>20、列出网络上所有的活动主机</p><pre><code># cat ping.sh#!/bin/bashfor ip in 192.168.1.&#123;1..255&#125;;do    ping $ip -c 2 &amp;&gt; /dev/null;    if [ $? -eq 0 ]    then        echo $ip is alive    fidone# 并行ping# cat ping_1.sh#!/bin/bashfor ip in 192.168.1.&#123;1..255&#125;;do    (    ping $ip -c 2 &amp;&gt; /dev/null;    if [ $? -eq 0 ]    then        echo $ip is alive    fi    )&amp;donewait# 将wait放在脚本最后，它就会一直等到所有的子脚本进程全部结束</code></pre><p>21、网络上利用套接字进行快速文件复制</p><pre><code># 设置侦听套接字nc -l 1234# 在另一终端或主机中连接到该套接字nc 127.0.0.1 1234message_test# 连接到套接字后就可以在终端中输入信息回车就会发送# 文件复制在接收端执行以下命令：nc -l 1234 &gt; destination_filename在发送端执行下列命令：nc 127.0.0.1 1234 &lt; source_filename</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161030/bash.png&quot; alt=&quot;Linux中常用的shell脚本&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="shell" scheme="https://weizhimiao.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux中通过inotify-tools实现监控文件变化</title>
    <link href="https://weizhimiao.github.io/2016/10/29/Linux%E4%B8%AD%E9%80%9A%E8%BF%87inotify-tools%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96/"/>
    <id>https://weizhimiao.github.io/2016/10/29/Linux%E4%B8%AD%E9%80%9A%E8%BF%87inotify-tools%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96/</id>
    <published>2016-10-29T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。</p><p>那么什么inotify又是什么？</p><p>inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。</p><p>官方站点地址：<a href="http://inotify-tools.sourceforge.net/">http://inotify-tools.sourceforge.net/</a><br>Github地址：<a href="https://github.com/rvoicilas/inotify-tools">https://github.com/rvoicilas/inotify-tools</a></p><span id="more"></span><h2 id="inotify安装"><a href="#inotify安装" class="headerlink" title="inotify安装"></a>inotify安装</h2><h3 id="inotify支持检测"><a href="#inotify支持检测" class="headerlink" title="inotify支持检测"></a>inotify支持检测</h3><p>只有在内核 2.6.13 (June 18, 2005)以上的Linux版本中才支持inotify-tools。</p><p>查看当前系统是否支持inotify， 可用通过 uname -a 查看你的内核版本</p><pre><code>uname -aLinux localhost.localdomain 2.6.32-279.el6.i686 #1 SMP Fri Jun 22 10:59:55 UTC 2012 i686 i686 i386 GNU/Linux</code></pre><p>或</p><pre><code>cat /proc/versionLinux version 2.6.32-279.el6.i686 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.6 20120305 (Red Hat 4.4.6-4) (GCC) ) #1 SMP Fri Jun 22 10:59:55 UTC 2012</code></pre><p>或者查看<code>/proc/sys/fs/inotify/</code>，如果看到显示 max_queued_events max_user_instances max_user_watches 则说明支持inotify</p><pre><code>ls /proc/sys/fs/inotify/max_queued_events  max_user_instances  max_user_watches</code></pre><h3 id="inotify-tools安装"><a href="#inotify-tools安装" class="headerlink" title="inotify-tools安装"></a>inotify-tools安装</h3><pre><code>#wget --no-check-certificate https://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz#tar zxvf inotify-tools-3.14.tar.gz#cd inotify-tools-3.14#./configure#make#make install</code></pre><p>注：源码包安装需要编译，需要系统已经安装过C编译器</p><p>在系统下执行man inotify 、 man inotifywait、man inotifywatch即可得到相应的帮助信息，如果看到信息 则表示安装完成.</p><h2 id="inotify-tools使用"><a href="#inotify-tools使用" class="headerlink" title="inotify-tools使用"></a>inotify-tools使用</h2><h3 id="inotify-的默认内核参数详解"><a href="#inotify-的默认内核参数详解" class="headerlink" title="inotify 的默认内核参数详解"></a>inotify 的默认内核参数详解</h3><pre><code>/proc/sys/fs/inotify/max_queued_events    默认值: 16384    该文件中的值为调用inotify_init时分配给inotify instance中可排队的event的数目的最大值，超出这个值得事件被丢弃，但会触发IN_Q_OVERFLOW事件/proc/sys/fs/inotify/max_user_instances    默认值: 128    指定了每一个real user ID可创建的inotify instatnces的数量上限/proc/sys/fs/inotify/max_user_watches    默认值: 8192    指定了每个inotify instance相关联的watches的上限，也就是每一个inotify实例可监控的最大目录数。如果监控的文件数目巨大，需要根据实际情况适当增加此值得大小。注意:    max_queued_events 是 Inotify 管理的队列的最大长度，文件系统变化越频繁，这个值就应该越大！如果你在日志中看到Event Queue Overflow，说明max_queued_events太小需要调整参数后再次使用</code></pre><p>优化参数配置</p><pre><code>echo 104857600 &gt; /proc/sys/fs/inotify/max_user_watches</code></pre><p>inotify-tools 工具包中包含了两个命令</p><ul><li>inotifywait</li><li>inotifywatch</li></ul><h3 id="inotifywait"><a href="#inotifywait" class="headerlink" title="inotifywait"></a>inotifywait</h3><blockquote><p>inotifywait 仅执行阻塞，等待 inotify 事件，你可以使用它来监控任何一组文件和目录，或监控整个目录树（目录、子目录、子目录的子目录等等），并且可以结合 shell 脚本，更好的使用 inotifywait。</p></blockquote><p>命令格式：</p><pre><code>inotifywait [-hcmrq] [-e &lt;event&gt; ] [-t &lt;seconds&gt; ] [--format &lt;fmt&gt; ] [--timefmt &lt;fmt&gt; ] &lt;file&gt; [ ... ]</code></pre><p>选项参数：</p><pre><code>-h|--help         显示帮助信息@&lt;file&gt;           排除不需要监视的文件，可以是相对路径，也可以是绝对路径--exclude &lt;pattern&gt;                正则匹配需要排除的文件，大小写敏感--excludei &lt;pattern&gt;                正则匹配需要排除的文件，忽略大小写。-m|--monitor      接收到一个事情而不退出，无限期地执行。默认行为是接收到一个事情后立即退出-d|--daemon       跟--monitor一样，除了是在后台运行，需要指定--outfile把事情输出到一个文件。也意味着使用了--syslog-r|--recursive    监视一个目录下的所有子目录--fromfile &lt;file&gt;                从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头-o|--outfile &lt;file&gt;                输出事件到文件.-s|--syslog       输出错误信息到系统日志-q|--quiet        不输出详细信息，只输出事件-qq               除了致命错误，不会输出任何信息--timefmt &lt;fmt&gt;    指定时间格式，用于�format选项中的%T格式-c|--csv          输出csv格式。-t|--timeout &lt;seconds&gt;                设置超时时间，如果为0，则无限期地执行下去。-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]                指定监听的时间，如果省略，则侦听所有事件。--format &lt;fmt&gt;    指定输出格式     %w 表示发生事件的目录     %f 表示发生事件的文件     %e 表示发生的事件     %Xe 事件以“X”分隔     %T 使用由--timefmt定义的时间格式</code></pre><p>可监听的事件</p><pre><code>access            文件或者目录被读modify            文件或目录被写入attrib            文件或者目录属性被更改close_write      文件或目录关闭，在写模式下打开后close_nowrite    文件或目录关闭，在只读模式打开后close              文件或目录关闭，而不管是读/写模式open              文件或目录被打开moved_to        文件或者目录移动到监视目录moved_from      文件或者目录移出监视目录move              文件或目录移出或者移入目录create            文件或目录被创建在监视目录delete            文件或者目录被删除在监视目录delete_self      文件或目录移除，之后不再监听此文件或目录unmount            文件系统取消挂载，之后不再监听此文件系统</code></pre><p>示例1、监控<code>/data</code>目录</p><pre><code>inotifywait -rmq /data</code></pre><p>我们在另一个终端中想该目录中写入一个文件</p><pre><code>echo &quot;test&quot; &gt;&gt; /data/newfile</code></pre><p>这个时候我们就会在前一个终端中看到如下信息</p><pre><code># inotifywait -rmq /data/data/ CREATE newfile/data/ OPEN newfile/data/ MODIFY newfile/data/ CLOSE_WRITE,CLOSE newfile</code></pre><p>如上所示，我们监控的了对于newfile文件的 CREATE、OPEN、MODIFY、CLOSE_WRITE、CLOSE等事件。</p><p>示例2、实时监控对<code>/etc/passwd</code> 文件的修改、删除和权限相关时间，并且按照指定格式输出。</p><pre><code># inotifywait -mrq --timefmt &#39;%d/%m/%y %H:%M&#39; --format  &#39;%T %w%f %e&#39; --event modify,delete,attrib  /etc/passwd</code></pre><p>这是我们在另一终端创建一个新用户</p><pre><code># useradd testuser</code></pre><p>这时在前一个终端中就会监控到一个ATTRIB 事件</p><pre><code># inotifywait -mrq --timefmt &#39;%d/%m/%y %H:%M&#39; --format  &#39;%T %w%f %e&#39; --event modify,delete,attrib  /etc/passwd29/10/16 16:59 /etc/passwd ATTRIB</code></pre><p>示例3、实现对 /data/web 目录进行监控，监控文件删除，修改，创建和权限相关事件，并且要求将监控信息写入/var/log/web_watch.log。要求日志条目要清晰明了，能突显文件路径、事件名和时间。</p><pre><code># cat web_watch.sh#!/bin/bashinotifywait -mrq --timefmt &#39;%y/%m/%d %H:%M&#39; --format  &#39;%T %w%f %e&#39; --event delete,modify,create,attrib  /data/web | while read  date time file event  do      case $event in          MODIFY|CREATE|MOVE|MODIFY,ISDIR|CREATE,ISDIR|MODIFY,ISDIR)                  echo $event&#39;-&#39;$file&#39;-&#39;$date&#39;-&#39;$time &gt;&gt; /var/log/web_watch.log              ;;          MOVED_FROM|MOVED_FROM,ISDIR|DELETE|DELETE,ISDIR)                  echo $event&#39;-&#39;$file&#39;-&#39;$date&#39;-&#39;$time /var/log/web_watch.log              ;;      esac  done</code></pre><p>运行脚本后，在另一个终端操作后，查看<code>/var/log/web_watch.log</code>日志</p><pre><code># cat /var/log/web_watch.logCREATE-/data/web/a-14/06/27-16:21CREATE-/data/web/aa-14/06/27-16:21CREATE-/data/web/aaaa-14/06/27-16:24CREATE-/data/web/aaaaa-14/06/27-16:24</code></pre><p>更多的使用方式，请查看 inotifywatch man page</p><h3 id="inotifywatch"><a href="#inotifywatch" class="headerlink" title="inotifywatch"></a>inotifywatch</h3><blockquote><p>inotifywatch 用来收集关于被监视的文件系统的统计数据，包括每个 inotify 事件发生多少次。</p></blockquote><p>命令格式：</p><pre><code>inotifywatch  [-hvzrqf]  [-e  &lt;event&gt;  ] [-t &lt;seconds&gt; ] [-a &lt;event&gt; ] [-d &lt;event&gt; ] &lt;file&gt; [ ... ]</code></pre><p>选项参数：</p><pre><code>-h|--help                    显示帮助信息-v|--verbose                 详细信息@&lt;file&gt;                     排除不需要监视的文件，可以是相对路径，也可以是绝对路径--fromfile &lt;file&gt;         从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头--exclude &lt;pattern&gt;       正则匹配需要排除的文件，大小写敏感--excludei &lt;pattern&gt;      正则匹配需要排除的文件，忽略大小写。-z|--zero                 输出表格的行和列，即使元素为空-r|--recursive              监视一个目录下的所有子目录-t|--timeout &lt;seconds&gt;                          设置超时时间，如果为0，则无限期地执行下去。-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ]                          指定监听的时间，如果省略，则侦听所有事件。-a|--ascending &lt;event&gt;    以指定事件升序排列-d|--descending &lt;event&gt;   以指定事件降序排列</code></pre><p>示例1、统计/data目录所在文件系统发生的事件次数</p><pre><code>inotifywatch -v -e create,modify,delete -t 30 -r /data</code></pre><p>然后在另一终端中进行一些操作</p><pre><code># echo &quot;test&quot; &gt;&gt; /data/newfile1...# rm /data/newfilerm：是否删除普通文件 &quot;/data/newfile&quot;？y# rm /data/newfile1rm：是否删除普通文件 &quot;/data/newfile1&quot;？y</code></pre><p>30秒后，前一个终端会生成如下报告</p><pre><code># inotifywatch -v -e create,modify,delete -t 30 -r /dataEstablishing watches...Setting up watch(es) on /dataOK, /data is now being watched.Total of 1 watches.Finished establishing watches, now collecting statistics.Will listen for events for 30 seconds.total  modify  create  delete  filename11     8       1       2       /data/</code></pre><p>更多的使用方式，请查看 inotifywatch man page</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;inotify-tools 是一个用C语言库，一个为Linux提供简单inotify接口的命令行程序。这些程序可以用于监视文件系统事件并执行相应操作。这些程序是用C语言来写的，除了需要Linux内核的inotify支持外，没有其他的依赖。inotify-tools 3.14是目前最新版本，其于2010年3月7日发布。&lt;/p&gt;
&lt;p&gt;那么什么inotify又是什么？&lt;/p&gt;
&lt;p&gt;inotify，它是Linux在内核 2.6.13 (June 18, 2005)版本中引入的一个新功能，它为用户态监视文件系统的变化提供了强大的支持，允许监控程序打开一个独立文件描述符，并针对事件集监控一个或者多个文件，例如打开、关闭、移动/重命名、删除、创建或者改变属性。&lt;/p&gt;
&lt;p&gt;官方站点地址：&lt;a href=&quot;http://inotify-tools.sourceforge.net/&quot;&gt;http://inotify-tools.sourceforge.net/&lt;/a&gt;&lt;br&gt;Github地址：&lt;a href=&quot;https://github.com/rvoicilas/inotify-tools&quot;&gt;https://github.com/rvoicilas/inotify-tools&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="inotify" scheme="https://weizhimiao.github.io/tags/inotify/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中用instanceof运算符实现对象的安全创建</title>
    <link href="https://weizhimiao.github.io/2016/10/27/Javascript%E4%B8%AD%E7%94%A8instanceof%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%9B%E5%BB%BA/"/>
    <id>https://weizhimiao.github.io/2016/10/27/Javascript%E4%B8%AD%E7%94%A8instanceof%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%9B%E5%BB%BA/</id>
    <published>2016-10-27T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Book <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Book</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><h2 id="什么叫对象的安全创建"><a href="#什么叫对象的安全创建" class="headerlink" title="什么叫对象的安全创建"></a>什么叫对象的安全创建</h2><p>假设我们有以下一个类</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Book <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们用下面代码去实例化一个Book</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token function">Book</span><span class="token punctuation">(</span><span class="token string">'javascipt'</span><span class="token punctuation">,</span> <span class="token string">'2010'</span><span class="token punctuation">,</span> <span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们查看book对象时，会发现book对象 undefined</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么会出现这种情况呢？原因就是我们在实例化book对象没有用<code>new</code>关键词。我们再试一下</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token string">'javascipt'</span><span class="token punctuation">,</span> <span class="token string">'2010'</span><span class="token punctuation">,</span> <span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到 Book &amp;#123;title: "javascipt", time: "2010", type: "js"&amp;#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么又没有办法可以在我们没有用 <code>new</code> 关键词还能安全的创建对象，而不会出现 <code>undefined</code> 的情况。即，对象的安全创建。</p><h2 id="对象的安全创建的实现"><a href="#对象的安全创建的实现" class="headerlink" title="对象的安全创建的实现"></a>对象的安全创建的实现</h2><p>首先，我们会用到 javascript 中的 instanceof 运算符。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p>instanceof 用来检测某个对象是否是某个类的实例。</p></blockquote><p>示例1：判断 foo 是否是 Foo 类的实例</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例2：instanceof 在继承中关系中的用法(判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例)</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//JavaScript 原型继承</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Aoo</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tips: instanceof 用来检测某个对象是否是某个类的实例。</p><p>所以</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo <span class="token keyword">instanceof</span> <span class="token class-name">Aoo</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是<code>Foo.prototype</code> 继承了 <code>Aoo</code> ,所以</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Aoo</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>希望我们不要弄混~</strong></p><p>另，Javascript为我们提供的原生对象 Object，所有的对象都可以说成是Object的子类。</p><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance instanceif Object<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Book <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Book</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> time<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> time<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token function">Book</span><span class="token punctuation">(</span><span class="token string">'javascipt'</span><span class="token punctuation">,</span> <span class="token string">'2010'</span><span class="token punctuation">,</span> <span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到：Book &amp;#123;title: "javascipt", time: "2010", type: "js"&amp;#125;</span><span class="token keyword">var</span> book1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token string">'javascipt_1'</span><span class="token punctuation">,</span> <span class="token string">'2010'</span><span class="token punctuation">,</span> <span class="token string">'js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book1<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//得到：Book &amp;#123;title: "javascipt_1", time: "2010", type: "js"&amp;#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var Book = function(title, time, type)&amp;#123;
  if(this instanceof Book)&amp;#123;
    this.title = title;
    this.time = time;
    this.type = type;
  &amp;#125; else&amp;#123;
    return new Book(title, time, type);
  &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://weizhimiao.github.io/categories/JavaScript/"/>
    
    
    <category term="instanceof" scheme="https://weizhimiao.github.io/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>PHP根据文件头检测文件类型</title>
    <link href="https://weizhimiao.github.io/2016/10/23/PHP%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    <id>https://weizhimiao.github.io/2016/10/23/PHP%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A3%80%E6%B5%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</id>
    <published>2016-10-23T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。</p><span id="more"></span><p>php怎么样验证文件类型？先来看一个简单的方法：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">checkFileType</span><span class="token punctuation">(</span><span class="token variable">$fileName</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;  </span>       <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$fileName</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token variable">$bin</span> <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只读2字节  </span>       <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// C为无符号整数，网上搜到的都是c，为有符号整数，这样会产生负数判断不正常</span>       <span class="token variable">$strInfo</span>  <span class="token operator">=</span> @<span class="token function">unpack</span><span class="token punctuation">(</span><span class="token string">"C2chars"</span><span class="token punctuation">,</span> <span class="token variable">$bin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token variable">$typeCode</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$strInfo</span><span class="token punctuation">[</span><span class="token string">'chars1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token variable">$strInfo</span><span class="token punctuation">[</span><span class="token string">'chars2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token variable">$fileType</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>      <span class="token keyword">switch</span><span class="token punctuation">(</span> <span class="token variable">$typeCode</span> <span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">case</span> <span class="token string">'255216'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'jpg'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'7173'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'gif'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'13780'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'png'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'6677'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'bmp'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'7790'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'exe'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'7784'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'midi'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'8297'</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'rar'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token variable">$typeCode</span><span class="token punctuation">.</span> <span class="token string">' : '</span> <span class="token punctuation">.</span><span class="token string">'Unknown'</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//return $typeCode;</span>   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token variable">$file_name</span> <span class="token operator">=</span> <span class="token string">'11.doc'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">checkFileType</span><span class="token punctuation">(</span><span class="token variable">$file_name</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下来提供一个类的实现：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/*通过文件名，获得文件类型* *@author chengmo QQ:8292669* *@copyright &lt;a href="http://www.cnblogs.com/chengmo">http://www.cnblogs.com/chengmo&lt;/a> 2010-10-17 *@version 0.1 *$filename="d:/1.png";echo cFileTypeCheck::getFileType($filename); 打印：png */</span><span class="token keyword">class</span> <span class="token class-name">cFileTypeCheck</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$_TypeList</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$CheckClass</span><span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_TypeList</span><span class="token operator">=</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">/**     *处理文件类型映射关系表*     *     * @param string $filename 文件类型     * @return string 文件类型，没有找到返回：other     */</span>    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">_getFileType</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$filetype</span><span class="token operator">=</span><span class="token string">"other"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"no found file!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$file</span> <span class="token operator">=</span> @<span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$file</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"file refuse!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$bin</span> <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//只读15字节 各个不同文件类型，头信息不一样。</span>        <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$typelist</span><span class="token operator">=</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_TypeList</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$typelist</span> <span class="token keyword">as</span> <span class="token variable">$v</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$blen</span><span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token string">"H*"</span><span class="token punctuation">,</span><span class="token variable">$v</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//得到文件头标记字节数</span>            <span class="token variable">$tbin</span><span class="token operator">=</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$bin</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$blen</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">///需要比较文件头长度</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$v</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token string">"H*"</span><span class="token punctuation">,</span><span class="token variable">$tbin</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token keyword">return</span> <span class="token variable">$v</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">return</span> <span class="token variable">$filetype</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">/**     *得到文件头与文件类型映射表*     *     * @return array array(array('key',value)...)     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getTypeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">return</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"FFD8FFE1"</span><span class="token punctuation">,</span><span class="token string">"jpg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"89504E47"</span><span class="token punctuation">,</span><span class="token string">"png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"47494638"</span><span class="token punctuation">,</span><span class="token string">"gif"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"49492A00"</span><span class="token punctuation">,</span><span class="token string">"tif"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"424D"</span><span class="token punctuation">,</span><span class="token string">"bmp"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"41433130"</span><span class="token punctuation">,</span><span class="token string">"dwg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"38425053"</span><span class="token punctuation">,</span><span class="token string">"psd"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"7B5C727466"</span><span class="token punctuation">,</span><span class="token string">"rtf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"3C3F786D6C"</span><span class="token punctuation">,</span><span class="token string">"xml"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"68746D6C3E"</span><span class="token punctuation">,</span><span class="token string">"html"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"44656C69766572792D646174"</span><span class="token punctuation">,</span><span class="token string">"eml"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"CFAD12FEC5FD746F"</span><span class="token punctuation">,</span><span class="token string">"dbx"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"2142444E"</span><span class="token punctuation">,</span><span class="token string">"pst"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"D0CF11E0"</span><span class="token punctuation">,</span><span class="token string">"xls/doc"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"5374616E64617264204A"</span><span class="token punctuation">,</span><span class="token string">"mdb"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"FF575043"</span><span class="token punctuation">,</span><span class="token string">"wpd"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"252150532D41646F6265"</span><span class="token punctuation">,</span><span class="token string">"eps/ps"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"255044462D312E"</span><span class="token punctuation">,</span><span class="token string">"pdf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"E3828596"</span><span class="token punctuation">,</span><span class="token string">"pwl"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"504B0304"</span><span class="token punctuation">,</span><span class="token string">"zip"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"52617221"</span><span class="token punctuation">,</span><span class="token string">"rar"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"57415645"</span><span class="token punctuation">,</span><span class="token string">"wav"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"41564920"</span><span class="token punctuation">,</span><span class="token string">"avi"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"2E7261FD"</span><span class="token punctuation">,</span><span class="token string">"ram"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"2E524D46"</span><span class="token punctuation">,</span><span class="token string">"rm"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"000001BA"</span><span class="token punctuation">,</span><span class="token string">"mpg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"000001B3"</span><span class="token punctuation">,</span><span class="token string">"mpg"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"6D6F6F76"</span><span class="token punctuation">,</span><span class="token string">"mov"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"3026B2758E66CF11"</span><span class="token punctuation">,</span><span class="token string">"asf"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"4D546864"</span><span class="token punctuation">,</span><span class="token string">"mid"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFileType</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$CheckClass</span><span class="token punctuation">)</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$CheckClass</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">self</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$class</span><span class="token operator">=</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$CheckClass</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token variable">$class</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_getFileType</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token variable">$filename</span><span class="token operator">=</span><span class="token string">"22.jpg"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token string">"t"</span><span class="token punctuation">,</span>cFileTypeCheck<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFileType</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"rn"</span><span class="token punctuation">;</span><span class="token variable">$filename</span><span class="token operator">=</span><span class="token string">"11.doc"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token string">"t"</span><span class="token punctuation">,</span>cFileTypeCheck<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFileType</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"rn"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者可以这么检测：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">'22.jpg'</span><span class="token punctuation">;</span><span class="token variable">$extname</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span> <span class="token function">strrpos</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$extname</span><span class="token punctuation">.</span><span class="token string">'&lt;br />'</span><span class="token punctuation">;</span><span class="token variable">$file</span> <span class="token operator">=</span> @<span class="token function">fopen</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token variable">$str</span> <span class="token operator">=</span> @<span class="token function">fread</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token number">0x400</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读取前 1024 个字节</span>        <span class="token keyword">echo</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        @<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'MThd'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'mid'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'RIFF'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">==</span> <span class="token string">'wav'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'wav'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"/xFF/xD8/xFF"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'jpg'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'GIF8'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'gif'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span> <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"/x89/x50/x4E/x47/x0D/x0A/x1A/x0A"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'png'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'BM'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'bmp'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'CWS'</span> <span class="token operator">||</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'FWS'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'swf'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"/xD0/xCF/x11/xE0"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;   </span><span class="token comment" spellcheck="true">// D0CF11E == DOCFILE == Microsoft Office Document</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span><span class="token number">0x200</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"/xEC/xA5/xC1/x00"</span> <span class="token operator">||</span> <span class="token variable">$extname</span> <span class="token operator">==</span> <span class="token string">'doc'</span><span class="token punctuation">)</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'doc'</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>            <span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">,</span><span class="token number">0x200</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"/x09/x08"</span> <span class="token operator">||</span> <span class="token variable">$extname</span> <span class="token operator">==</span> <span class="token string">'xls'</span><span class="token punctuation">)</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'xls'</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str,0x200,4) == </span><span class="token string">"/xFD/xFF/xFF/xFF"</span> <span class="token operator">||</span> <span class="token variable">$extname</span> <span class="token operator">==</span> <span class="token string">'ppt'</span><span class="token punctuation">)</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'ppt'</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 4) == </span><span class="token string">"PK/x03/x04"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'zip'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 4) == </span><span class="token string">'Rar!'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'rar'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 4) == </span><span class="token string">"/x25PDF"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'pdf'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 3) == </span><span class="token string">"/x30/x82/x0A"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'cert'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 4) == </span><span class="token string">'ITSF'</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$extname</span> <span class="token operator">!=</span> <span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'chm'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif (substr($str ,0, 4) == </span><span class="token string">"/x2ERMF"</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'rm'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif ($extname == </span><span class="token string">'sql'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'sql'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; elseif ($extname == </span><span class="token string">'txt'</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$format</span> <span class="token operator">=</span> <span class="token string">'txt'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">echo</span> <span class="token variable">$format</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://www.nowamagic.net/librarys/veda/detail/836">转自：http://www.nowamagic.net/librarys/veda/detail/836</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件签名一般都在文件的头部，如果你用十六进制方式查看文件，你就可以看到文件的一些签名信息。如用uestudio以十六进制方式查看zip格式的文件，其文件内容头部有50 4B 03 04这样的十六进制信息。同理jpg文件状况有FF D8 FF E0 xx xx 4A 46这样的十六进制信息，其实这此十六进制都是表示一些特殊字条。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Xdebug之PHP脚本剖析</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8BPHP%E8%84%9A%E6%9C%AC%E5%89%96%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8BPHP%E8%84%9A%E6%9C%AC%E5%89%96%E6%9E%90/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug内置分析器允许您在脚本中找到瓶颈，并使用外部工具（如KCacheGrind或WinCacheGrind）可视化这些瓶颈。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Xdebug的Profiler是一个强大的工具，使您能够分析您的PHP代码并确定瓶颈，或者通常查看代码的哪些部分很慢，并可以使用速度提升。<br>Xdebug 2中的分析器以高速缓存磨削兼容文件的形式输出分析信息。这允许您使用优秀的KCacheGrind工具（Linux，KDE）来分析概要分析数据。</p><ul><li><p>如果你在Linux上，你可以安装KCacheGrind通过你最喜欢的包管理器。</p></li><li><p>如果你在Windows上，有预编译的QCacheGrind二进制文件可用。 （QCacheGrind是没有KDE绑定的KCacheGrind）。</p></li><li><p>如果你在Mac OSX上，还有如何构建QCacheGrind的说明。</p></li></ul><p>Windows的用户可以选择使用WinCacheGrind。该功能不同于KCacheGrind，因此在此页面上记录使用KCacheGrind的部分不适用于此程序。 WinCacheGrind目前不支持Xdebug 2.3引入的cachegrind文件的文件和函数压缩。</p><p>还有一个替代的配置文件信息呈现工具xdebugtoolkit，一个称为Webgrind的基于Web的前端，以及一个名为XCallGraph的基于Java的工具。</p><p>如果您不能使用KDE（或不想使用KDE），kcachegrind软件包也会附带一个perl脚本“ct_annotate”，该脚本从profiler跟踪文件生成ASCII输出。</p><h2 id="启动Profiler"><a href="#启动Profiler" class="headerlink" title="启动Profiler"></a>启动Profiler</h2><p>通过在php.ini中将xdebug.profiler_enable设置为1来启用分析。<br>这将指示Xdebug开始将分析信息写入使用xdebug.profiler_output_dir指令配置的转储目录。<br>生成的文件的名称始终以“cachegrind.out”开头。并以PHP（或Apache）进程的PID（进程ID）或包含最初调试的脚本的目录的crc32哈希结束。<br>请确保您的xdebug.profiler_output_dir中有足够的空间，因为分析器生成的信息量对于复杂脚本非常大，例如对于像eZ Publish这样的复杂应用程序，最多可以有500MB的空间。</p><p>您还可以选择性地启用分析器，将xdebug.profiler_enable_trigger设置为1.<br>如果设置为1，那么可以使用名为XDEBUG_PROFILE的GET / POST或COOKIE变量启用分析器。<br>可以用于启用调试器（请参阅HTTP调试会话）的FireFox 2扩展也可以与此设置一起使用。为了使触发器正常工作，xdebug.profiler_enable需要设置为0。</p><h2 id="分析Profiler"><a href="#分析Profiler" class="headerlink" title="分析Profiler"></a>分析Profiler</h2><p>生成配置文件信息文件后，可以使用 <a href="https://kcachegrind.github.io/">KCacheGrind</a> 打开它：</p><p><img data-src="https://xdebug.org/images/docs/kc-open.png" alt="img"></p><p>一旦打开文件，您就可以在KCacheGrind的不同窗格中获得大量信息。在左侧，找到“Flat Profile”窗格，其中显示了脚本中按照此函数中的时间花费及其所有子项排序的所​​有函数。第二列“Self”显示此函数（没有其子项）的时间花费，第三列“Called”显示特定函数的调用频率，最后一列“Function”显示函数的名称。 Xdebug通过用“php ::”作为前缀来更改内部PHP函数名称，并且包含文件也以特殊方式处理。调用include（和include_one，require和require_once）后跟“::”和包含文件的文件名。在左边的截图中你可以看到“include :: / home / httpd / ez_34 / v …”，内部PHP函数的例子是“php :: mysql_query”。前两列中的数字可以是脚本的完整运行时间的百分比（如在示例中）或绝对时间（1单位是1 / 1,000,000秒）。您可以使用右侧显示的按钮在两种模式之间切换。</p><p><img data-src="https://xdebug.org/images/docs/kc-profile.png" alt="img"></p><p>右侧的窗格包含上窗格和下窗格。 上面的图显示了有关称为当前所选函数的函数的信息（“eztemplatedesignresource-&gt; executecompiledtemplate”）。下面的窗格显示当前所选函数调用的函数的信息。</p><p><img data-src="https://xdebug.org/images/docs/kc-right-call.png" alt="img"></p><p>上方窗格中的“成本”列显示从列表中的函数调用时当前所选函数的时间花费。 添加的“费用”列中的数字将始终为100％。 下方窗格中的“成本”列显示从列表中调用函数所花费的时间。 在添加此列表中的数字时，您很可能永远不会达到100％，因为所选的函数本身也需要时间来执行。</p><p><img data-src="https://xdebug.org/images/docs/kc-right-callers.png" alt="img"></p><p>“所有呼叫者”和“所有呼叫”选项卡不仅显示从其调用该函数的直接调用，而且还显示所有直接调用的函数调用，还显示函数调用更多级别上下调用。 左侧屏幕截图中的上部窗格显示了所有调用当前所选函数的函数，直接和间接地使用堆栈上它们之间的其他函数。 “距离”列显示列出的和当前选择的函数调用之间有多少个函数调用（-1）。 如果两个函数之间有不同的距离，则显示为一个范围（例如“5-24”）。 括号中的数字是中值距离。 下面的窗格是类似的，除了它显示从当前选择的函数调用的函数的信息，再次是直接或间接。</p><h2 id="相关的设置"><a href="#相关的设置" class="headerlink" title="相关的设置"></a>相关的设置</h2><h3 id="xdebug-profiler-append"><a href="#xdebug-profiler-append" class="headerlink" title="xdebug.profiler_append"></a>xdebug.profiler_append</h3><p>类型：整数，默认值：0</p><p>当此设置设置为1时，当新请求映射到同一文件时（不在xdebug.profiler_output_name设置上），将不会覆盖分析器文件，而是使用新配置文件附加文件。</p><h3 id="xdebug-profiler-enable"><a href="#xdebug-profiler-enable" class="headerlink" title="xdebug.profiler_enable"></a>xdebug.profiler_enable</h3><p>类型：整数，默认值：0</p><p>启用Xdebug的概要分析器，它在概要文件输出目录中创建文件。这些文件可以由KCacheGrind读取以可视化您的数据。<br>无法使用ini_set（）在脚本中设置此设置。如果要选择性地启用分析器，请将xdebug.profiler_enable_trigger设置为1，而不使用此设置。</p><h3 id="xdebug-profiler-enable-trigger"><a href="#xdebug-profiler-enable-trigger" class="headerlink" title="xdebug.profiler_enable_trigger"></a>xdebug.profiler_enable_trigger</h3><p>类型：整数，默认值：0</p><p>当此设置设置为1时，可以使用XDEBUG_PROFILE GET / POST参数触发剖析器文件的生成，或者设置名为XDEBUG_PROFILE的cookie。<br>这将然后将分析器数据写入定义的目录。为了防止profiler为每个请求生成概要文件文件，您需要将xdebug.profiler_enable设置为0.对触发器本身的访问可以通过xdebug.profiler_enable_trigger_value配置。</p><h3 id="xdebug-profiler-enable-trigger-value"><a href="#xdebug-profiler-enable-trigger-value" class="headerlink" title="xdebug.profiler_enable_trigger_value"></a>xdebug.profiler_enable_trigger_value</h3><p>类型：字符串，默认值：“”，在Xdebug&gt; 2.3中引入</p><p>此设置可用于限制谁可以使用xdebug.profiler_enable_trigger中概述的XDEBUG_PROFILE功能。当从空字符串的默认值更改时，cookie，GET或POST参数的值需要使用此设置匹配共享机密集，<br>以便分析器启动。</p><h3 id="xdebug-profiler-output-dir"><a href="#xdebug-profiler-output-dir" class="headerlink" title="xdebug.profiler_output_dir"></a>xdebug.profiler_output_dir</h3><p>类型：字符串，默认值：/ tmp</p><p>将写入分析器输出的目录，确保PHP将运行的用户具有对该目录的写入权限。无法使用ini_set（）在脚本中设置此设置。</p><h3 id="xdebug-profiler-output-name"><a href="#xdebug-profiler-output-name" class="headerlink" title="xdebug.profiler_output_name"></a>xdebug.profiler_output_name</h3><p>类型：字符串，默认值：cachegrind.out。％p</p><p>此设置确定用于将跟踪转储到的文件的名称。设置使用格式说明符指定格式，非常类似于sprintf（）和strftime（）。有几个格式说明符可以用于格式化文件名。</p><p>有关受支持的说明符，请参见 <a href="https://xdebug.org/docs/all_settings#trace_output_name">xdebug.trace_output_name</a> 文档。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="string-xdebug-get-profiler-filename（）"><a href="#string-xdebug-get-profiler-filename（）" class="headerlink" title="string xdebug get profiler filename（）"></a>string xdebug get profiler filename（）</h3><p>返回配置文件信息文件名</p><p>返回用于将配置文件信息保存到的文件的名称。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Xdebug内置分析器允许您在脚本中找到瓶颈，并使用外部工具（如KCacheGrind或WinCacheGrind）可视化这些瓶颈。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之代码覆盖率分析</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%88%86%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E5%88%86%E6%9E%90/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>代码覆盖率告诉您在请求期间已执行了哪些行的脚本（或一组脚本）。 有了这些信息，你可以找出你的单元测试有多好。</p><span id="more"></span><h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><h3 id="xdebug-coverage-enable"><a href="#xdebug-coverage-enable" class="headerlink" title="xdebug.coverage_enable"></a>xdebug.coverage_enable</h3><p>类型：boolean，默认值：1，在Xdebug&gt; = 2.2中引入</p><p>如果此设置设置为0，则Xdebug不会设置内部结构以允许代码覆盖。 这加快了Xdebug相当有点，但当然，代码覆盖率分析将不工作。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="boolean-xdebug-code-coverage-started（）"><a href="#boolean-xdebug-code-coverage-started（）" class="headerlink" title="boolean xdebug_code_coverage_started（）"></a>boolean xdebug_code_coverage_started（）</h3><p>返回代码覆盖是否处于活动状态。</p><p>返回代码覆盖是否已开始。</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_code_coverage_started</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xdebug_start_code_coverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_code_coverage_started</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><pre><code>bool(false)bool(true)</code></pre><h3 id="array-xdebug-get-code-coverage（）"><a href="#array-xdebug-get-code-coverage（）" class="headerlink" title="array xdebug_get_code_coverage（）"></a>array xdebug_get_code_coverage（）</h3><p>返回代码覆盖率信息</p><p>返回一个结构，其中包含有关在脚本中执行哪些行（包括include文件）的信息。 以下示例显示了一个特定文件的代码覆盖率：</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token function">xdebug_start_code_coverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">echo</span> <span class="token variable">$a</span> <span class="token operator">*</span> <span class="token number">2.5</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token variable">$count</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$count</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token function">a</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">0.17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_get_code_coverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><pre><code>array  &#39;/home/httpd/html/test/xdebug/docs/xdebug_get_code_coverage.php&#39; =&gt;    array      5 =&gt; int 1      6 =&gt; int 1      7 =&gt; int 1      9 =&gt; int 1      10 =&gt; int 1      11 =&gt; int 1      12 =&gt; int 1      13 =&gt; int 1      15 =&gt; int 1      16 =&gt; int 1      18 =&gt; int 1</code></pre><h3 id="void-xdebug-start-code-coverage（-int-options-）"><a href="#void-xdebug-start-code-coverage（-int-options-）" class="headerlink" title="void xdebug_start_code_coverage（[int options]）"></a>void xdebug_start_code_coverage（[int options]）</h3><p>开始代码覆盖</p><p>此函数开始收集代码覆盖的信息。 收集的信息包括一个二维数组，其主要索引为执行的文件名，辅助键为行号。 元素中的值表示行是否已执行或它是否具有不可达行。</p><p>每行的返回值为：</p><ul><li><p>1：这行被执行</p></li><li><p>-1：此行未执行</p></li><li><p>-2：这行没有可执行代码就可以了</p></li></ul><p>值-1仅在启用XDEBUG_CC_UNUSED时返回，并且仅当启用了XDEBUG_CC_UNUSED和XDEBUG_CC_DEAD_CODE时才返回值-2。</p><p>此函数有两个选项，用作位字段：</p><ul><li><p>XDEBUG_CC_UNUSED</p><blockquote><p>启用代码扫描，以确定哪行有可执行代码。 如果没有这个选项，返回的数组将只包含实际执行的行。</p></blockquote></li><li><p>XDEBUG_CC_DEAD_CODE</p><blockquote><p>启用分支分析以确定是否可以执行代码。<br>启用这些选项会使代码覆盖率显着降低。<br>您可以使用以下示例中所示的选项。</p></blockquote></li></ul><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">xdebug_start_code_coverage</span><span class="token punctuation">(</span> <span class="token constant">XDEBUG_CC_UNUSED</span> <span class="token operator">|</span> <span class="token constant">XDEBUG_CC_DEAD_CODE</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="void-xdebug-stop-code-coverage（-int-cleanup-true-）"><a href="#void-xdebug-stop-code-coverage（-int-cleanup-true-）" class="headerlink" title="void xdebug_stop_code_coverage（[int cleanup = true]）"></a>void xdebug_stop_code_coverage（[int cleanup = true]）</h3><p>停止代码覆盖</p><p>此功能停止收集信息，内存中的信息将被销毁。 如果传递“false”作为参数，那么代码覆盖率信息不会被销毁，因此您可以再次使用xdebug_start_code_coverage（）函数恢复信息收集。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码覆盖率告诉您在请求期间已执行了哪些行的脚本（或一组脚本）。 有了这些信息，你可以找出你的单元测试有多好。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之函数轨迹跟踪</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%87%BD%E6%95%B0%E8%BD%A8%E8%BF%B9%E8%B7%9F%E8%B8%AA/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%87%BD%E6%95%B0%E8%BD%A8%E8%BF%B9%E8%B7%9F%E8%B8%AA/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug允许您记录所有函数调用，包括参数和返回值到不同格式的文件。</p><p>那些所谓的“函数跟踪”可以帮助当你是新的一个应用程序，或当你试图找出当你的应用程序运行时究竟是怎么回事。<br>函数跟踪还可以选择显示传递给函数和方法的变量的值，以及返回值。 在默认跟踪中，这两个元素不可用。</p><span id="more"></span><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>有三种输出格式。 一个是作为一个人类可读的跟踪，另一个更适合计算机程序，因为它更容易解析，最后一个使用HTML格式化跟踪。 您可以使用xdebug.trace_format设置在两种不同的格式之间切换。 有一些设置控制哪些信息写入跟踪文件。 有一些设置包括变量（xdebug.collect_params）和包括返回值（xdebug.collect_return）例如。 下面的示例显示了不同设置对人类可读功能轨迹的影响。</p><p>脚本</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$str</span> <span class="token operator">=</span> <span class="token string">"Xdebug"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">ret_ord</span><span class="token punctuation">(</span> <span class="token variable">$c</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">return</span> <span class="token function">ord</span><span class="token punctuation">(</span> <span class="token variable">$c</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span> <span class="token function">str_split</span><span class="token punctuation">(</span> <span class="token variable">$str</span> <span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$char</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">echo</span> <span class="token variable">$char</span><span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> <span class="token function">ret_ord</span><span class="token punctuation">(</span> <span class="token variable">$char</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p>以下是使用xdebug.collect_params设置的不同设置的结果。 因为这不是一个Web环境,值2没有任何意义，因为工具提示不工作在文本文件。</p><ul><li><p>default</p><pre><code>TRACE START [2007-05-06 14:37:06]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split() ../trace.php:8  0.0153     117424     -&gt; ret_ord() ../trace.php:10  0.0165     117584       -&gt; ord() ../trace.php:5  0.0166     117584     -&gt; ret_ord() ../trace.php:10  0.0167     117584       -&gt; ord() ../trace.php:5  0.0168     117584     -&gt; ret_ord() ../trace.php:10  0.0168     117584       -&gt; ord() ../trace.php:5  0.0170     117584     -&gt; ret_ord() ../trace.php:10  0.0170     117584       -&gt; ord() ../trace.php:5  0.0172     117584     -&gt; ret_ord() ../trace.php:10  0.0172     117584       -&gt; ord() ../trace.php:5  0.0173     117584     -&gt; ret_ord() ../trace.php:10  0.0174     117584       -&gt; ord() ../trace.php:5  0.0177      41152TRACE END   [2007-05-06 14:37:07]</code></pre></li><li><p>collect_params=1</p><pre><code>TRACE START [2007-05-06 14:37:11]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split(string(6)) ../trace.php:8  0.0007     117424     -&gt; ret_ord(string(1)) ../trace.php:10  0.0007     117584       -&gt; ord(string(1)) ../trace.php:5  0.0009     117584     -&gt; ret_ord(string(1)) ../trace.php:10  0.0009     117584       -&gt; ord(string(1)) ../trace.php:5  0.0010     117584     -&gt; ret_ord(string(1)) ../trace.php:10  0.0011     117584       -&gt; ord(string(1)) ../trace.php:5  0.0012     117584     -&gt; ret_ord(string(1)) ../trace.php:10  0.0013     117584       -&gt; ord(string(1)) ../trace.php:5  0.0014     117584     -&gt; ret_ord(string(1)) ../trace.php:10  0.0014     117584       -&gt; ord(string(1)) ../trace.php:5  0.0016     117584     -&gt; ret_ord(string(1)) ../trace.php:10  0.0016     117584       -&gt; ord(string(1)) ../trace.php:5  0.0019      41152TRACE END   [2007-05-06 14:37:11]</code></pre></li><li><p>collect_params=3</p><pre><code>TRACE START [2007-05-06 14:37:13]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split(&#39;Xdebug&#39;) ../trace.php:8  0.0007     117424     -&gt; ret_ord(&#39;X&#39;) ../trace.php:10  0.0007     117584       -&gt; ord(&#39;X&#39;) ../trace.php:5  0.0009     117584     -&gt; ret_ord(&#39;d&#39;) ../trace.php:10  0.0009     117584       -&gt; ord(&#39;d&#39;) ../trace.php:5  0.0010     117584     -&gt; ret_ord(&#39;e&#39;) ../trace.php:10  0.0011     117584       -&gt; ord(&#39;e&#39;) ../trace.php:5  0.0012     117584     -&gt; ret_ord(&#39;b&#39;) ../trace.php:10  0.0013     117584       -&gt; ord(&#39;b&#39;) ../trace.php:5  0.0014     117584     -&gt; ret_ord(&#39;u&#39;) ../trace.php:10  0.0014     117584       -&gt; ord(&#39;u&#39;) ../trace.php:5  0.0016     117584     -&gt; ret_ord(&#39;g&#39;) ../trace.php:10  0.0016     117584       -&gt; ord(&#39;g&#39;) ../trace.php:5  0.0019      41152TRACE END   [2007-05-06 14:37:13]</code></pre></li><li><p>collect_params=4</p><pre><code>TRACE START [2007-05-06 14:37:16]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split(&#39;Xdebug&#39;) ../trace.php:8  0.0007     117424     -&gt; ret_ord($c = &#39;X&#39;) ../trace.php:10  0.0007     117584       -&gt; ord(&#39;X&#39;) ../trace.php:5  0.0009     117584     -&gt; ret_ord($c = &#39;d&#39;) ../trace.php:10  0.0009     117584       -&gt; ord(&#39;d&#39;) ../trace.php:5  0.0010     117584     -&gt; ret_ord($c = &#39;e&#39;) ../trace.php:10  0.0011     117584       -&gt; ord(&#39;e&#39;) ../trace.php:5  0.0012     117584     -&gt; ret_ord($c = &#39;b&#39;) ../trace.php:10  0.0013     117584       -&gt; ord(&#39;b&#39;) ../trace.php:5  0.0014     117584     -&gt; ret_ord($c = &#39;u&#39;) ../trace.php:10  0.0014     117584       -&gt; ord(&#39;u&#39;) ../trace.php:5  0.0016     117584     -&gt; ret_ord($c = &#39;g&#39;) ../trace.php:10  0.0016     117584       -&gt; ord(&#39;g&#39;) ../trace.php:5  0.0019      41152TRACE END   [2007-05-06 14:37:16]</code></pre></li></ul><p>除了xdebug.collect_params设置，还有另一些影响跟踪文件输出的设置。<br>第一个选项卡“默认”显示与上面的默认值相同。<br>第二个选项卡“show_mem_delta = 1”还显示输出文件中两个不同行之间的内存使用差异。</p><p>在“collect return = 1”选项卡上，所有函数调用的返回值也是可见的。 这使用xdebug.collect返回设置打开。</p><p>名为“collect assignments = 1”的选项卡显示可变分配，可以使用xdebug.collect分配设置打开。</p><p>最后一个选项卡显示不同的输出格式，更容易解析，但更难阅读。<br>因此，如果有一个额外的工具来解释跟踪文件，xdebug.trace_format设置是非常有用的。</p><ul><li><p>default</p><pre><code>TRACE START [2007-05-06 14:37:06]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split() ../trace.php:8  0.0153     117424     -&gt; ret_ord() ../trace.php:10  0.0165     117584       -&gt; ord() ../trace.php:5  0.0166     117584     -&gt; ret_ord() ../trace.php:10  0.0167     117584       -&gt; ord() ../trace.php:5  0.0168     117584     -&gt; ret_ord() ../trace.php:10  0.0168     117584       -&gt; ord() ../trace.php:5  0.0170     117584     -&gt; ret_ord() ../trace.php:10  0.0170     117584       -&gt; ord() ../trace.php:5  0.0172     117584     -&gt; ret_ord() ../trace.php:10  0.0172     117584       -&gt; ord() ../trace.php:5  0.0173     117584     -&gt; ret_ord() ../trace.php:10  0.0174     117584       -&gt; ord() ../trace.php:5  0.0177      41152TRACE END   [2007-05-06 14:37:07]</code></pre></li><li><p>show_mem_delta=1</p><pre><code>TRACE START [2007-05-06 14:37:26]  0.0003     114112  +114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     +160     -&gt; str_split(&#39;Xdebug&#39;) ../trace.php:8  0.0007     117424    +3152     -&gt; ret_ord($c = &#39;X&#39;) ../trace.php:10  0.0007     117584     +160       -&gt; ord(&#39;X&#39;) ../trace.php:5  0.0009     117584       +0     -&gt; ret_ord($c = &#39;d&#39;) ../trace.php:10  0.0009     117584       +0       -&gt; ord(&#39;d&#39;) ../trace.php:5  0.0011     117584       +0     -&gt; ret_ord($c = &#39;e&#39;) ../trace.php:10  0.0011     117584       +0       -&gt; ord(&#39;e&#39;) ../trace.php:5  0.0013     117584       +0     -&gt; ret_ord($c = &#39;b&#39;) ../trace.php:10  0.0013     117584       +0       -&gt; ord(&#39;b&#39;) ../trace.php:5  0.0014     117584       +0     -&gt; ret_ord($c = &#39;u&#39;) ../trace.php:10  0.0015     117584       +0       -&gt; ord(&#39;u&#39;) ../trace.php:5  0.0016     117584       +0     -&gt; ret_ord($c = &#39;g&#39;) ../trace.php:10  0.0017     117584       +0       -&gt; ord(&#39;g&#39;) ../trace.php:5  0.0019      41152TRACE END   [2007-05-06 14:37:26]</code></pre></li><li><p>collect_return=1</p><pre><code>TRACE START [2007-05-06 14:37:35]  0.0003     114112   -&gt; &#123;main&#125;() ../trace.php:0  0.0004     114272     -&gt; str_split(&#39;Xdebug&#39;) ../trace.php:8                        &gt;=&gt; array (0 =&gt; &#39;X&#39;, 1 =&gt; &#39;d&#39;, 2 =&gt; &#39;e&#39;, 3 =&gt; &#39;b&#39;, 4 =&gt; &#39;u&#39;, 5 =&gt; &#39;g&#39;)  0.0007     117424     -&gt; ret_ord($c = &#39;X&#39;) ../trace.php:10  0.0007     117584       -&gt; ord(&#39;X&#39;) ../trace.php:5                          &gt;=&gt; 88                        &gt;=&gt; 88  0.0009     117584     -&gt; ret_ord($c = &#39;d&#39;) ../trace.php:10  0.0009     117584       -&gt; ord(&#39;d&#39;) ../trace.php:5                          &gt;=&gt; 100                        &gt;=&gt; 100  0.0011     117584     -&gt; ret_ord($c = &#39;e&#39;) ../trace.php:10  0.0011     117584       -&gt; ord(&#39;e&#39;) ../trace.php:5                          &gt;=&gt; 101                        &gt;=&gt; 101  0.0013     117584     -&gt; ret_ord($c = &#39;b&#39;) ../trace.php:10  0.0013     117584       -&gt; ord(&#39;b&#39;) ../trace.php:5                          &gt;=&gt; 98                        &gt;=&gt; 98  0.0015     117584     -&gt; ret_ord($c = &#39;u&#39;) ../trace.php:10  0.0016     117584       -&gt; ord(&#39;u&#39;) ../trace.php:5                          &gt;=&gt; 117                        &gt;=&gt; 117  0.0017     117584     -&gt; ret_ord($c = &#39;g&#39;) ../trace.php:10  0.0018     117584       -&gt; ord(&#39;g&#39;) ../trace.php:5                          &gt;=&gt; 103                        &gt;=&gt; 103                      &gt;=&gt; 1  0.0021      41152TRACE END   [2007-05-06 14:37:35]</code></pre></li><li><p>trace_format=1</p><pre><code>Version: 2.0.0RC4-devTRACE START [2007-05-06 18:29:01]1    0    0    0.010870    114112    &#123;main&#125;    1    ../trace.php    02    1    0    0.032009    114272    str_split    0    ../trace.php    82    1    1    0.032073    1166322    2    0    0.033505    117424    ret_ord    1    ../trace.php    103    3    0    0.033531    117584    ord    0    ../trace.php    53    3    1    0.033551    1175842    2    1    0.033567    1175842    4    0    0.033718    117584    ret_ord    1    ../trace.php    103    5    0    0.033740    117584    ord    0    ../trace.php    53    5    1    0.033758    1175842    4    1    0.033770    1175842    6    0    0.033914    117584    ret_ord    1    ../trace.php    103    7    0    0.033936    117584    ord    0    ../trace.php    53    7    1    0.033953    1175842    6    1    0.033965    1175842    8    0    0.034108    117584    ret_ord    1    ../trace.php    103    9    0    0.034130    117584    ord    0    ../trace.php    53    9    1    0.034147    1175842    8    1    0.034160    1175842    10    0    0.034302    117584    ret_ord    1    ../trace.php    103    11    0    0.034325    117584    ord    0    ../trace.php    53    11    1    0.034342    1175842    10    1    0.034354    1175842    12    0    0.034497    117584    ret_ord    1    ../trace.php    103    13    0    0.034519    117584    ord    0    ../trace.php    53    13    1    0.034536    1175842    12    1    0.034549    1175841    0    1    0.034636    117584TRACE END   [2007-05-06 18:29:01]</code></pre></li></ul><p><strong>VIM语法文件</strong></p><p>Xdebug附带了语法高亮显示跟踪文件的VIM语法文件：xt.vim。<br>为了使VIM能够识别这种新格式，您需要执行以下步骤：</p><ol><li>复制 xt.vim 文件到 ~/.vim/syntax</li><li>修改, 或者创建, ~/.vim/filetype.vim 并添加下列内容<pre><code>augroup filetypedetectau BufNewFile,BufRead *.xt  setf xtaugroup END</code></pre></li></ol><p>使用这些设置，打开的跟踪文件看起来像：</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-10@2x.png" alt="img"></p><h2 id="相关的设置"><a href="#相关的设置" class="headerlink" title="相关的设置"></a>相关的设置</h2><h3 id="xdebug-auto-trace"><a href="#xdebug-auto-trace" class="headerlink" title="xdebug.auto_trace"></a><strong>xdebug.auto_trace</strong></h3><p>类型：布尔值，默认值：0</p><p>当此设置设置为on时，将在脚本运行之前启用函数调用的跟踪。这使得可以跟踪auto_prepend_file中的代码。</p><h3 id="xdebug-collect-assignments"><a href="#xdebug-collect-assignments" class="headerlink" title="xdebug.collect_assignments"></a><strong>xdebug.collect_assignments</strong></h3><p>类型：boolean，默认值：0，在Xdebug&gt; 2.1中引入</p><p>此设置（默认为0）控制Xdebug是否应向函数轨迹添加变量分配。</p><h3 id="xdebug-collect-includes"><a href="#xdebug-collect-includes" class="headerlink" title="xdebug.collect_includes"></a><strong>xdebug.collect_includes</strong></h3><p>类型：布尔值，默认值：1</p><p>此设置默认为1，控制Xdebug是否应将include（），include_once（），require（）或require_once（）中使用的文件名写入跟踪文件。</p><h3 id="xdebug-collect-params"><a href="#xdebug-collect-params" class="headerlink" title="xdebug.collect_params"></a><strong>xdebug.collect_params</strong></h3><p>类型：整数，默认值：0</p><p>此设置默认为0，控制在函数跟踪或堆栈跟踪中记录函数调用时，Xdebug是否应收集传递给函数的参数。</p><p>该设置默认为0，因为对于非常大的脚本，它可能使用大量的内存，因此使巨量脚本无法运行。您可以最安全地打开此设置，但是您可以预期在具有大量函数调用和/或巨大的数据结构作为参数的脚本中存在一些问题。 Xdebug 2不会有增加的内存使用这个问题，因为它永远不会将此信息存储在内存中。相反，它将只被写入磁盘。这意味着您需要查看磁盘使用情况。</p><p>此设置可以有四个不同的值。对于每个值，示出了不同量的信息。下面你将看到每个值提供什么信息。另请参见功能堆栈跟踪的几个截图的介绍。</p><table><thead><tr><th>显示的值</th><th>参数信息</th></tr></thead><tbody><tr><td>0</td><td>无。</td></tr><tr><td>1</td><td>元素的类型和数量（f.e. string（6），array（8））。</td></tr><tr><td>2</td><td>元素的类型和数量，带有完整信息的工具提示1。1在CLI版本的PHP中，它不会有工具提示，也不会在输出文件中。</td></tr><tr><td>3</td><td>完全变量内容（具有由xdebug.var_display_max_children，xdebug.var_display_max_data和xdebug.var_display_max_depth设置的限制）。</td></tr><tr><td>4</td><td>完全变量内容和变量名。</td></tr><tr><td>5</td><td>PHP序列化变量内容，没有名称。 （Xdebug 2.3中的新功能）</td></tr></tbody></table><h3 id="xdebug-collect-return"><a href="#xdebug-collect-return" class="headerlink" title="xdebug.collect_return"></a><strong>xdebug.collect_return</strong></h3><p>类型：布尔值，默认值：0</p><p>此设置默认为0，控制Xdebug是否应将函数调用的返回值写入跟踪文件。</p><p>对于计算机化的跟踪文件（xdebug.trace_format = 1），这只能从Xdebug 2.3起。</p><h3 id="xdebug-show-mem-delta"><a href="#xdebug-show-mem-delta" class="headerlink" title="xdebug.show_mem_delta"></a><strong>xdebug.show_mem_delta</strong></h3><p>类型：整数，默认值：0</p><p>当这个设置设置为某些！= 0 Xdebug的人类可读的生成的跟踪文件将显示在函数调用之间的内存使用的差异。如果Xdebug配置为生成计算机可读的跟踪文件，则它们将始终显示此信息。</p><h3 id="xdebug-trace-enable-trigger"><a href="#xdebug-trace-enable-trigger" class="headerlink" title="xdebug.trace_enable_trigger"></a><strong>xdebug.trace_enable_trigger</strong></h3><p>类型：boolean，默认值：0，在Xdebug&gt; 2.2中引入</p><p>当此设置设置为1时，可以使用XDEBUG_TRACE GET / POST参数触发跟踪文件的生成，或者设置名为XDEBUG_TRACE的cookie。然后将跟踪数据写入定义的目录。为了防止Xdebug为每个请求生成跟踪文件，您需要将xdebug.auto_trace设置为0.对触发器本身的访问可以通过xdebug.trace_enable_trigger_value配置。</p><h3 id="xdebug-trace-enable-trigger-value"><a href="#xdebug-trace-enable-trigger-value" class="headerlink" title="xdebug.trace_enable_trigger_value"></a><strong>xdebug.trace_enable_trigger_value</strong></h3><p>类型：字符串，默认值：“”，在Xdebug&gt; 2.3中引入</p><p>此设置可用于限制谁可以使用xdebug.trace_enable_trigger中概述的XDEBUG_TRACE功能。当从空字符串的默认值更改时，cookie，GET或POST参数的值需要使用此设置匹配共享机密集，以便生成跟踪文件。</p><h3 id="xdebug-trace-format"><a href="#xdebug-trace-format" class="headerlink" title="xdebug.trace_format"></a><strong>xdebug.trace_format</strong></h3><p>类型：整数，默认值：0</p><p>跟踪文件的格式。</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>显示一个人工可读的缩进跟踪文件，具有：时间索引，内存使用，内存增量（如果设置xdebug.show_mem_delta启用），级别，函数名称，函数参数（如果设置xdebug.collect_params启用），文件名和行 数。</td></tr><tr><td>1</td><td>写入具有两个不同记录的计算机可读格式。 有不同的记录用于输入堆栈帧，并留下堆栈帧。 下表列出了每种记录类型中的字段。 字段是制表符分隔的。</td></tr><tr><td>2</td><td>写入以（简单）HTML格式化的跟踪。</td></tr></tbody></table><h3 id="xdebug-trace-options"><a href="#xdebug-trace-options" class="headerlink" title="xdebug.trace_options"></a><strong>xdebug.trace_options</strong></h3><p>类型：整数，默认值：0</p><p>当设置为’1’时，跟踪文件将被附加到，而不是在后续请求中被覆盖。</p><h3 id="xdebug-trace-output-dir"><a href="#xdebug-trace-output-dir" class="headerlink" title="xdebug.trace_output_dir"></a><strong>xdebug.trace_output_dir</strong></h3><p>类型：字符串，默认值：/ tmp</p><p>将写入跟踪文件的目录，确保PHP将运行的用户具有对该目录的写入权限。</p><h3 id="xdebug-trace-output-name"><a href="#xdebug-trace-output-name" class="headerlink" title="xdebug.trace_output_name"></a><strong>xdebug.trace_output_name</strong></h3><p>类型：字符串，默认值：trace。％c</p><p>此设置确定用于将跟踪转储到的文件的名称。 设置使用格式说明符指定格式，非常类似于sprintf（）和strftime（）。 有几个格式说明符可以用于格式化文件名。 “.xt”扩展名总是自动添加。</p><p>可能的格式说明符是：</p><table><thead><tr><th>指定符</th><th>含义</th><th>示例格式</th><th>示例文件名</th></tr></thead><tbody><tr><td>%c</td><td>crc32 of the current working directory</td><td>trace.%c</td><td>trace.1258863198.xt</td></tr><tr><td>%p</td><td>pid</td><td>trace.%p</td><td>trace.5174.xt</td></tr><tr><td>%r</td><td>random number</td><td>trace.%r</td><td>trace.072db0.xt</td></tr><tr><td>%s</td><td>script name 这一个不可用于跟踪文件名。</td><td>cachegrind.out.%s</td><td>cachegrind.out._home_httpd_html_test_xdebug_test_php</td></tr><tr><td>%t</td><td>timestamp (seconds)</td><td>trace.%t</td><td>trace.1179434742.xt</td></tr><tr><td>%u</td><td>timestamp (microseconds)</td><td>trace.%u</td><td>trace.1179434749_642382.xt</td></tr><tr><td>%H</td><td>$_SERVER[‘HTTP_HOST’]</td><td>trace.%H</td><td>trace.kossu.xt</td></tr><tr><td>%R</td><td>$_SERVER[‘REQUEST_URI’]</td><td>trace.%R</td><td>trace._test_xdebug_test_php_var=1_var2=2.xt</td></tr><tr><td>%U</td><td>$_SERVER[‘UNIQUE_ID’] 版本2.2中的新功能。 这个由Apache mod_unique_id模块设置</td><td>trace.%U</td><td>trace.TRX4n38AAAEAAB9gBFkAAAAB.xt</td></tr><tr><td>%S</td><td>session_id (from $_COOKIE if set)</td><td>trace.%S</td><td>trace.c70c1ec2375af58f74b390bbdd2a679d.xt</td></tr><tr><td>%%</td><td>literal %</td><td>trace.%%</td><td>trace.%%.xt</td></tr></tbody></table><h3 id="xdebug-var-display-max-children"><a href="#xdebug-var-display-max-children" class="headerlink" title="xdebug.var_display_max_children"></a><strong>xdebug.var_display_max_children</strong></h3><p>类型：整数，默认值：128</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的数组子元素和对象的属性的数量。</p><p>要禁用任何限制，请使用-1作为值。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-data"><a href="#xdebug-var-display-max-data" class="headerlink" title="xdebug.var_display_max_data"></a><strong>xdebug.var_display_max_data</strong></h3><p>类型：整数，默认值：512</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的最大字符串长度。</p><p>要禁用任何限制，请使用-1作为值。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-depth"><a href="#xdebug-var-display-max-depth" class="headerlink" title="xdebug.var_display_max_depth"></a><strong>xdebug.var_display_max_depth</strong></h3><p>类型：整数，默认值：3</p><p>当使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时，控制数组元素和对象属性的嵌套级别数。</p><p>您可以选择的最大值为1023.您还可以使用-1作为值来选择此最大数。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="string-xdebug-get-tracefile-name（）"><a href="#string-xdebug-get-tracefile-name（）" class="headerlink" title="string xdebug_get_tracefile_name（）"></a><strong>string xdebug_get_tracefile_name（）</strong></h3><p>返回函数跟踪文件的名称</p><p>返回用于跟踪此脚本的输出的文件的名称。这在启用xdebug.auto_trace时非常有用。</p><h3 id="string-xdebug-start-trace（-string-trace-file-，integer-options-）"><a href="#string-xdebug-start-trace（-string-trace-file-，integer-options-）" class="headerlink" title="string xdebug_start_trace（[string trace_file [，integer options]]）"></a><strong>string xdebug_start_trace（[string trace_file [，integer options]]）</strong></h3><p>启动新的函数跟踪</p><p>启动跟踪从此点到trace_file参数中的文件的函数调用。如果未指定文件名，则跟踪文件将放置在由xdebug.trace_output_dir设置配置的目录中。</p><p>如果文件名称作为第一个参数，则名称相对于当前工作目录。此当前工作目录可能与您预期的不同，因此，如果指定文件名，请使用绝对路径。使用PHP函数getcwd（）来找出当前工作目录是什么。</p><p>跟踪文件的名称为“{trace_file} .xt”。如果启用了xdebug.auto_trace，则文件名的格式为“{filename} .xt”，其中“{filename}”部分取决于xdebug.trace_output_name设置。 options参数是一个位域;目前有三个选项：</p><ul><li><p>XDEBUG_TRACE_APPEND（1）</p><blockquote><p>使追踪文件在追加模式而不是覆盖模式下打开</p></blockquote></li><li><p>XDEBUG_TRACE_COMPUTERIZED（2）</p><blockquote><p>创建具有1“xdebug.trace_format”下描述的格式的跟踪文件。</p></blockquote></li><li><p>XDEBUG_TRACE_HTML（4）</p><blockquote><p>将跟踪文件创建为HTML表</p></blockquote></li><li><p>XDEBUG_TRACE_NAKED_FILENAME（8）</p><blockquote><p>通常，Xdebug总是将“.xt”添加到文件名的末尾，该文件名作为第一个参数传递给此函数。 如果设置了XDEBUG_TRACE_NAKED_FILENAME标志，则不会添加“.xt”。 （Xdebug 2.3中的新功能）。</p></blockquote></li></ul><p>与Xdebug 1不同，Xdebug 2不会在内存中存储函数调用，但始终只写入磁盘以减轻对已用内存的压力。 设置xdebug.collect_includes，xdebug.collect_params和xdebug.collect_return影响什么信息记录到跟踪文件，设置xdebug.trace_format影响跟踪文件的格式。<br>从此函数返回Xdebug跟踪的完整路径和文件名。 这将是您传入的文件名（可能添加了“.xt”），或者如果没有传入文件名，则为自动生成的文件名。</p><h3 id="string-xdebug-start-trace（）"><a href="#string-xdebug-start-trace（）" class="headerlink" title="string xdebug_start_trace（）"></a><strong>string xdebug_start_trace（）</strong></h3><p>停止当前函数轨迹</p><p>停止跟踪函数调用并关闭跟踪文件。</p><p>该函数返回写入跟踪的文件的文件名。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Xdebug允许您记录所有函数调用，包括参数和返回值到不同格式的文件。&lt;/p&gt;
&lt;p&gt;那些所谓的“函数跟踪”可以帮助当你是新的一个应用程序，或当你试图找出当你的应用程序运行时究竟是怎么回事。&lt;br&gt;函数跟踪还可以选择显示传递给函数和方法的变量的值，以及返回值。 在默认跟踪中，这两个元素不可用。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之变量显示功能</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%8F%98%E9%87%8F%E6%98%BE%E7%A4%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%8F%98%E9%87%8F%E6%98%BE%E7%A4%BA%E5%8A%9F%E8%83%BD/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug替换了PHP的var_dump（）函数来显示变量。 Xdebug的版本包括不同类型的不同颜色，并且限制了数组元素/对象属性的数量，最大深度和字符串长度。 还有一些其他函数处理可变显示。</p><span id="more"></span><p>有一些设置控制Xdebug修改的var_dump（）函数的输出：</p><ul><li>xdebug.var_display_max_children，</li><li>xdebug.var_display_max_data</li><li>xdebug.var_display_max_depth</li></ul><p> 这三个设置的效果最好用一个例子。 下面的脚本运行四次，每次使用不同的设置。 您可以使用选项卡查看差异。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">public</span> <span class="token variable">$pub</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token variable">$priv</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token variable">$prot</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token variable">$t</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">;</span><span class="token variable">$t</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">pub</span> <span class="token operator">=</span> <span class="token variable">$t</span><span class="token punctuation">;</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token string">'one'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'a somewhat long string!'</span><span class="token punctuation">,</span>    <span class="token string">'two'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">array</span><span class="token punctuation">(</span>        <span class="token string">'two.one'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">array</span><span class="token punctuation">(</span>            <span class="token string">'two.one.zero'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">210</span><span class="token punctuation">,</span>            <span class="token string">'two.one.one'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">array</span><span class="token punctuation">(</span>                <span class="token string">'two.one.one.zero'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">3.141592564</span><span class="token punctuation">,</span>                <span class="token string">'two.one.one.one'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2.7</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'three'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$t</span><span class="token punctuation">,</span>    <span class="token string">'four'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span> <span class="token variable">$data</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>默认</p><pre><code>array&#39;one&#39; =&gt; string &#39;a somewhat long string!&#39; (length=23)&#39;two&#39; =&gt;  array    &#39;two.one&#39; =&gt;      array        &#39;two.one.zero&#39; =&gt; int 210        &#39;two.one.one&#39; =&gt;          array            ...&#39;three&#39; =&gt;  object(test)[1]    public &#39;pub&#39; =&gt;      &amp;object(test)[1]    private &#39;priv&#39; =&gt; boolean true    protected &#39;prot&#39; =&gt; int 42&#39;four&#39; =&gt;  array    0 =&gt; int 0    1 =&gt; int 1    2 =&gt; int 2    3 =&gt; int 3    4 =&gt; int 4    5 =&gt; int 5</code></pre></li><li><p>children=2</p><pre><code>array&#39;one&#39; =&gt; string &#39;a somewhat long string!&#39; (length=23)&#39;two&#39; =&gt;  array    &#39;two.one&#39; =&gt;      array        &#39;two.one.zero&#39; =&gt; int 210        &#39;two.one.one&#39; =&gt;          array            ...more elements...</code></pre></li><li><p>data=16</p><pre><code>array&#39;one&#39; =&gt; string &#39;a somewhat long &#39;... (length=23)&#39;two&#39; =&gt;  array    &#39;two.one&#39; =&gt;      array        &#39;two.one.zero&#39; =&gt; int 210        &#39;two.one.one&#39; =&gt;          array            ...&#39;three&#39; =&gt;  object(test)[1]    public &#39;pub&#39; =&gt;      &amp;object(test)[1]    private &#39;priv&#39; =&gt; boolean true    protected &#39;prot&#39; =&gt; int 42&#39;four&#39; =&gt;  array    0 =&gt; int 0    1 =&gt; int 1    2 =&gt; int 2    3 =&gt; int 3    4 =&gt; int 4    5 =&gt; int 5</code></pre></li><li><p>depth=2</p><pre><code>array&#39;one&#39; =&gt; string &#39;a somewhat long string!&#39; (length=23)&#39;two&#39; =&gt;  array    &#39;two.one&#39; =&gt;      array        ...&#39;three&#39; =&gt;  object(test)[1]    public &#39;pub&#39; =&gt;      &amp;object(test)[1]    private &#39;priv&#39; =&gt; boolean true    protected &#39;prot&#39; =&gt; int 42&#39;four&#39; =&gt;  array    0 =&gt; int 0    1 =&gt; int 1    2 =&gt; int 2    3 =&gt; int 3    4 =&gt; int 4    5 =&gt; int 5</code></pre></li><li><p>children=3, data=8, depth=1</p><pre><code>array&#39;one&#39; =&gt; string &#39;a somewh&#39;... (length=23)&#39;two&#39; =&gt;  array    ...&#39;three&#39; =&gt;  object(test)[1]    ...more elements...</code></pre></li></ul><h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><h3 id="xdebug-cli-color"><a href="#xdebug-cli-color" class="headerlink" title="xdebug.cli_color"></a><strong>xdebug.cli_color</strong></h3><p>类型：整数，默认值：0，在Xdebug&gt; 2.2中引入</p><ul><li><p>如果此设置为1，则Xdebug将在CLI模式下和输出为tty时对var_dumps和堆栈跟踪输出进行颜色。在Windows上，需要安装ANSICON工具。</p></li><li><p>如果设置为2，那么无论Xdebug是否连接到tty或是否安装了ANSICON，Xdebug都将始终对var_dumps和堆栈跟踪进行着色。在这种情况下，您可能会看到转义码。</p></li></ul><p>有关更多信息，请参阅此<a href="http://drck.me/clicolor-9cr">文章</a>。</p><h3 id="xdebug-overload-var-dump"><a href="#xdebug-overload-var-dump" class="headerlink" title="xdebug.overload_var_dump"></a><strong>xdebug.overload_var_dump</strong></h3><p>类型：boolean，默认值：2，在Xdebug&gt; 2.1中引入</p><ul><li><p>默认情况下，当html_errors php.ini设置为1或2时，Xdebug会自动重载var_dump（）并显示变量。</p></li><li><p>如果您不想要，可以将此设置设置为0，但首先检查它是否不是更聪明的关闭html_errors。</p></li><li><p>您也可以使用2作为此设置的值。除了格式化var_dump（）输出很好，它还将添加文件名和行号到输出。还尊重xdebug.file_link_format设置。 （Xdebug 2.3中的新功能）</p></li></ul><p>在Xdebug 2.4之前，此设置的默认值为1。</p><h3 id="xdebug-var-display-max-children"><a href="#xdebug-var-display-max-children" class="headerlink" title="xdebug.var_display_max_children"></a><strong>xdebug.var_display_max_children</strong></h3><p>类型：整数，默认值：128</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的数组子元素和对象的属性的数量。</p><ul><li>要禁用任何限制，请使用-1作为值。</li></ul><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-data"><a href="#xdebug-var-display-max-data" class="headerlink" title="xdebug.var_display_max_data"></a><strong>xdebug.var_display_max_data</strong></h3><p>类型：整数，默认值：512</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的最大字符串长度。</p><ul><li>要禁用任何限制，请使用-1作为值。</li></ul><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-depth"><a href="#xdebug-var-display-max-depth" class="headerlink" title="xdebug.var_display_max_depth"></a><strong>xdebug.var_display_max_depth</strong></h3><p>类型：整数，默认值：3</p><p>当使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时，控制数组元素和对象属性的嵌套级别数。</p><ul><li>您可以选择的最大值为1023.您还可以使用-1作为值来选择此最大数。</li></ul><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="void-var-dump（-mixture-var-，…-）"><a href="#void-var-dump（-mixture-var-，…-）" class="headerlink" title="void var_dump（[mixture var [，…]]）"></a><strong>void var_dump（[mixture var [，…]]）</strong></h3><blockquote><p>显示有关变量的详细信息</p></blockquote><p>此函数由Xdebug重载，请参阅xdebug_var_dump（）的说明。</p><h3 id="void-xdebug-debug-zval（-string-varname-，…-）"><a href="#void-xdebug-debug-zval（-string-varname-，…-）" class="headerlink" title="void xdebug_debug_zval（[string varname [，…]]）"></a><strong>void xdebug_debug_zval（[string varname [，…]]）</strong></h3><blockquote><p>显示有关变量的信息</p></blockquote><p>此函数显示有关一个或多个变量的结构化信息，包括其类型，值和引用计数信息。使用值递归地探索数组。这个函数的实现不同于PHP的debug_zval_dump（）函数，以解决该函数的问题，因为变量本身实际上传递给函数。 Xdebug的版本是更好的，因为它使用变量名称来查找内部符号表中的变量，并直接访问所有的属性，而不必处理实际传递一个变量到一个函数。结果是，该函数返回的信息比PHP自己的用于显示zval信息的函数准确得多。</p><p>从Xdebug 2.3开始支持除了简单变量名（例如下面的“a [2]”）之外的任何东西。</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$b</span> <span class="token operator">=</span><span class="token operator">&amp;</span> <span class="token variable">$a</span><span class="token punctuation">;</span>    <span class="token variable">$c</span> <span class="token operator">=</span><span class="token operator">&amp;</span> <span class="token variable">$a</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">xdebug_debug_zval</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xdebug_debug_zval</span><span class="token punctuation">(</span><span class="token string">"a[2]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：(refcount:引用次数，)</p><pre><code>a: (refcount=2, is_ref=1)=array (    0 =&gt; (refcount=1, is_ref=0)=1,    1 =&gt; (refcount=1, is_ref=0)=2,    2 =&gt; (refcount=2, is_ref=1)=3)a[2]: (refcount=2, is_ref=1)=3</code></pre><h3 id="void-xdebug-debug-zval-stdout（-string-varname-，…-）"><a href="#void-xdebug-debug-zval-stdout（-string-varname-，…-）" class="headerlink" title="void xdebug_debug_zval_stdout（[string varname [，…]]）"></a><strong>void xdebug_debug_zval_stdout（[string varname [，…]]）</strong></h3><blockquote><p>将有关变量的信息返回到stdout。</p></blockquote><p>此函数显示有关一个或多个变量的结构化信息，包括其类型，值和引用计数信息。 使用值递归地探索数组。 与xdebug_debug_zval（）的区别在于，该信息不通过Web服务器API层显示，而是直接显示在stdout上（因此，在Apache以单进程模式运行时，它会在控制台上运行）。</p><p>Example:</p><pre><code>&lt;?php    $a = array(1, 2, 3);    $b =&amp; $a;    $c =&amp; $a[2];    xdebug_debug_zval_stdout(&#39;a&#39;);</code></pre><p>返回：</p><pre><code>a: (refcount=2, is_ref=1)=array (    0 =&gt; (refcount=1, is_ref=0)=1,    1 =&gt; (refcount=1, is_ref=0)=2,    2 =&gt; (refcount=2, is_ref=1)=3)</code></pre><h3 id="void-xdebug-dump-superglobals（）"><a href="#void-xdebug-dump-superglobals（）" class="headerlink" title="void xdebug_dump_superglobals（）"></a><strong>void xdebug_dump_superglobals（）</strong></h3><blockquote><p>显示有关超级全局的信息</p></blockquote><p>此函数转储指定的超级全局元素的值通过php.ini中的xdebug.dump.*选项。 对于下面的示例，php.ini中的设置是：</p><p>Example:</p><pre><code>xdebug.dump.GET=*xdebug.dump.SERVER=REMOTE_ADDRQuery string:?var=fourty%20two&amp;array[a]=a&amp;array[9]=b</code></pre><p>结果：<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/8F0658D7-C951-4B12-BC74-92E15E31C44C.png" alt="img"></p><h3 id="void-xdebug-var-dump（-mixed-var-，…-）"><a href="#void-xdebug-var-dump（-mixed-var-，…-）" class="headerlink" title="void xdebug_var_dump（[mixed var [，…]]）"></a><strong>void xdebug_var_dump（[mixed var [，…]]）</strong></h3><blockquote><p>显示有关变量的详细信息</p></blockquote><p>此函数显示有关包含其类型和值的一个或多个表达式的结构化信息。 使用值递归地探索数组。 请参阅变量显示功能的介绍，其中php.ini设置影响此功能。</p><p>Example:</p><pre><code>&lt;?phpini_set(&#39;xdebug.var_display_max_children&#39;, 3 );$c = new stdClass;$c-&gt;foo = &#39;bar&#39;;$c-&gt;file = fopen( &#39;/etc/passwd&#39;, &#39;r&#39; );var_dump(    array(        array(TRUE, 2, 3.14, &#39;foo&#39;),        &#39;object&#39; =&gt; $c    ));?&gt;  </code></pre><p>结果</p><pre><code>array  0 =&gt;    array      0 =&gt; boolean true      1 =&gt; int 2      2 =&gt; float 3.14      more elements...  &#39;object&#39; =&gt;    object(stdClass)[1]      public &#39;foo&#39; =&gt; string &#39;bar&#39; (length=3)      public &#39;file&#39; =&gt; resource(3, stream)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Xdebug替换了PHP的var_dump（）函数来显示变量。 Xdebug的版本包括不同类型的不同颜色，并且限制了数组元素/对象属性的数量，最大深度和字符串长度。 还有一些其他函数处理可变显示。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之变量显示功能</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>当Xdebug被激活时，只要PHP决定显示通知，警告，错误等，它将显示一个堆栈跟踪。堆栈跟踪显示的信息以及它们的呈现方式可以配置为满足您的需要。</p><p>Xdebug在错误情况下显示的堆栈跟踪（如果display_errors在php.ini中设置为On）在它们显示的信息量上相当保守。 这是因为大量的信息可以减慢脚本的执行和在浏览器中呈现堆栈跟踪本身。 但是，可以使堆栈跟踪显示具有不同设置的更详细信息。</p><span id="more"></span><h2 id="堆栈跟踪中的变量"><a href="#堆栈跟踪中的变量" class="headerlink" title="堆栈跟踪中的变量"></a>堆栈跟踪中的变量</h2><p>默认情况下，Xdebug现在会在它生成的堆栈跟踪中显示变量信息。 在收集或显示时，可变信息可能需要相当多的资源。 然而，在许多情况下，显示变量信息是有用的，这就是为什么Xdebug具有设置xdebug.collect_params。 下面的脚本结合了该设置的不同值的输出结果，如下例所示。</p><p>示例：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token variable">$a</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$a</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">==</span> <span class="token number">500000</span><span class="token punctuation">)</span> <span class="token function">xdebug_break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token function">set_time_limit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">stdClass</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">bar</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token number">42</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">'foo'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">912124</span><span class="token punctuation">,</span>    <span class="token variable">$c</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">stdClass</span><span class="token punctuation">,</span> <span class="token function">fopen</span><span class="token punctuation">(</span> <span class="token string">'/etc/passwd'</span><span class="token punctuation">,</span> <span class="token string">'r'</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token variable">$a</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:<br>xdebug.collect_params设置的不同值提供不同的输出，您可以在下面看到：</p><ul><li>default</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-0@2x.png" alt="default"></p><ul><li>1<pre><code>ini_set(&#39;xdebug.collect_params&#39;, &#39;1&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-1@2x.png" alt="default"></p><ul><li>2<pre><code>ini_set(&#39;xdebug.collect_params&#39;, &#39;2&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-2@2x.png" alt="default"></p><ul><li>3<pre><code>ini_set(&#39;xdebug.collect_params&#39;, &#39;3&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-3@2x.png" alt="default"></p><ul><li>4<pre><code>ini_set(&#39;xdebug.collect_params&#39;, &#39;4&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-4@2x.png" alt="default"></p><h2 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h2><p>除了显示传递给每个函数的变量的值之外，Xdebug还可以通过使用xdebug.dump_globals和xdebug.dump.* 设置来选择性地显示关于所选超级元素的信息。 设置xdebug.dump_once和xdebug.dump_undefined会稍微修改可用超级元素显示的时间和信息。 使用xdebug.show_local_vars设置，您可以指示Xdebug为用户定义的函数显示最顶层栈级中可用的所有变量。 下面的示例显示了这一点（脚本从上面的示例中使用）。</p><ul><li>default</li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-5@2x.png" alt="default"></p><ul><li>dump_superglobals=1<pre><code>ini_set(&#39;xdebug.collect_vars&#39;, &#39;on&#39;);ini_set(&#39;xdebug.collect_params&#39;, &#39;4&#39;);ini_set(&#39;xdebug.dump_globals&#39;, &#39;on&#39;);ini_set(&#39;xdebug.dump.SERVER&#39;, &#39;REQUEST_URI&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-6@2x.png" alt="default"></p><ul><li>show_local_vars=1<pre><code>ini_set(&#39;xdebug.collect_vars&#39;, &#39;on&#39;);ini_set(&#39;xdebug.collect_params&#39;, &#39;4&#39;);ini_set(&#39;xdebug.dump_globals&#39;, &#39;on&#39;);ini_set(&#39;xdebug.dump.SERVER&#39;, &#39;REQUEST_URI&#39;);ini_set(&#39;xdebug.show_local_vars&#39;, &#39;on&#39;);</code></pre></li></ul><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-8@2x.png" alt="default"></p><h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><h3 id="xdebug-cli-color"><a href="#xdebug-cli-color" class="headerlink" title="xdebug.cli_color"></a><strong>xdebug.cli_color</strong></h3><p>类型：整数，默认值：0，在Xdebug&gt; 2.2中引入</p><p>如果此设置为1，则Xdebug将在CLI模式下和输出为tty时对var_dumps和堆栈跟踪输出进行颜色。在Windows上，需要安装ANSICON工具。</p><p>如果设置为2，那么无论Xdebug是否连接到tty或是否安装了ANSICON，Xdebug都将始终对var_dumps和堆栈跟踪进行着色。在这种情况下，您可能会看到转义码。</p><p>有关更多信息，请参阅此<a href="http://drck.me/clicolor-9cr">文章</a>。</p><h3 id="xdebug-collect-includes"><a href="#xdebug-collect-includes" class="headerlink" title="xdebug.collect_includes"></a><strong>xdebug.collect_includes</strong></h3><p>类型：布尔值，默认值：1</p><p>此设置默认为1，控制Xdebug是否应将include（），include_once（），require（）或require_once（）中使用的文件名写入跟踪文件。</p><h3 id="xdebug-collect-params"><a href="#xdebug-collect-params" class="headerlink" title="xdebug.collect_params"></a><strong>xdebug.collect_params</strong></h3><p>类型：整数，默认值：0</p><p>此设置默认为0，控制在函数跟踪或堆栈跟踪中记录函数调用时，Xdebug是否应收集传递给函数的参数。</p><p>该设置默认为0，因为对于非常大的脚本，它可能使用大量的内存，因此使巨量脚本无法运行。您可以最安全地打开此设置，但是您可以预期在具有大量函数调用和/或巨大的数据结构作为参数的脚本中存在一些问题。</p><p>Xdebug 2不会有增加的内存使用这个问题，因为它永远不会将此信息存储在内存中。相反，它将只被写入磁盘。这意味着您需要查看磁盘使用情况。</p><p>此设置可以有四个不同的值。对于每个值，示出了不同量的信息。下面你将看到每个值提供什么信息。另请参见功能堆栈跟踪的几个截图的介绍。</p><table><thead><tr><th>值</th><th>显示参数信息</th></tr></thead><tbody><tr><td>0</td><td>无。</td></tr><tr><td>1</td><td>元素的类型和数量（f.e. string（6），array（8））。</td></tr><tr><td>2</td><td>元素的类型和数量，带有完整信息的工具提示1。在CLI版本的PHP它不会有工具提示，而不是在输出文件。</td></tr><tr><td>3</td><td>完全变量内容（具有由xdebug.var_display_max_children，xdebug.var_display_max_data和xdebug.var_display_max_depth设置的限制）。</td></tr><tr><td>4</td><td>完全变量内容和变量名称。</td></tr><tr><td>5</td><td>PHP序列化变量内容，没有名称。 （Xdebug 2.3中的新功能）</td></tr></tbody></table><h3 id="xdebug-collect-vars"><a href="#xdebug-collect-vars" class="headerlink" title="xdebug.collect_vars"></a><strong>xdebug.collect_vars</strong></h3><p>类型：布尔值，默认值：0</p><p>此设置告诉Xdebug收集有关在某个范围中使用哪些变量的信息。 这个分析可能很慢，因为Xdebug必须逆向工程PHP的操作码数组。 此设置不会记录不同变量具有的值，因为使用xdebug.collect_params。 仅当您希望使用xdebug_get_declared_vars（）时，才需要启用此设置。</p><h3 id="xdebug-dump"><a href="#xdebug-dump" class="headerlink" title="xdebug.dump.*"></a><strong>xdebug.dump.*</strong></h3><p>类型：字符串，默认值：空</p><p>*可以是COOKIE，FILES，GET，POST，REQUEST，SERVER，SESSION中的任何一个。 这七个设置控制当发生错误情况时来自超级溶剂的数据。</p><p>每个php.ini设置可以包括一个逗号分隔的变量从这个超级全局转储，或*所有的。 请确保您在此设置中不添加空格。</p><p>为了在发生错误时转储REMOTE_ADDR和REQUEST_METHOD，以及所有GET参数，请添加以下设置：</p><pre><code>xdebug.dump.SERVER = REMOTE_ADDR,REQUEST_METHODxdebug.dump.GET = *</code></pre><h3 id="xdebug-dump-globals"><a href="#xdebug-dump-globals" class="headerlink" title="xdebug.dump_globals"></a><strong>xdebug.dump_globals</strong></h3><p>类型：布尔值，默认值：1</p><p>控制是否应显示由xdebug.dump.*设置定义的超级元素的值。</p><h3 id="xdebug-dump-once"><a href="#xdebug-dump-once" class="headerlink" title="xdebug.dump_once"></a><strong>xdebug.dump_once</strong></h3><p>类型：布尔值，默认值：1</p><p>控制是否应在所有错误情况（设置为0）或仅在第一个（设置为1）上转储超级元素的值。</p><h3 id="xdebug-dump-undefined"><a href="#xdebug-dump-undefined" class="headerlink" title="xdebug.dump_undefined"></a><strong>xdebug.dump_undefined</strong></h3><p>类型：布尔值，默认值：0<br>如果要从超级元组转储未定义的值，您应该将此设置设置为1，否则将其设置为0。</p><h3 id="xdebug-file-link-format"><a href="#xdebug-file-link-format" class="headerlink" title="xdebug.file_link_format"></a><strong>xdebug.file_link_format</strong></h3><p>类型：字符串，默认值：，在Xdebug&gt; 2.1中引入</p><p>此设置确定在使用文件名的堆栈跟踪显示中进行的链接的格式。 这允许IDE设置一个链接协议，通过单击Xdebug在堆栈跟踪中显示的文件名，可以直接转到行和文件。 示例格式可能如下所示：</p><pre><code>myide://%f@%l</code></pre><p>可能的格式说明符是：</p><table><thead><tr><th>说明符</th><th>含义</th></tr></thead><tbody><tr><td>％f</td><td>文件名</td></tr><tr><td>％l</td><td>行号</td></tr></tbody></table><p>对于各种IDE / OSses，有一些关于如何使这项工作的指示：</p><p>Linux上的Firefox</p><ul><li><p>打开about：config</p></li><li><p>添加一个新的布尔设置“network.protocol-handler.expose.xdebug”并将其设置为“false”</p></li><li><p>将以下内容添加到shell脚本〜/ bin / ff-xdebug.sh中：</p><pre class="line-numbers language-sh"><code class="language-sh">#! /bin/shf=`echo $1 | cut -d @ -f 1 | sed 's/xdebug:\/\///'`l=`echo $1 | cut -d @ -f 2`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加（取决于你有komodo，vim vs netbeans）：</p><pre class="line-numbers language-sh"><code class="language-sh">komodo $f -l $lgvim --remote-tab +$l $fnetbeans "$f:$l"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用chmod + x〜/ bin / ff-xdebug.sh来使脚本可执行</p></li><li><p>将xdebug.file_link_format设置为xdebug：//％f @％l</p></li></ul><p>Windows和netbeans</p><ul><li>创建文件netbeans.bat并将其保存在您的路径（C：\ Windows）：<pre><code>@echo offsetlocal enableextensions enabledelayedexpansionset NETBEANS=%1set FILE=%~2%NETBEANS% --nosplash --console suppress --open &quot;%FILE:~19%&quot;nircmd win activate process netbeans.exe</code></pre></li></ul><p>注意：如果没有nircmd，请删除最后一行。</p><ul><li>将以下代码保存在netbeans protocol.reg中：</li></ul><pre><code>Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\netbeans]&quot;URL Protocol&quot;=&quot;&quot;@=&quot;URL:Netbeans Protocol&quot;[HKEY_CLASSES_ROOT\netbeans\DefaultIcon]@=&quot;\&quot;C:\\Program Files\\NetBeans 7.1.1\\bin\\netbeans.exe,1\&quot;&quot;[HKEY_CLASSES_ROOT\netbeans\shell][HKEY_CLASSES_ROOT\netbeans\shell\open][HKEY_CLASSES_ROOT\netbeans\shell\open\command]@=&quot;\&quot;C:\\Windows\\netbeans.bat\&quot; \&quot;C:\\Program Files\\NetBeans 7.1.1\\bin\\netbeans.exe\&quot; \&quot;%1\&quot;&quot;</code></pre><p>注意：确保更改Netbeans（两次）的路径以及netbeans.bat批处理文件（如果将其保存在C：\Windows 以外的其他位置）。</p><p>Double click on the netbeans_protocol.reg file to import it into the registry.<br>Set the xdebug.file_link_format setting to</p><ul><li><p>双击netbeans protocol.reg文件将其导入到注册表中。</p></li><li><p>将xdebug.file_link_format设置设置为<code>xdebug.file_link_format = &quot;netbeans://open/?f=%f:%l&quot;</code></p></li></ul><h3 id="xdebug-manual-url"><a href="#xdebug-manual-url" class="headerlink" title="xdebug.manual_url"></a><strong>xdebug.manual_url</strong></h3><p>类型：字符串，默认值：http：//<a href="http://www.php.net,在xdebug/">www.php.net，在Xdebug</a> &lt;2.2.1中引入</p><p>这是从函数跟踪和错误消息到函数的手册页的链接的基本URL。建议将此设置设置为使用最近的镜像。</p><h3 id="xdebug-show-exception-trace"><a href="#xdebug-show-exception-trace" class="headerlink" title="xdebug.show_exception_trace"></a><strong>xdebug.show_exception_trace</strong></h3><p>类型：整数，默认值：0</p><p>当此设置设置为1时，每当引发异常时，即使此异常实际被捕获，Xdebug也将显示堆栈跟踪。</p><h3 id="xdebug-show-local-vars"><a href="#xdebug-show-local-vars" class="headerlink" title="xdebug.show_local_vars"></a><strong>xdebug.show_local_vars</strong></h3><p>类型：整数，默认值：0</p><p>当这个设置设置为某事！= 0 Xdebug的错误情况下生成的堆栈转储也将显示最顶层范围中的所有变量。请注意，这可能会生成大量的信息，因此默认情况下关闭。</p><h3 id="xdebug-show-mem-delta"><a href="#xdebug-show-mem-delta" class="headerlink" title="xdebug.show_mem_delta"></a><strong>xdebug.show_mem_delta</strong></h3><p>类型：整数，默认值：0</p><p>当这个设置设置为某些！= 0 Xdebug的人类可读的生成的跟踪文件将显示在函数调用之间的内存使用的差异。如果Xdebug配置为生成计算机可读的跟踪文件，则它们将始终显示此信息。</p><h3 id="xdebug-var-display-max-children"><a href="#xdebug-var-display-max-children" class="headerlink" title="xdebug.var_display_max_children"></a><strong>xdebug.var_display_max_children</strong></h3><p>类型：整数，默认值：128</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的数组子元素和对象的属性的数量。</p><p>要禁用任何限制，请使用-1作为值。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-data"><a href="#xdebug-var-display-max-data" class="headerlink" title="xdebug.var_display_max_data"></a><strong>xdebug.var_display_max_data</strong></h3><p>类型：整数，默认值：512</p><p>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的最大字符串长度。</p><p>要禁用任何限制，请使用-1作为值。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h3 id="xdebug-var-display-max-depth"><a href="#xdebug-var-display-max-depth" class="headerlink" title="xdebug.var_display_max_depth"></a><strong>xdebug.var_display_max_depth</strong></h3><p>类型：整数，默认值：3</p><p>当使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时，控制数组元素和对象属性的嵌套级别数。</p><p>您可以选择的最大值为1023.您还可以使用-1作为值来选择此最大数。</p><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="array-xdebug-get-declared-vars（）"><a href="#array-xdebug-get-declared-vars（）" class="headerlink" title="array xdebug_get_declared_vars（）"></a><strong>array xdebug_get_declared_vars（）</strong></h3><p>返回声明的变量</p><p>返回一个数组，其中每个元素是在当前范围中定义的变量名称。 需要启用xdebug.collect_vars设置。</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">class</span> <span class="token class-name">strings</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">fix_strings</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$b</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$b</span> <span class="token keyword">as</span> <span class="token variable">$item</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_get_declared_vars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    strings<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">fix_strings</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><pre><code>array  0 =&gt; string &#39;a&#39; (length=1)  1 =&gt; string &#39;b&#39; (length=1)  2 =&gt; string &#39;item&#39; (length=4)</code></pre><p>在5.1之前的PHP版本中，变量名“a”不在返回的数组中，因为它在调用函数xdebug_get_declared_vars（）的作用域中不使用。</p><h3 id="array-xdebug-get-function-stack（）"><a href="#array-xdebug-get-function-stack（）" class="headerlink" title="array xdebug_get_function_stack（）"></a><strong>array xdebug_get_function_stack（）</strong></h3><p>返回有关堆栈的信息</p><p>返回类似于此点的堆栈跟踪的数组。 示例脚本：</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">class</span> <span class="token class-name">strings</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">function</span> <span class="token function">fix_string</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_get_function_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">function</span> <span class="token function">fix_strings</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$b</span> <span class="token keyword">as</span> <span class="token variable">$item</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">fix_string</span><span class="token punctuation">(</span><span class="token variable">$item</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$s</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">strings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$ret</span> <span class="token operator">=</span> <span class="token variable">$s</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">fix_strings</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'Derick'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><pre><code>array  0 =&gt;    array      &#39;function&#39; =&gt; string &#39;&#123;main&#125;&#39; (length=6)      &#39;file&#39; =&gt; string &#39;/var/www/xdebug_get_function_stack.php&#39; (length=63)      &#39;line&#39; =&gt; int 0      &#39;params&#39; =&gt;        array          empty  1 =&gt;    array      &#39;function&#39; =&gt; string &#39;fix_strings&#39; (length=11)      &#39;class&#39; =&gt; string &#39;strings&#39; (length=7)      &#39;file&#39; =&gt; string &#39;/var/www/xdebug_get_function_stack.php&#39; (length=63)      &#39;line&#39; =&gt; int 18      &#39;params&#39; =&gt;        array          &#39;b&#39; =&gt; string &#39;array (0 =&gt; &#39;Derick&#39;)&#39; (length=21)  2 =&gt;    array      &#39;function&#39; =&gt; string &#39;fix_string&#39; (length=10)      &#39;class&#39; =&gt; string &#39;strings&#39; (length=7)      &#39;file&#39; =&gt; string &#39;/var/www/xdebug_get_function_stack.php&#39; (length=63)      &#39;line&#39; =&gt; int 12      &#39;params&#39; =&gt;        array          &#39;a&#39; =&gt; string &#39;&#39;Derick&#39;&#39; (length=8)</code></pre><h3 id="array-xdebug-get-monitored-functions（）"><a href="#array-xdebug-get-monitored-functions（）" class="headerlink" title="array xdebug_get_monitored_functions（）"></a><strong>array xdebug_get_monitored_functions（）</strong></h3><p>返回有关受监视函数的信息</p><p>在2.4版本中引入</p><p>返回一个结构，其中包含有关在脚本中执行受监视函数的位置的信息。 以下示例显示如何使用此和返回的信息：</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/* Start the function monitor for strrev and array_push: */</span><span class="token function">xdebug_start_function_monitor</span><span class="token punctuation">(</span> <span class="token punctuation">[</span> <span class="token string">'strrev'</span><span class="token punctuation">,</span> <span class="token string">'array_push'</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Run some code: */</span><span class="token keyword">echo</span> <span class="token function">strrev</span><span class="token punctuation">(</span><span class="token string">"yes!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">strrev</span><span class="token punctuation">(</span><span class="token string">"yes!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">xdebug_get_monitored_functions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xdebug_stop_function_monitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><pre><code>/tmp/monitor-example.php:10:array(2) &#123;  [0] =&gt;  array(3) &#123;    &#39;function&#39; =&gt;    string(6) &quot;strrev&quot;    &#39;filename&#39; =&gt;    string(24) &quot;/tmp/monitor-example.php&quot;    &#39;lineno&#39; =&gt;    int(6)  &#125;  [1] =&gt;  array(3) &#123;    &#39;function&#39; =&gt;    string(6) &quot;strrev&quot;    &#39;filename&#39; =&gt;    string(24) &quot;/tmp/monitor-example.php&quot;    &#39;lineno&#39; =&gt;    int(8)  &#125;&#125;</code></pre><h3 id="integer-xdebug-get-stack-depth（）"><a href="#integer-xdebug-get-stack-depth（）" class="headerlink" title="integer xdebug_get_stack_depth（）"></a><strong>integer xdebug_get_stack_depth（）</strong></h3><p>返回当前堆栈深度级别</p><p>返回堆栈深度级别。 脚本的主体是级别0，每个包含和/或函数调用将向堆栈深度级别添加一个。</p><h3 id="none-xdebug-print-function-stack-string-message-int-options"><a href="#none-xdebug-print-function-stack-string-message-int-options" class="headerlink" title="none xdebug_print_function_stack( [ string message [, int options ] ] )"></a><strong>none xdebug_print_function_stack( [ string message [, int options ] ] )</strong></h3><p>显示当前函数栈</p><p>以类似于Xdebug在错误情况下显示的方式显示当前函数堆栈。</p><p>“message”参数允许您使用自己的头部替换消息。 （在Xdebug 2.1中引入）。</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token variable">$far</span><span class="token punctuation">,</span> <span class="token variable">$out</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token function">xdebug_print_function_stack</span><span class="token punctuation">(</span> <span class="token string">'Your own message'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">3141592654</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Returns:</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161022/QQ20161022-9@2x.png" alt="img"></p><p>位掩码“options”允许您配置一些额外的选项。 目前支持以下选项：</p><ul><li>XDEBUG_STACK_NO_DESC<blockquote><p>如果设置了此选项，则打印的堆栈跟踪将不具有标题。 如果要从自己的错误处理程序打印堆栈跟踪，否则打印位置是从中调用xdebug_print_function_stack（）时，这是有用的。 （在Xdebug 2.3中引入）。</p></blockquote></li></ul><h3 id="void-xdebug-start-function-monitor（array-list-of-functions-to-monitor）"><a href="#void-xdebug-start-function-monitor（array-list-of-functions-to-monitor）" class="headerlink" title="void xdebug_start_function_monitor（array $ list_of_functions_to_monitor）"></a><strong>void xdebug_start_function_monitor（array $ list_of_functions_to_monitor）</strong></h3><p>开始功能监控</p><p>在2.4版本中引入</p><p>此函数开始监视列表中给出的函数作为此函数的参数。 函数监视允许您找到代码中提供的作为参数的函数在哪里调用。 这可以用于跟踪使用旧的或不鼓励的函数的位置。</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">xdebug_start_function_monitor</span><span class="token punctuation">(</span> <span class="token punctuation">[</span> <span class="token string">'strrev'</span><span class="token punctuation">,</span> <span class="token string">'array_push'</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>您还可以向定义要监视的函数的数组添加类方法和静态方法。 例如，要捕获对DramModel :: canSee的静态调用和对Whisky-&gt; drink的动态调用，您将启动监视器：</p><p>Example:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">xdebug_start_function_monitor</span><span class="token punctuation">(</span> <span class="token punctuation">[</span> <span class="token string">'DramModel::canSee'</span><span class="token punctuation">,</span> <span class="token string">'Whisky->drink'</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义的函数区分大小写，并且不会捕获对静态方法的动态调用。</p><h3 id="void-xdebug-stop-function-monitor（）"><a href="#void-xdebug-stop-function-monitor（）" class="headerlink" title="void xdebug_stop_function_monitor（）"></a><strong>void xdebug_stop_function_monitor（）</strong></h3><p>停止监视功能</p><p>在2.4版本中引入</p><p>此功能停止功能监视器。 为了获得受监视函数的列表，您需要使用xdebug_get_monitored_functions（）函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当Xdebug被激活时，只要PHP决定显示通知，警告，错误等，它将显示一个堆栈跟踪。堆栈跟踪显示的信息以及它们的呈现方式可以配置为满足您的需要。&lt;/p&gt;
&lt;p&gt;Xdebug在错误情况下显示的堆栈跟踪（如果display_errors在php.ini中设置为On）在它们显示的信息量上相当保守。 这是因为大量的信息可以减慢脚本的执行和在浏览器中呈现堆栈跟踪本身。 但是，可以使堆栈跟踪显示具有不同设置的更详细信息。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之常见问题</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>xdebug的使用</p></li><li><p>xdebug的编译安装</p></li></ul><span id="more"></span><h2 id="xdebug的使用"><a href="#xdebug的使用" class="headerlink" title="xdebug的使用"></a>xdebug的使用</h2><p>问：phpinfo（）报告Xdebug已安装和启用，但我仍然不会得到任何堆栈跟踪时发生错误。</p><p>A1：你必须搜索所有的PHP库，并包含任何“set_error_handler”调用的文件。如果有任何，你必须将其注释掉，或者更改handler函数的主体以调用xdebug_ * api函数。</p><p>A2：您没有在php.ini中将display_errors设置为1</p><hr><p>问：Xdebug不格式化输出。</p><p>A：确保php.ini中的PHP的html_errors设置为1</p><hr><p>问：调试客户端没有收到任何连接，我怎么办？</p><p>A：您可能忘记设置环境变量或向URL中添加必要的信息。有关详细信息，请参阅文档。</p><p>A：您检查过防火墙设置了吗？确保Xdebug正在侦听的端口（默认为9000）未被阻止。</p><p>A：你使用FastCGI，可能是通过FPM（FastCGI过程管理器）？它默认使用相同的端口作为Xdebug（9000），因此您需要将其中一个更改为不同的数字。在Xdebug，你可以使用xdebug.remote_port。</p><p>A：如果你使用SELinux运行，你应该确保它不会阻止连接;查找关于name_connect或与Xdebug端口相关的任何警告。您可能必须明确允许访问。访问此网站或搜索“selinux name_connect apache”有关如何执行此操作的详细信息</p><h2 id="xdebug的编译安装"><a href="#xdebug的编译安装" class="headerlink" title="xdebug的编译安装"></a>xdebug的编译安装</h2><p>问：我没有phpize工具。</p><p>答：Debian和Ubuntu用户需要用apt安装php5-dev软件包。</p><hr><p>问：如何处理：Xdebug需要Zend Engine API版本xxxxxxxx。安装的Zend Engine API版本2xxxxxxxx较新。</p><p>A：此消息意味着您正在尝试加载Xdebug的PHP版本，它不是为它构建的。如果你自己编译PHP，很可能是因为你编译Xdebug对PHP头，属于你运行的不同的PHP版本。例如，你使用PHP 5.3，你使用的头仍然是PHP 5.2。如果你使用一个预编译的二进制文件，那么你使用的是错误的。</p><p>要诊断这是否是您的问题，请执行以下步骤：</p><ul><li><p>通过查看phpinfo（）（或“php -i”）输出，检查您正在运行的PHP版本的“Zend Extension”API号。您可以在输出的顶部找到它，与PHP徽标和PHP版本在同一个块中。例如，对于PHP 5.2，数字是“220060519”，对于PHP 5.3，它是“220090626”。</p></li><li><p>当您完成编译步骤时，检查“phpize”的输出。您要查找的数字是在“Zend Extension Api No”的行上。</p></li></ul><p>如果上面的两个数字不匹配，你正在使用错误的PHP头文件进行编译。请参阅下一个常见问题条目以确定要使用的phpize。</p><hr><p>问：Xdebug仅作为PHP扩展加载，而不是作为Zend扩展。<br>定制的安装指导可能已指向此条目。</p><p>为了使Xdebug正常工作，包括断点等，它需要它作为Zend扩展加载，而不只是作为一个普通的PHP扩展。有些安装工具（PEAR / PECL）有时建议您使用extension = xdebug.so加载Xdebug。这是不正确的。为了解决这个问题，请在顶部块中“加载配置文件”和“其他.ini文件解析”下列出的任何INI文件中查找一行extension = xdebug.so。删除此行，并返回到定制安装说明。</p><hr><p>问：我如何找到使用哪个phpize？</p><p>A：运行：“phpize –help”。这将显示phpize的完整路径。此路径应该与您具有CLI二进制文件“php-config”和安装的“pear”和“pecl”二进制文件的路径相同。如果你运行“php-config –version”它应该显示与你运行的PHP版本相同。如果它不匹配，并且可能在路径上找到错误的“phpize”二进制，您可以运行configure如下：</p><pre><code>/full/path/to/php/bin/phpize./configure --with-php-config=/full/path/to/php/bin/php-config</code></pre><hr><p>问：我使用XAMPP，但我似乎不能得到打包的xdebug扩展正常工作。</p><p>A：如果你取消注释“extension = php_xdebug.dll”行，这是预期的。 Xdebug需要加载zend_extension_ts =“C：\ path \ to \ php_xdebug.dll”指令。 你也可能必须禁用加载Zend优化器，因为它默认情况下启用，并且不能很好地与Xdebug。 因此，查找php.ini中的相关条目，并将其注释掉。 从PHP 5.3起，您总是需要使用zend_extension PHP.ini设置名称，而不是zend_extension_ts。<br>问：在Debian，我看到以下问题与Xdebug的构建….任何修复？</p><pre><code>/usr/lib/libc_nonshared.a(stat.oS)(.text.__i686.get_pc_thunk.bx+0x0):In function `__i686.get_pc_thunk.bx&#39;:: multiple definition of `__i686.get_pc_thunk.bx&#39;/usr/lib/gcc-lib/i486-linux/3.3.5/crtbeginS.o(.gnu.linkonce.t.__i686.get_pc_thunk.bx+0x0): first defined herecollect2: ld returned 1 exit statusmake: *** [xdebug.la] Error 1</code></pre><p>A：这是Debian本身的问题，有关更多信息，请参阅<a href="http://www.xdebug.org/archives/xdebug-general/0825.html">此处</a>和<a href="http://www.xdebug.org/archives/xdebug-general/0825.html">此处</a>。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;xdebug的使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;xdebug的编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>Xdebug之远程调试</title>
    <link href="https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://weizhimiao.github.io/2016/10/22/Xdebug%E4%B9%8B%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2016-10-22T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug为与运行PHP脚本交互的调试器客户端提供了一个接口。 本节介绍如何设置PHP和Xdebug来允许这一点，并介绍一些客户端。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Xdebug的（远程）调试器允许您检查数据结构，交互式地浏览和调试您的代码。 正在使用的协议是打开的，称为DBGp。 此协议在Xdebug 2中实现，并替换不再支持的旧的GDB类协议。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Xdebug 2捆绑了一个用于DBGp协议的简单命令行客户端。 还有一些其他客户端实现（免费和商业）。 我不是任何这些的作者，所以请参考原作者的支持：</p><ul><li>Dev-PHP (IDE: Windows)</li><li>Eclipse plugin (IDE).</li><li>Emacs plugin (Editor Plugin).</li><li>KDevelop (IDE: Linux (KDE); Open Source).</li><li>ActiveState’s Komodo (IDE: Windows, Linux, Mac; Commercial).</li><li>MacGDBP (Standalone client for Mac OS X; Free)</li><li>NetBeans (IDE: Windows, Linux, Mac OS X and Solaris).</li><li>Notepad++ plugin (Editor: Windows).</li><li>WaterProof’s PHPEdit (IDE, from version 2.10: Windows; Commercial).</li><li>PHPEclipse (Editor Plugin).</li><li>Devsense’s PHP Tools for Visual Studio (MS Visual Studio Plugin; Commercial).</li><li>JetBrain’s PhpStorm (IDE; Commercial).</li><li>Protoeditor (Editor: Linux).</li><li>pugdebug (Standalone client for Linux, Windows and Mac OS X; Open Source).</li><li>VIM plugin (Editor Plugin).</li><li>jcx software’s VS.Php (MS Visual Studio Plugin; Commercial).</li><li>Xdebug Chrome App (Chrome Application; Open Source)</li><li>XDebugClient (Standalone client for Windows).</li></ul><p>用于调试的简单命令行客户机与debugclient目录中的Xdebug捆绑在一起。</p><h2 id="启动调试器"><a href="#启动调试器" class="headerlink" title="启动调试器"></a>启动调试器</h2><p>为了启用Xdebug的调试器，您需要在php.ini中进行一些配置设置。 这些设置为xdebug.remote_enable以启用调试器xdebug.remote_host和xdebug.remote_port来配置调试器应连接到的IP地址和端口。 还有一个xdebug.remote_connect_back设置，如果您的开发服务器与多个开发人员共享，则可以使用此设置。</p><p>如果希望调试器在发生错误情况（PHP错误或异常）时启动会话，则还需要更改xdebug.remote_mode设置。 此设置的允许值为“req”（默认值），这使得调试器在脚本启动时启动会话，或者“jit”，当会话只应在错误时启动。</p><p>完成所有这些设置后，Xdebug仍然不会在脚本运行时自动启动调试会话。 你需要激活Xdebug的调试器，你可以通过三种方式：</p><p>1、当从命令行运行脚本时，您需要设置一个环境变量，如：</p><pre><code>export XDEBUG_CONFIG=&quot;idekey=session_name&quot;php myscript.php</code></pre><p>您还可以在此相同的环境变量中配置xdebug.remote_host，xdebug.remote_port，xdebug.remote_mode和xdebug.remote_handler，只要使用空格分隔值即可：</p><pre><code>export XDEBUG_CONFIG=&quot;idekey=session_name remote_host=localhost profiler_enable=1&quot;</code></pre><p>通过XDEBUG_CONFIG设置可以获得的所有设置也可以使用正常的php.ini设置进行设置。</p><p>2、如果要调试通过Web浏览器启动的脚本，只需将XDEBUG_SESSION_START = session_name作为参数添加到URL。 而不是使用GET参数，您还可以将XDEBUG_SESSION_START设置为POST参数，或通过cookie。 请参阅下一节，了解调试会话如何在浏览器窗口中工作。</p><p>3、通过Web服务器运行PHP时激活调试器的另一种方法是安装以下四个浏览器扩展之一。 它们中的每一个都允许您通过单击一个按钮来启用调试器。 当这些扩展是活动的，他们直接设置XDEBUG_SESSION cookie，而不是通过XDEBUG_SESSION_START进一步的HTTP调试会话中描述。 扩展名为：</p><ul><li><p>The easiest Xdebug</p><blockquote><p>这个扩展的Firefox是为了使IDE的调试更容易。 您可以在<a href="https://addons.mozilla.org/en-US/firefox/addon/the-easiest-xdebug/%E6%89%BE%E5%88%B0%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E3%80%82">https://addons.mozilla.org/en-US/firefox/addon/the-easiest-xdebug/找到扩展程序。</a></p></blockquote></li><li><p>Xdebug Helper for Chrome</p><blockquote><p>Chrome的此扩展程序将帮助您通过一次点击启用/禁用调试和分析。 您可以在<a href="https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc%E6%89%BE%E5%88%B0%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E3%80%82">https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc找到扩展程序。</a></p></blockquote></li><li><p>Xdebug Toggler for Safari</p><blockquote><p>Safari的这个扩展允许你从Safari中自动启动Xdebug调试。 你可以从Github <a href="https://github.com/benmatselby/xdebug-toggler%E8%8E%B7%E5%8F%96%E5%AE%83%E3%80%82">https://github.com/benmatselby/xdebug-toggler获取它。</a></p></blockquote></li><li><p>Xdebug launcher for Opera</p><blockquote><p>这个扩展的Opera允许您从Opera启动Xdebug会话。</p></blockquote></li></ul><p>在你开始你的脚本之前，你需要告诉你的客户端它可以接收调试连接，请参考具体客户端的文档如何做到这一点。 要使用捆绑的客户端，只需在编译和安装后启动它。 您可以通过运行“debugclient”启动它。</p><p>当debugclient启动时，它将显示以下信息，然后等待，直到调试服务器启动连接：</p><pre><code>Xdebug Simple DBGp client (0.10.0)Copyright 2002-2007 by Derick Rethans.- libedit support: enabledWaiting for debug server to connect.</code></pre><p>在建立连接后，将显示调试服务器的输出：</p><pre><code>Connect&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&lt;init xmlns=&quot;urn:debugger_protocol_v1&quot;      xmlns:xdebug=&quot;http://xdebug.org/dbgp/xdebug&quot;      fileuri=&quot;file:///home/httpd/www.xdebug.org/html/docs/index.php&quot;      language=&quot;PHP&quot;      protocol_version=&quot;1.0&quot;      appid=&quot;13202&quot;      idekey=&quot;derick&quot;&gt;  &lt;engine version=&quot;2.0.0RC4-dev&quot;&gt;&lt;![CDATA[Xdebug]]&gt;&lt;/engine&gt;  &lt;author&gt;&lt;![CDATA[Derick Rethans]]&gt;&lt;/author&gt;  &lt;url&gt;&lt;![CDATA[http://xdebug.org]]&gt;&lt;/url&gt;  &lt;copyright&gt;&lt;![CDATA[Copyright (c) 2002-2007 by Derick Rethans]]&gt;&lt;/copyright&gt;&lt;/init&gt;(cmd)</code></pre><p>现在，您可以使用DBGp文档页面中说明的命令集。 当脚本结束时，调试服务器与客户端断开连接，并且调试客户端在等待新连接时恢复。</p><h2 id="通讯建立"><a href="#通讯建立" class="headerlink" title="通讯建立"></a>通讯建立</h2><h3 id="使用静态IP-单个开发者"><a href="#使用静态IP-单个开发者" class="headerlink" title="使用静态IP /单个开发者"></a>使用静态IP /单个开发者</h3><p>通过远程调试，嵌入在PHP中的Xdebug就像客户端，而IDE作为服务器。 以下动画显示了通信通道的设置：</p><p><img data-src="https://xdebug.org/images/docs/dbgp-setup.gif" alt="img"></p><ul><li>服务器的IP是10.0.1.2，HTTP在端口80上</li><li>IDE在IP 10.0.1.42上，因此xdebug.remote_host设置为10.0.1.42</li><li>IDE侦听端口9000，因此xdebug.remote_port设置为9000</li><li>HTTP请求在运行IDE的计算机上启动</li><li>Xdebug连接到10.0.1.42:9000</li><li>调试运行，提供HTTP响应</li></ul><h3 id="与未知IP-多开发者"><a href="#与未知IP-多开发者" class="headerlink" title="与未知IP /多开发者"></a>与未知IP /多开发者</h3><p>如果使用xdebug.remote_connect_back，设置稍有不同：</p><p><img data-src="https://xdebug.org/images/docs/dbgp-setup2.gif" alt="img"></p><ul><li>服务器的IP是10.0.1.2，HTTP在端口80上</li><li>IDE处于未知IP，因此xdebug.remote_connect_back设置为1</li><li>IDE侦听端口9000，因此xdebug.remote_port设置为9000</li><li>发出HTTP请求后，Xdebug将从HTTP头中检测IP地址</li><li>Xdebug连接到端口9000上检测到的IP（10.0.1.42）</li><li>调试运行，提供HTTP响应</li></ul><h2 id="HTTP调试会话"><a href="#HTTP调试会话" class="headerlink" title="HTTP调试会话"></a>HTTP调试会话</h2><p>Xdebug包含通过浏览器启动时跟踪调试会话的功能：Cookie。 这是这样工作：</p><ul><li><p>当URL变量XDEBUG_SESSION_START = name附加到URL或通过具有相同名称的POST变量时，-Xdebug会发出名为“XDEBUG_SESSION”的cookie，并将值设置为XDEBUG_SESSION_START URL参数的值。 cookie的到期时间为1小时。 当连接到“idekey”属性中的debugclient时，DBGp协议也将此相同的值传递给init包。</p></li><li><p>当有一个GET（或POST）变量XDEBUG_SESSION_START或XDEBUG_SESSION cookie被设置时，Xdebug将尝试连接到一个调试客户端。</p></li><li><p>要停止调试会话（并销毁cookie），只需添加URL参数XDEBUG_SESSION_STOP即可。 Xdebug将不再尝试连接到调试客户端。</p></li></ul><h2 id="多用户调试"><a href="#多用户调试" class="headerlink" title="多用户调试"></a>多用户调试</h2><p>Xdebug仅允许您在执行远程调试时指定一个IP地址与xdebug.remote_host连接。它不会自动连接回浏览器运行的计算机的IP地址，除非您使用xdebug.remote_connect_back。</p><p>如果所有开发人员在同一（开发）服务器上的不同项目上工作，则可以通过Apache的.htaccess功能为每个目录设置xdebug.remote_host设置，方法是使用php_value xdebug.remote_host = 10.0.0.5。但是，对于多个开发人员在同一代码上工作的情况，.htaccess技巧不工作，因为代码所在的目录是相同的。</p><p>有两个解决方案。首先，你可以使用DBGp代理。有关如何使用此代理的概述，请参阅多个用户调试中的文章。您可以在ActiveState的网站上下载代理作为python远程调试包的一部分。 Komodo FAQ中还有一些文档。</p><p>其次，您可以使用Xdebug 2.1中引入的xdebug.remote_connect_back设置。</p><h2 id="实施细则"><a href="#实施细则" class="headerlink" title="实施细则"></a>实施细则</h2><p>Xdebug的DBGp协议的context_names命令的实现不依赖于栈级别。 在每个调试器会话期间返回的值总是相同的，因此，可以安全地缓存。</p><h2 id="相关的设置"><a href="#相关的设置" class="headerlink" title="相关的设置"></a>相关的设置</h2><h3 id="xdebug-extended-info"><a href="#xdebug-extended-info" class="headerlink" title="xdebug.extended_info"></a>xdebug.extended_info</h3><p>类型：整数，默认值：1</p><p>控制Xdebug是否应该为PHP解析器强制执行’extended_info’模式;这允许Xdebug使用远程调试器执行文件/行断点。当跟踪或剖析脚本时，通常希望关闭此选项，因为PHP生成的oparrays将增加大约三分之一的大小减慢脚本。此设置不能在带有ini_set（）的脚本中设置，但只能在php.ini中设置。</p><h3 id="xdebug-idekey"><a href="#xdebug-idekey" class="headerlink" title="xdebug.idekey"></a>xdebug.idekey</h3><p>类型：字符串，默认值：* complex *</p><p>控制哪个IDE密钥Xdebug应该传递到DBGp调试器处理程序。默认值基于环境设置。首先查询环境设置DBGP_IDEKEY，然后查询USER和最后一个USERNAME。默认值设置为找到的第一个环境变量。如果找不到，则设置为默认的“”。如果设置此设置，它始终覆盖环境变量。</p><h3 id="xdebug-remote-addr-header"><a href="#xdebug-remote-addr-header" class="headerlink" title="xdebug.remote_addr_header"></a>xdebug.remote_addr_header</h3><p>类型：字符串，默认值：“”，在Xdebug&gt; 2.4中引入</p><p>如果xdebug.remote_addr_header配置为非空字符串，那么该值将用作$ SERVER超全局数组中的键，以确定用于查找用于“连接回”的IP地址或主机名的头。此设置仅与xdebug.remote_connect_back结合使用，否则将被忽略。</p><h3 id="xdebug-remote-autostart"><a href="#xdebug-remote-autostart" class="headerlink" title="xdebug.remote_autostart"></a>xdebug.remote_autostart</h3><p>类型：布尔值，默认值：0</p><p>通常，您需要使用特定的HTTP GET / POST变量来启动远程调试（请参阅远程调试）。当此设置设置为1时，Xdebug将始终尝试启动远程调试会话并尝试连接到客户端，即使GET / POST / COOKIE变量不存在。</p><h3 id="xdebug-remote-connect-back"><a href="#xdebug-remote-connect-back" class="headerlink" title="xdebug.remote_connect_back"></a>xdebug.remote_connect_back</h3><p>类型：boolean，默认值：0，在Xdebug&gt; 2.1中引入</p><p>如果启用，xdebug.remote_host设置将被忽略，Xdebug将尝试连接到发出HTTP请求的客户端。它检查$_SERVER [‘HTTP_X_FORWARDED_FOR’]和$_SERVER [‘REMOTE_ADDR’]变量以找出要使用的IP地址。</p><p>如果配置了xdebug.remote_addr_header，那么将在$_SERVER [‘HTTP_X_FORWARDED_FOR’]和$_SERVER [‘REMOTE_ADDR’]变量之前检查具有配置名称的$ SERVER变量。</p><p>此设置不适用于通过CLI进行调试，因为$ SERVER标题变量在那里不可用。</p><p>请注意，没有可用的过滤器，任何可以连接到Web服务器的人都能够启动调试会话，即使他们的地址与xdebug.remote_host不匹配。</p><h3 id="xdebug-remote-cookie-expire-time"><a href="#xdebug-remote-cookie-expire-time" class="headerlink" title="xdebug.remote_cookie_expire_time"></a>xdebug.remote_cookie_expire_time</h3><p>类型：整数，默认值：3600，在Xdebug&gt; 2.1中引入</p><p>此设置可用于增加（或减少）远程调试会话通过会话cookie保持活动的时间。</p><h3 id="xdebug-remote-enable"><a href="#xdebug-remote-enable" class="headerlink" title="xdebug.remote_enable"></a>xdebug.remote_enable</h3><p>类型：布尔值，默认值：0</p><p>此开关控制Xdebug是否应尝试联系正在侦听主机上的调试客户端，并使用设置xdebug.remote_host和xdebug.remote_port设置的端口。如果无法建立连接，脚本将继续，就像此设置为0。</p><h3 id="xdebug-remote-handler"><a href="#xdebug-remote-handler" class="headerlink" title="xdebug.remote_handler"></a>xdebug.remote_handler</h3><p>类型：字符串，默认值：dbgp</p><p>可以是“php3”选择旧的PHP 3式调试器输出，“gdb”启用GDB像调试器接口或’dbgp’ - 调试器协议。 DBGp协议是唯一支持的协议。</p><p>注意：Xdebug 2.1和更高版本只支持’db​​gp’作为协议。</p><h3 id="xdebug-remote-host"><a href="#xdebug-remote-host" class="headerlink" title="xdebug.remote_host"></a>xdebug.remote_host</h3><p>类型：字符串，默认值：localhost<br>选择运行调试客户端的主机，您可以使用主机名或IP地址。如果启用xdebug.remote_connect_back，将忽略此设置。</p><h3 id="xdebug-remote-log"><a href="#xdebug-remote-log" class="headerlink" title="xdebug.remote_log"></a>xdebug.remote_log</h3><p>类型：字符串，默认值：</p><p>如果设置为某个值，则将其用作所有远程调试器通信记录到的文件的文件名。 该文件始终以附加模式打开，因此默认情况下不会被覆盖。 没有可用的并发保护。 该文件的格式如下：</p><pre><code>Log opened at 2007-05-27 14:28:15-&gt; &lt;init xmlns=&quot;urn:debugger_protocol_v1&quot; xmlns:xdebug=&quot;http://xdebug.org/dbgp/x ... ight&gt;&lt;/init&gt;&lt;- step_into -i 1-&gt; &lt;response xmlns=&quot;urn:debugger_protocol_v1&quot; xmlns:xdebug=&quot;http://xdebug.org/db ... &gt;&lt;/response&gt;</code></pre><h3 id="xdebug-remote-mode"><a href="#xdebug-remote-mode" class="headerlink" title="xdebug.remote_mode"></a>xdebug.remote_mode</h3><p>类型：字符串，默认值：req</p><p>选择启动调试连接的时间。 此设置可以有两个不同的值：</p><ul><li><p>req</p><blockquote><p>一旦脚本启动，Xdebug将尝试连接到调试客户端。</p></blockquote></li><li><p>jit</p><blockquote><p>Xdebug只会在出现错误情况时尝试连接到调试客户端。</p></blockquote></li></ul><h3 id="xdebug-remote-port"><a href="#xdebug-remote-port" class="headerlink" title="xdebug.remote_port"></a>xdebug.remote_port</h3><p>类型：整数，默认值：9000</p><p>Xdebug尝试在远程主机上连接的端口。 端口9000是客户端和捆绑的debugclient的默认值。 由于许多客户端使用此端口号，最好保持此设置不变。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="bool-xdebug-break（）"><a href="#bool-xdebug-break（）" class="headerlink" title="bool xdebug_break（）"></a>bool xdebug_break（）</h3><p>向调试客户端发出断点。</p><p>此函数使调试器在特定行上断开，就好像在此行上设置了正常的文件/行断点。</p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Xdebug为与运行PHP脚本交互的调试器客户端提供了一个接口。 本节介绍如何设置PHP和Xdebug来允许这一点，并介绍一些客户端。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>PHP程序调试之Xdebug</title>
    <link href="https://weizhimiao.github.io/2016/10/22/PHP%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%B9%8BXdebug/"/>
    <id>https://weizhimiao.github.io/2016/10/22/PHP%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%B9%8BXdebug/</id>
    <published>2016-10-22T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>$ tar -zxvf xdebug-2.4.1.tgz$ cd xdebug-2.4.1$ /usr/local/bin/phpize$ ./configure$ make$ make installInstalling shared extensions:     /usr/local/Cellar/php54/5.4.45_6/lib/php/extensions/no-debug-non-zts-20100525/</code></pre><p>在<code>/usr/local/Cellar/php54/5.4.45_6/lib/php/extensions/no-debug-non-zts-20100525/</code> 查看<code>xdebug.so</code>是否已经生成</p><p>注：<code>/usr/local/Cellar/php54/5.4.45_6/lib/php/extensions/no-debug-non-zts-20100525/</code> 不同的PHP版本路径不同，也不一定要放在该路径，可以在zend_extension_ts中自行指定xdebug.so所在位置。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改配置文件 php.ini</p><pre><code>[XDebug]  zend_extension =&quot;/usr/local/Cellar/php54/5.4.45_6/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so&quot;  xdebug.remote_handler=dbgp  ;开启远程调试  xdebug.remote_enable = On  ;远程主机  xdebug.remote_host=localhost  ;主机端口  xdebug.remote_port=9000  ;开启自动跟踪  xdebug.auto_trace = On  ;开启异常跟踪  xdebug.show_exception_trace = On  ;开启远程调试自动启动  xdebug.remote_autostart = On  ;收集变量   xdebug.collect_vars = On  ;收集返回值   xdebug.collect_return = On  ;收集参数   xdebug.collect_params = On  ;设定函数调用监测信息的输出文件的路径。;xdebug.trace_output_dir=&quot;/home/xdebug_log&quot;  ;显示局部变量  xdebug.show_local_vars = On  xdebug.profiler_enable = On  ;设定效能监测信息输出文件的路径。;xdebug.profiler_output_dir =&quot;/home/xdebug_log&quot;  xdebug.trace_enable_trigger =On  </code></pre><p>注：xdebug是一个zend扩展，所以要用zend_extension来加载，不能使用extensions来加载</p><p>运行<code>php -m</code>查看xdebug模块是否已经加载</p><h3 id="其他配置选项说明："><a href="#其他配置选项说明：" class="headerlink" title="其他配置选项说明："></a>其他配置选项说明：</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>xdebug.trace_output_dir</p><blockquote><p>日志追踪输出目录</p><p>类型：字符串，默认值：/tmp</p><p>确保php运行用户对该目录有写权限</p></blockquote><p>xdebug.trace_output_name</p><blockquote><p>日志文件名，xdebug提供了一系列的标识符，生成相应格式的文件名</p></blockquote><blockquote><p>类型: string, 默认值: trace.%c</p></blockquote><blockquote><p>此设置确定用于将跟踪转储到的文件的名称。 设置使用格式说明符指定格式，非常类似于sprintf（）和strftime（）。 有几个格式说明符可以用于格式化文件名。 “.xt”扩展名总是自动添加。</p></blockquote><p>可能的格式说明符是：</p><table><thead><tr><th>说明</th><th>含义</th><th>示例</th><th>对应文件名</th></tr></thead><tbody><tr><td>%c</td><td>crc32 of the current working directory</td><td>trace.%c</td><td>trace.1258863198.xt</td></tr><tr><td>%p</td><td>pid</td><td>trace.%p</td><td>trace.5174.xt</td></tr><tr><td>%r</td><td>random number</td><td>trace.%r</td><td>trace.072db0.xt</td></tr><tr><td>%s</td><td>script name</td><td>cachegrind.out.%s</td><td>cachegrind.out._home_httpd_html_test_xdebug_test_php</td></tr><tr><td>%t</td><td>timestamp (seconds)</td><td>trace.%t</td><td>trace.1179434742.xt</td></tr><tr><td>%u</td><td>timestamp (microseconds)</td><td>trace.%u</td><td>trace.1179434749_642382.xt</td></tr><tr><td>%H</td><td>$_SERVER[‘HTTP_HOST’]</td><td>trace.%H</td><td>trace.kossu.xt</td></tr><tr><td>%R</td><td>$_SERVER[‘REQUEST_URI’]</td><td>trace.%R</td><td>trace._test_xdebug_test_php_var=1_var2=2.xt</td></tr><tr><td>%U</td><td>$_SERVER[‘UNIQUE_ID’] 3</td><td>trace.%U</td><td>trace.TRX4n38AAAEAAB9gBFkAAAAB.xt</td></tr><tr><td>%S</td><td>session_id (from $_COOKIE if set)</td><td>trace.%S</td><td>trace.c70c1ec2375af58f74b390bbdd2a679d.xt</td></tr><tr><td>%%</td><td>literal %</td><td>trace.%%</td><td>trace.%%.xt</td></tr></tbody></table><p>xdebug.trace_options</p><blockquote><p>记录添加到文件中方式：</p></blockquote><blockquote><p>类型：整数，默认值：0</p></blockquote><blockquote><p>当设置为’1’时，跟踪文件将被附加到，而不是在后续请求中被覆盖。</p></blockquote><h4 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h4><p>xdebug.collect_params</p><blockquote><p>类型：整数，默认值：0</p></blockquote><blockquote><p>此设置默认为0，控制function的参数显示选项</p></blockquote><ul><li>0    不显示.</li><li>1    参数类型，值  (例如：array(9))</li><li>2    同上1，只是在CLI模式下略微有区别</li><li>3    所有变量内容</li><li>4    所有变量内容和变量名(例如：array(0 =&gt; 9))</li><li>5    PHP序列化变量内容，没有名称。 （Xdebug 2.3中的新功能）</li></ul><p>xdebug.collect_return</p><blockquote><p>类型：布尔值，默认值：0</p></blockquote><blockquote><p>此设置默认为0，控制Xdebug是否应将函数调用的返回值写入跟踪文件。</p></blockquote><blockquote><p>对于计算机化的跟踪文件（xdebug.trace_format = 1），这只能从Xdebug 2.3起。</p></blockquote><p>xdebug.collect_vars</p><blockquote><p>类型：布尔值，默认值：0</p></blockquote><blockquote><p>此设置告诉Xdebug收集有关在某个范围中使用哪些变量的信息。 这个分析可能很慢，因为Xdebug必须逆向工程PHP的操作码数组。 此设置不会记录不同变量具有的值，因为使用xdebug.collect_params。 仅当您希望使用xdebug_get_declared_vars（）时，才需要启用此设置。</p></blockquote><blockquote><p>显示当前作用域使用了哪些变量，显示变量名，该选项不会记录变量的值，如果需要，使用xdebug.collect_params</p></blockquote><p>xdebug.collect_assignments</p><blockquote><p>类型：boolean，默认值：0，在Xdebug&gt; 2.1中引入</p></blockquote><blockquote><p>此设置（默认为0）控制Xdebug是否应向函数轨迹添加变量分配。</p></blockquote><blockquote><p>1 = 添加一行显示变量赋值（若为1，形如$a = 1;这类Assignment Expression会在trace文件里显示）</p></blockquote><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>xdebug.trace_format</p><blockquote><p>类型：整数，默认值：0</p></blockquote><blockquote><ul><li>0 = 人可读. 从左至右每列分别表示：时间点, 内存, 内存差 (需要设置xdebug.show_mem_delta=1), 等级, 函数名,函数参数 (需要设置，xdebug.collect_params=1，只要是非零), 当前代码行所在文件名 , 行号;</li><li>1 = 机器可读[1]. 需要借助第三方app，例如：xdebug trace file parser 或者 xdebug trace viewer; 2 = html格式 即table，用browser打开，显示table</li></ul></blockquote><p>xdebug.show_mem_delta</p><blockquote><p>类型：整数，默认值：0</p></blockquote><blockquote><p>当这个设置设置为某些！= 0 Xdebug的人类可读的生成的跟踪文件将显示在函数调用之间的内存使用的差异。 如果Xdebug配置为生成计算机可读的跟踪文件，则它们将始终显示此信息。</p></blockquote><blockquote><ul><li>1 = 显示每次函数调用内存消耗（内存差）</li></ul></blockquote><h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p>xdebug.auto_trace</p><blockquote><p>类型：布尔值，默认值：0</p></blockquote><blockquote><p>当此设置设置为on时，将在脚本运行之前启用函数调用的跟踪。 这使得可以跟踪auto_prepend_file中的代码。</p></blockquote><blockquote><p>1 = 打开自动追踪. （追踪方式有2种，一种是自动追踪，所有php脚本运行时，都会产生trace文件；另一种是触发方式追踪，如下）</p></blockquote><p>xdebug.trace_enable_trigger[2]</p><blockquote><p>类型：boolean，默认值：0，在Xdebug&gt; 2.2中引入</p></blockquote><blockquote><p>当此设置设置为1时，可以使用XDEBUG_TRACE GET / POST参数触发跟踪，或者设置名为XDEBUG_TRACE的cookie。 然后将跟踪数据写入定义的目录。 为了防止Xdebug为每个请求生成跟踪文件，您需要将xdebug.auto_trace设置为0.对触发器本身的访问可以通过xdebug.trace_enable_trigger_value配置。</p></blockquote><blockquote><p>1 = 使用 XDEBUG_TRACE GET/POST 触发追踪, 或者通过设置cookie XDEBUG_TRACE. 为了避免每次请求时，都会生成相应trace追踪文件，你需要把auto_trace设置为0</p></blockquote><blockquote><p>注：该特性只在2.2+版本才能设置<br>[xdebug-general] Re: Is trace_enable_trigger defunct?</p></blockquote><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>xdebug.var_display_max_depth</p><blockquote><p>类型：整数，默认值：3</p></blockquote><blockquote><p>当使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时，控制数组元素和对象属性的嵌套级别数。</p></blockquote><blockquote><p>您可以选择的最大值为1023.您还可以使用-1作为值来选择此最大数。</p></blockquote><blockquote><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p></blockquote><blockquote><p>数组和对象元素显示深度：主要用在数组嵌套，对象属性嵌套时，显示几级的元素内容. Default 3.</p></blockquote><p>xdebug.var_display_max_data</p><blockquote><p>变量值为字符串时显示多长. Default 512.</p></blockquote><blockquote><p>类型：整数，默认值：512<br>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的最大字符串长度。</p></blockquote><blockquote><p>要禁用任何限制，请使用-1作为值。</p></blockquote><blockquote><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p></blockquote><p>xdebug.var_display_max_children</p><blockquote><p>数组和对象元素显示的个数. Default 128</p></blockquote><blockquote><p>类型：整数，默认值：128<br>控制使用xdebug_var_dump（），xdebug.show_local_vars或通过函数跟踪显示变量时显示的数组子元素和对象的属性的数量。</p></blockquote><blockquote><p>要禁用任何限制，请使用-1作为值。</p></blockquote><blockquote><p>此设置对通过远程调试功能发送到客户端的子项数没有任何影响。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一些常用到的xdebug函数</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>void xdebug_enable()</td><td>手动打开，相当于xdebug.default_enable=on</td></tr><tr><td>void var_dump()</td><td>覆写php提供的var_dump，出错时，显示函数堆栈信息，（前提：php.ini里html_errors为1），使用xdebug.overload_var_dump 设置是否覆写</td></tr><tr><td>void xdebug_start_trace( string trace_file_path [, integer options] )</td><td>手动控制需要追踪的代码段 trace_file_path ：文件路径（相对或绝对，若为空）.如果为空，或者不传参， 使用xdebug.trace_output_dir设置的目录options ：XDEBUG_TRACE_APPEND: 1 = 追加文件内容末尾, 0 = 覆写该文件 XDEBUG_TRACE_COMPUTERIZED:2 =同 xdebug.trace_format=1 .XDEBUG_TRACE_HTML: 4 = 输出HTML表格，浏览器打开为一table</td></tr><tr><td>void xdebug_stop_trace()</td><td>停止追踪，代码追踪在该行停止</td></tr><tr><td>string xdebug_get_tracefile_name()</td><td>获得输出文件名，与 xdebug.auto_trace配合使用.</td></tr><tr><td>void xdebug_var_dump([mixed var[,…]])</td><td>输出变量详细信息，相当于php里的var_dump，具体显示请看这里xdebug.show_local_vars     默认为0，不显示；非零时，在php执行出错时，显示出错代码所在作用域所有本地变量（注：这会产生大量信息，因此默认是closed），具体显示差别如下图[3]</td></tr><tr><td>array xdebug_get_declared_vars()</td><td>显示当前作用域中已声明的变量</td></tr><tr><td>array xdebug_get_code_coverage()</td><td>显示某一段代码内，代码执行到哪些行[4]</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="Xdebug" scheme="https://weizhimiao.github.io/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>apache上运行PHP的几种方式汇总</title>
    <link href="https://weizhimiao.github.io/2016/10/21/apache%E4%B8%8A%E8%BF%90%E8%A1%8CPHP%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/10/21/apache%E4%B8%8A%E8%BF%90%E8%A1%8CPHP%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB/</id>
    <published>2016-10-21T14:40:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>之前也有整理过一篇 「apache中PHP的几种支持模式」的blog，但是感觉还是比较混乱，很多问题没有理清楚，一些方式也没有整理到。所以今天通过这篇blog再整理一下。</p><ul><li><p>Using proxy_fcgi and php-fpm (for apache 2.4)</p></li><li><p>Using php with fastcgi (for 2.2 and older)</p></li><li><p>Using php with fcgid (for 2.2 and older)</p></li><li><p>Using mod_php as a DSO with a threaded mpm (2.0 and newer)</p></li><li><p>Using mod_php as a DSO (deprecated)</p></li></ul><span id="more"></span><h2 id="Using-proxy-fcgi-and-php-fpm-for-apache-2-4"><a href="#Using-proxy-fcgi-and-php-fpm-for-apache-2-4" class="headerlink" title="Using proxy_fcgi and php-fpm (for apache 2.4)"></a>Using proxy_fcgi and php-fpm (for apache 2.4)</h2><p>此方法优先于所有其他方案，适用于Apache 2.4及更高版本。 它还允许线程mpm，如event或worker，这将显著减少对服务器的RAM需求。</p><p>详情见<a href="https://weizhimiao.github.io/2016/10/20/High-performance%20PHP%20on%20apache%20httpd%202.4.x%20using%20mod_proxy_fcgi%20and%20php-fpm/">httpd 2.4.x上使用mod_proxy_fcgi和php-fpm实现高性能PHP</a></p><h2 id="Using-php-with-fastcgi-for-2-2-and-older"><a href="#Using-php-with-fastcgi-for-2-2-and-older" class="headerlink" title="Using php with fastcgi (for 2.2 and older)"></a>Using php with fastcgi (for 2.2 and older)</h2><p>此方法适用于2.2及更高版本。 它还允许线程mpm，如event或worker，这将显著减少对服务器的RAM需求。</p><p>本文的范围是讨论使用Apache httpd 2.2和php的可能配置。在大多数情况下使用mod_php不是一个可行的解决方案，因为它引入了对每个httpd进程增加的RAM需求的可扩展性问题。另外，此外，它排除了使用线程MPM，因为php扩展在许多情况下不是线程安全的。</p><p>理想的配置是轻线程httpd进程，与外部fastcgi服务器（如PHP-FPM）通信。</p><p>第一个使用mod_fastcgi的方案</p><pre><code>Alias /php5.fcgi /var/www/fcgi/php5.fcgiFastCGIExternalServer /var/www/fcgi/php5.fcgi -flush -host 127.0.0.1:9000# 创建一个新的处理程序名称并将其用于PHP文件AddHandler my-fastcgi .php#  *.php的请求实际上作为参数馈送到php-fastcgiAction my-fastcgi /php5.fcgi&lt;Directory &quot;/var/www/fcgi/&quot;&gt;  Order deny,allow  Deny from all  &lt;Files &quot;php5.fcgi&quot;&gt;    Order allow,deny    Allow from all  &lt;/Files&gt;&lt;/Directory&gt;</code></pre><h2 id="Using-php-with-fcgid-for-2-2-and-older"><a href="#Using-php-with-fcgid-for-2-2-and-older" class="headerlink" title="Using php with fcgid (for 2.2 and older)"></a>Using php with fcgid (for 2.2 and older)</h2><p>此方法适用于2.0或2.2版本。 它允许线程mpm，如worker，这将显着减少您的服务器上的RAM要求。 而mod_fcgid是一个官方的Apache模块。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why ?"></a>Why ?</h3><ul><li>因为mod_php迫使你加载prefork MPM，这是低效的。</li><li>因为mod_php将被加载到httpd内存中，即使在服务静态页面</li><li>2013年发布的大多数发行版提供了预编译的包，让您可以使用fcgi运行php。 这只是一个配置问题。</li><li>mod_fcgid是一个官方Apache模块，可在 <a href="http://httpd.apache.org/mod_fcgid/">http://httpd.apache.org/mod_fcgid/</a> 查看</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>巨大的性能提升，在CPU和内存消耗</li><li>PHP运行在一个单独的进程</li></ul><h3 id="不在fcgid上运行php的情况"><a href="#不在fcgid上运行php的情况" class="headerlink" title="不在fcgid上运行php的情况"></a>不在fcgid上运行php的情况</h3><p>如果你运行httpd 2.4，你应该考虑<a href="http://wiki.apache.org/httpd/PHP-FPM">PHP-FPM</a></p><h3 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h3><p>按照所有步骤，或许最终会丢失一些东西。</p><p>1、摆脱mod_php。 你需要从你的配置中注释掉“LoadModule php5_module”。<br>在debian上，只要运行“apt-get remove libapache2-mod-php5”</p><p>2、Install mod_fcgid<br>在 debian上, “apt-get install libapache2-mod-fcgid”</p><p>3、Install PHP as CGI<br>在 debian上, “apt-get install php5-cgi”</p><p>编写一个小封装包，例如：/usr/local/bin/php-wrapper</p><pre><code>#!/bin/sh# Set desired PHP_FCGI_* environment variables.# Example:# PHP FastCGI processes exit after 1000 requests by default.PHP_FCGI_MAX_REQUESTS=1000export PHP_FCGI_MAX_REQUESTS# Replace with the path to your FastCGI-enabled PHP executableexec /usr/lib/cgi-bin/php5</code></pre><p>确保它是可读的和可执行的apache user/group.</p><p>5、修改配置 httpd.conf</p><pre><code>LoadModule fcgid_module /usr/lib/apache2/modules/mod_fcgid.soAddHandler fcgid-script .phpFcgidWrapper /usr/local/bin/php-wrapper .php</code></pre><p>6、用多线程MPM替换prefork MPM，例如worker。</p><p>在debian上，只需运行“apt-get install apache2-mpm-worker”</p><h3 id="常见问题-It-doesn’t-work"><a href="#常见问题-It-doesn’t-work" class="headerlink" title="常见问题/It doesn’t work"></a>常见问题/It doesn’t work</h3><p>不要惊慌。 检查apache错误日志。</p><p>PHP文件被下载，不解释<br>PHP files are downloaded, not interpreted</p><p>If you have a handler already set for PHP, it may be conflicting. So you can try something like : “grep -ri handler /etc/httpd | grep php” depending on the result, you may need to comment out some config you are having.</p><p>如果您已经为PHP设置了处理程序，则可能会发生冲突。 所以你可以尝试类似：“grep -ri handler /etc/httpd | grep php”根据结果，你可能需要注释掉一些存在配置。</p><h3 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h3><p>请参考： <a href="http://httpd.apache.org/mod_fcgid/mod/mod_fcgid.html#upgrade">http://httpd.apache.org/mod_fcgid/mod/mod_fcgid.html#upgrade</a></p><h2 id="Using-mod-php-as-a-DSO-with-a-threaded-mpm-2-0-and-newer"><a href="#Using-mod-php-as-a-DSO-with-a-threaded-mpm-2-0-and-newer" class="headerlink" title="Using mod_php as a DSO with a threaded mpm (2.0 and newer)"></a>Using mod_php as a DSO with a threaded mpm (2.0 and newer)</h2><p>这种方法与下一个配方相同，只是可以使用event或worker等线程化的mpm。主要的要求是php系统库和DSO必须用线程安全标志（重新）编译。</p><p>如果使用apache httpd 2.0或更早版本，必须重新编译才能更改mpm。 对于2.4，加载适当的mpm模块后缀。</p><p>必须特别注意确保工作程序经常重启（MaxConnectionsPerChild&gt; 0），因为子进程仍然容易出现php内存泄漏，并且进程可能消耗大量RAM并耗尽可用的系统资源。</p><p>这可能是所有最少使用的方法，由于维护一个线程安全的php库是一件非常头痛的事，并且因为大多数linux发行版不发运这些包。</p><h2 id="Using-mod-php-as-a-DSO-deprecated"><a href="#Using-mod-php-as-a-DSO-deprecated" class="headerlink" title="Using mod_php as a DSO (deprecated)"></a>Using mod_php as a DSO (deprecated)</h2><p>此方法是最早和可能是最慢的配置。 它适合2.2版本和更旧，并要求使用prefork mpm。</p><h3 id="为什么你不应该使用mod-php与prefork-mpm了"><a href="#为什么你不应该使用mod-php与prefork-mpm了" class="headerlink" title="为什么你不应该使用mod_php与prefork mpm了"></a>为什么你不应该使用mod_php与prefork mpm了</h3><ul><li>mod_php始终加载到每个httpd进程中。 即使当httpd服务静态/非php内容。</li><li>mod_php不是线程安全的，并且迫使你坚持使用prefork mpm（多进程，没有线程），这可能是最慢的配置</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>首先，必须加载模块：</p><pre><code>LoadModule php5_module lib/httpd/modules/libphp5.so</code></pre><p>然后，添加dso的处理程序：</p><pre><code># Then, configure the handler for all files that end with .php# A regexp such as \.(php|php4|php5)$ can also be used to support more extensions&lt;FilesMatch \.php$&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>参考:</p><p><a href="http://www.php.net/manual/en/install.unix.apache2.php">官方php安装和配置说明</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前也有整理过一篇 「apache中PHP的几种支持模式」的blog，但是感觉还是比较混乱，很多问题没有理清楚，一些方式也没有整理到。所以今天通过这篇blog再整理一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using proxy_fcgi and php-fpm (for apache 2.4)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using php with fastcgi (for 2.2 and older)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using php with fcgid (for 2.2 and older)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using mod_php as a DSO with a threaded mpm (2.0 and newer)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using mod_php as a DSO (deprecated)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
  </entry>
  
  <entry>
    <title>httpd 2.4.x上使用mod_proxy_fcgi和php-fpm实现高性能PHP</title>
    <link href="https://weizhimiao.github.io/2016/10/20/High-performance%20PHP%20on%20apache%20httpd%202.4.x%20using%20mod_proxy_fcgi%20and%20php-fpm/"/>
    <id>https://weizhimiao.github.io/2016/10/20/High-performance%20PHP%20on%20apache%20httpd%202.4.x%20using%20mod_proxy_fcgi%20and%20php-fpm/</id>
    <published>2016-10-20T14:40:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>内容</p><ul><li>apache httpd 2.4.x上使用mod_proxy_fcgi和php-fpm实现高性能PHP<ul><li>php-fpm</li><li>apache httpd 2.4<ul><li>TCP套接字（IP和端口）方法</li><li>unix域套接字（UDS）方法</li><li>通过代理程序处理</li><li>先睹为快<ul><li>一个简单的例子</li><li>一个更灵活的例子</li></ul></li><li>性能和陷阱</li><li>警告</li></ul></li></ul></li></ul><span id="more"></span><p>apache httpd 2.4.x上使用mod_proxy_fcgi和php-fpm实现高性能PHP</p><p>随着apache httpd 2.4的发布，我们已经获得了一些非常整洁的功能关于apache和php：运行PHP作为一个fastCGI进程服务器的能力，并且这个fastCGI服务器可以直接从apache中通过一个专用的模块代理来实现 （mod_proxy_fcgi.）</p><blockquote><p>从2010年初的版本5.3.3开始，PHP已经将php-fpm fastCGI进程管理器合并到其代码库中，现在（从5.4.1开始）相当稳定。<br>php-fpm ， <a href="http://php-fpm.org/">http://php-fpm.org/</a></p></blockquote><p>这意味着我们现在可以运行安全，快速和可靠的PHP代码，只给apache httpd和php.net版本使用; 没有更多的混乱像suphp、suexec 或者 mod_php。</p><h2 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h2><p>准备：</p><ul><li><p>安装软件包</p></li><li><p>编辑配置文件</p></li><li><p>控制服务守护程序。</p></li></ul><p>从5.3.3版本开始，PHP现在在源代码中包括fastCGI进程管理器（php-fpm）。<br>您的发行版或操作系统将其包含在库存PHP包中，或将其作为附加包提供;<br>我们可以通过向./configure选项添加“–enable-fpm”从源代码构建它。</p><p>这为我们提供了一个新的二进制文件，称为php-fpm，一个名为php-fpm.conf的默认配置文件安装在/ etc中。</p><p>此文件中的默认值是可以启动的，但请注意，你在本地安装的时候可能会有修改，其位置也可能会变。</p><p>在这个配置文件中，您可以创建任意数量的fastcgi“池”，这些池由它们侦听的IP和端口定义，就像apache虚拟主机一样。</p><p>每个池中最重要的设置是TCP套接字（IP和端口）或unix域套接字（UDS）php-fpm将监听接收fastCGI请求; 这是使用listen选项配置的。</p><p>默认池[www]，配置为listen 127.0.0.1:9000：它将只响应本地环回网络接口（localhost）上的请求，在TCP端口9000上。</p><p>另外，有趣的是 per-pool 的user和group选项，他们允许在指定的uid和gid下运行特定的fpm池。再见 suphp！</p><p>让我们使用默认值作为运行并启动php-fpm守护进程; 如果您的发行版使用提供的init脚本，请运行</p><pre><code>/etc/init.d/php-fpm start</code></pre><p>如果没有，请手动启动</p><pre><code>php-fpm -y /path/to/php-fpm.conf -c /path/to/custom/php.ini</code></pre><p>如果你不提供php-fpm自己的php.ini文件，将使用全局php.ini。记住这一点，当你想要包括更多或更少的扩展比如CLI或CGI二进制使用，或需要改变一些其他值。</p><p>你可以使用php [admin]（flag | value）以同样的方式包含每个池的php.ini值，方法与以前在apache中为mod_php定义的一样。</p><p>有关所有可能的配置选项，请<a href="http://www.php.net/manual/en/install.fpm.configuration.php">参阅fpm的官方PHP文档</a>。</p><p>更改php-fpm.conf的loging选项，方便我们查看错误信息</p><pre><code>error_log /var/log/php-fpm.log</code></pre><p>如果不设置php-fpm日志文件，将按照php.ini中定义的方式记录错误。</p><blockquote><p>note:我们可以强制 php-fpm 重新加载它的配置文件，通过想php-fpm发送 SIGUSR2 信号。SIGUSR1将循环日志文件（完美的logrotate脚本！）一些实验很漫长</p></blockquote><p>注意：如果php-fpm在启动的时候没有出现报错，那么它就已经在监听端口等待连接了。</p><h2 id="apache-httpd-2-4"><a href="#apache-httpd-2-4" class="headerlink" title="apache httpd 2.4"></a>apache httpd 2.4</h2><p>准备：</p><ul><li><p>编辑httpd.conf</p></li><li><p>理解vhost上下文</p></li><li><p>理解URL到文件系统命名空间映射</p></li><li><p>控制apache httpd守护进程</p></li></ul><p>这个版本的apache httpd引入了两个值得注意的特性：一个新的代理模块专门用于fastCGI（mod_proxy_fcgi），并将 event MPM作为默认的apache进程管理器。</p><p>与以前版本的worker MPM一样，当使用非线程安全的第三方PHP扩展时，此MPM的线程模型会导致问题。</p><p>自从apache 2.2发布以来，这已经成为mod_php用户的一个祸根，实际上迫使他们将fastcgi解决方案拼凑在一起，或者使用更慢和内存饥饿的prefork MPM。</p><p>要使用PHP fastCGI进程管理器工作，我们将使用一个新模块mod_proxy_fcgi，该模块专用于与（可能是外部）fastCGI服务器通信。</p><p>确保您在httpd.conf中包含proxy_fcgi模块，以便我们可以使用其功能; 因为这需要基本代理模块，请确保两者都加载（取消注释）：</p><pre><code>LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so</code></pre><p>现在，有不同的方法实际转发请求的.php文件到这个模块，从转发所有的请求（使用ProxyPass），到只转发非常特定，或者通过重写文件或模式（使用带有[P]标志的mod_rewrite）的方法。</p><p>我们选择介于复杂性和灵活性之间的方法（使用ProxyPassMatch），因为它允许您为特定vhost的所有PHP内容设置一个规则，但只会代理.php文件（或包含.php的urls）。</p><h3 id="TCP套接字（IP和端口）方法"><a href="#TCP套接字（IP和端口）方法" class="headerlink" title="TCP套接字（IP和端口）方法"></a>TCP套接字（IP和端口）方法</h3><p>编辑所选主机的配置，并向其中添加以下行：</p><pre><code>ProxyPassMatch ^/(.*\.php(/.*)?)$ fcgi://127.0.0.1:9000/path/to/your/documentroot/$1DirectoryIndex /index.php index.php</code></pre><p>说明：<br>ProxyPassMatch</p><blockquote><p>只有与指定的正则表达式模式匹配的代理内容; 在这种情况下：</p></blockquote><p>^/(.*.php(/.*)?)$</p><blockquote><p>从文档根开始，匹配以.php结尾的所有内容（使用点转义），可选地后跟一个斜杠和您喜欢的任何继续路径（一些应用程序使用这个所谓的PathInfo将参数传递给php脚本）。</p></blockquote><blockquote><p>^和$符号用于锚定URL的绝对开始和结束，以确保请求中的任何字符都不会转义我们的模式匹配。</p></blockquote><blockquote><p>嵌套括号使我们能够将整个请求URI（减去前导斜杠）引用为$ 1，同时仍然保持尾随pathinfo可选。</p></blockquote><p>fcgi://127.0.0.1:9000</p><blockquote><p>通过mod_proxy_fcgi，使用fastCGI协议，转发到我们的php-fpm守护程序正在侦听的端口。<br>这确定哪个fastcgi池将服务由此规则代理的请求。</p></blockquote><p>/path/to/your/documentroot/</p><blockquote><p><strong>重要！</strong>  这必须与您的php文件的真实文件系统位置完全匹配，因为这是php-fpm守护程序将查找它们的位置。<br>php-fpm只是解释传递给它的php文件; 它不是一个Web服务器，也不了解您的Web服务器的命名空间，虚拟主机布局或别名。</p><p><strong>重要！</strong>  请再看一遍以上内容</p></blockquote><p>$1</p><blockquote><p>从原始请求扩展到整个请求URI，减去前导斜杠（因为我们已经添加了上面的。）</p></blockquote><p>DirectoryIndex /index.php index.php</p><blockquote><p>对根目录/的请求，需要用默认索引文件映射到fcgi上。</p></blockquote><blockquote><p>没有解决这个问题可能导致一个空白响应，通常被称为WSOD（死亡白屏），特别是如果仅代理包含php扩展名的请求URI，如本示例。</p></blockquote><blockquote><p>处理流程将首先将针对/的请求映射到/index.php或相对于当前请求uri的任何其他index.php文件，然后正确地代理到PHP-FPM后端。</p></blockquote><h3 id="unix域套接字（UDS）方法"><a href="#unix域套接字（UDS）方法" class="headerlink" title="unix域套接字（UDS）方法"></a>unix域套接字（UDS）方法</h3><p>编辑所选主机的配置，并向其中添加以下行：</p><pre><code>ProxyPassMatch ^/(.*\.php(/.*)?)$ unix:/path/to/socket.sock|fcgi://127.0.0.1:9000/path/to/your/documentroot/</code></pre><p>unix:/path/to/socket.sock</p><blockquote><p>您的fpm套接字的路径</p><p><strong>请注意</strong>，使用此方法，捕获的请求URI（$ 1）不会在路径之后传递</p></blockquote><h3 id="Proxy-via-handler-通过代理程序处理"><a href="#Proxy-via-handler-通过代理程序处理" class="headerlink" title="Proxy via handler(通过代理程序处理)"></a>Proxy via handler(通过代理程序处理)</h3><p>使用这种方法，您可以在代理到php-fpm后端之前检查资源的存在。</p><pre><code>＃定义工作器将提高性能＃在这种情况下，重新使用worker（依赖于fcgi应用程序的支持）＃如果你有足够的空闲工作，这只会略微提高性能&lt;Proxy &quot;fcgi://localhost:9000/&quot; enablereuse=on max=10&gt;&lt;/Proxy&gt;&lt;FilesMatch &quot;\.php$&quot;&gt;    # 选择以下方法之一    # 1、使用标准的TCP套接字    # SetHandler &quot;proxy:fcgi://localhost:9000&quot;    # 2、如果您的版本的httpd是2.4.9或更新版本（或具有后端功能），您可以使用unix域套接字    # SetHandler &quot;proxy:unix:/path/to/app.sock|fcgi://localhost:9000&quot;&lt;/FilesMatch&gt;</code></pre><h3 id="For-the-impatient"><a href="#For-the-impatient" class="headerlink" title="For the impatient"></a>For the impatient</h3><h4 id="Very-simple-example"><a href="#Very-simple-example" class="headerlink" title="Very simple example"></a>Very simple example</h4><p>首先, 创建一个文件/var/www/info.php 内容如下:</p><pre><code>&lt;?php phpinfo() ?&gt;</code></pre><p>假设/ var / www是现有vhost的DocumentRoot。</p><p>在此vhost内，添加以下行：</p><pre><code>ProxyPassMatch ^/info$ fcgi://127.0.0.1:9000/var/www/info.php</code></pre><p>使用apachectl优雅重新加载apache，您现在可以使用<a href="http://example.com/info%E8%B0%83%E7%94%A8phpinfo%E9%A1%B5%E9%9D%A2">http://example.com/info调用phpinfo页面</a></p><p>这是一个非常简单的示例，将一个唯一的URL映射到单个PHP文件。</p><h4 id="A-more-flexible-example"><a href="#A-more-flexible-example" class="headerlink" title="A more flexible example"></a>A more flexible example</h4><p>要使用其真实的php文件位置将vhost中的所有.php文件代理到fcgi服务器，您可以使用更灵活的匹配：</p><pre><code>ProxyPassMatch ^/(.*\.php)$ fcgi://127.0.0.1:9000/var/www/$1</code></pre><p>同样，假设/ var / www是所讨论的vhost的DocumentRoot.</p><p>Reload apache with apachectl graceful and you can now call up the phpinfo page using <a href="http://example.com/yourscript.php">http://example.com/yourscript.php</a><br>使用apachectl优雅重新加载apache，您现在可以使用<a href="http://example.com/yourscript.php%E8%B0%83%E7%94%A8phpinfo%E9%A1%B5%E9%9D%A2">http://example.com/yourscript.php调用phpinfo页面</a></p><h3 id="性能和陷阱"><a href="#性能和陷阱" class="headerlink" title="性能和陷阱"></a>性能和陷阱</h3><p>mod_proxy_fcgi现在支持unix域套接字自2.4.9（ [Unix域套接字支持mod_proxy_fcgi](<a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=54101%EF%BC%89%EF%BC%89">https://issues.apache.org/bugzilla/show_bug.cgi?id=54101））</a></p><p>这是很容易占满你的系统的可用套接字，通过ulimits等等。一些提示，以避免这一点：</p><p>使用太多的套接字将导致apache给出一个（（(99)Cannot assign requested address:）的错误。 这意味着您的操作系统不允许创建新的套接字。</p><p>在linux上，可以使用/ proc / sys / net / ipv4 / tcp_tw_reuse 建立尽可能多的套接字，但是在NAT之后将会出现很多有关使用这些套接字的警告。</p><p>确保修改ulimit并允许apache用户和php-fpm用户都有足够的打开文件和进程。 ulimit -n 和 ulimit -u（nofile，最大文件打开数＆nproc，最大进程数）</p><p>如果php-fpm没有足够大的nproc（最大进程数），它将退出（代码255，没有php 5.3的附加信息），没有附加消息。</p><p>如果php-fpm没有足够大的nofile（最大文件打开数），你可能无法获得每个子进程的日志记录，如上所示。 它会在一般的错误日志中给出。</p><p>如果apache和php-fpm作为同一用户运行（不必要或不推荐），且nproc太小，apache将无法启动，并显示以下消息（11）Resource temporarily unavailable：AH02162：setuid: unable to change to uid: 600</p><p><strong>警告：</strong> 当ProxyPass向另一个服务器（在这种情况下，php-fpm守护程序）的请求，身份验证限制和放置在目录块或.htaccess文件中的其他配置可能被绕过。</p><h3 id="Caveats（警告）"><a href="#Caveats（警告）" class="headerlink" title="Caveats（警告）"></a>Caveats（警告）</h3><p>有人可能会指出，贪婪的ProxyPassMatch伪指令可能允许由HTTP客户端上传的某些恶意内容。</p><p>这不是一个全面的安全文件，而是将指出一个可能的注入向量，可以从本文档中的指令生成。</p><p>例如，</p><pre><code>/uploads/malicious.jpg/lalalaalala.php</code></pre><p>将导致php-fpm处理该文件（/uploads/malicious.jpg），并且没有某些健全性检查，可能导致被攻击的服务器。</p><p>这当然不推荐。 使用php上传的内容应该安全地保存在DocumentRoot之外，并且应该仔细检查pathinfo。</p><p>此外，php-fpm应检查是否允许调用脚本。</p><p>如果这样的限制不能容易地实现，则可以在用RewriteCond或FallbackResource在代理之前执行检查，以确保URI不被HTTP客户端改变。</p><p><a href="http://wiki.apache.org/httpd/PHP-FPM">【原文】</a></p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apache httpd 2.4.x上使用mod_proxy_fcgi和php-fpm实现高性能PHP&lt;ul&gt;
&lt;li&gt;php-fpm&lt;/li&gt;
&lt;li&gt;apache httpd 2.4&lt;ul&gt;
&lt;li&gt;TCP套接字（IP和端口）方法&lt;/li&gt;
&lt;li&gt;unix域套接字（UDS）方法&lt;/li&gt;
&lt;li&gt;通过代理程序处理&lt;/li&gt;
&lt;li&gt;先睹为快&lt;ul&gt;
&lt;li&gt;一个简单的例子&lt;/li&gt;
&lt;li&gt;一个更灵活的例子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能和陷阱&lt;/li&gt;
&lt;li&gt;警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="PHP-FPM" scheme="https://weizhimiao.github.io/tags/PHP-FPM/"/>
    
    <category term="mod_proxy_fcgi" scheme="https://weizhimiao.github.io/tags/mod-proxy-fcgi/"/>
    
  </entry>
  
  <entry>
    <title>PHP常见设计模式之策略模式</title>
    <link href="https://weizhimiao.github.io/2016/10/19/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/10/19/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-10-19T14:40:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式允许类的使用者为这个类根据需要注入不同的依赖。通常情况下，这些依赖表现为对象、闭包或者回调方式，他们完成类所必要的要求以执行预期行为。</p><span id="more"></span><h2 id="UML设计"><a href="#UML设计" class="headerlink" title="UML设计"></a>UML设计</h2><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161020/CeLueMoShi-YiLaiZhuRu.png" alt="策略模式"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于每一个依赖，我们可以指定一个setter方法（添加一个getter方法更好），它将接收可以满足依赖要求的参数。</p><p>示例：使用策略设计模式实现一个日志类</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Log</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">protected</span> <span class="token variable">$engine</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$logArr</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">engine</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span> <span class="token string">"unable to write log. no engine set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$logArr</span><span class="token punctuation">[</span><span class="token string">'datetime'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">engine</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$logArr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">setEngine</span><span class="token punctuation">(</span>Log_Engine_Interface <span class="token variable">$engin</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">engine</span> <span class="token operator">=</span> <span class="token variable">$engin</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">engine</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们用Log类，传入我们希望使用的任何一种数据存储引擎。</p><p>我们先定义一个接口或者抽象类，通过接口或者类的类型提示，确保每个驱动程序都符合要求。这里我们用接口来进行约束，使用add()给日志添加一个事件。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">interface</span> <span class="token class-name">Log_Engine_Interface</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">array</span> <span class="token variable">$LogData</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后我们来定义一个引擎。</p><p>基于文件的存储引擎</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Log_Engine_File</span> <span class="token keyword">implements</span> <span class="token class-name">Log_Engine_Interface</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">array</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$line</span> <span class="token operator">=</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token variable">$location</span> <span class="token operator">=</span> <span class="token string">"/var/log/app_file_log.log"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$location</span><span class="token punctuation">,</span> <span class="token variable">$line</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span> <span class="token string">"an error occurred writing to file. "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们就可在程序中调用Log类：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$engine</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Log_Engine_File</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$log</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEngine</span><span class="token punctuation">(</span><span class="token variable">$engine</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$logData</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token string">"user"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>    <span class="token string">"action"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"spend"</span><span class="token punctuation">,</span>    <span class="token string">"msg"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"....."</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$logData</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们可以还可以和注册表模式结合起来，使之更加方便我们使用。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$engine</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Log_Engine_File</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$log</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEngine</span><span class="token punctuation">(</span><span class="token variable">$engine</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//加入到注册表，方便我们随时使用</span>  Register<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$log</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>策略模式的伟大之处在于它不像工厂模式，日志类无需知道每一个不同的存储引擎的相关具体内容。这就意味着任何使用日志类的开发者都可以添加他们自己的存储引擎，只需要相应的存储引擎符合接口就行。例如我们可以继续给日志类增加MySQL存储引擎、Memcache存储引擎等等。</p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;策略模式允许类的使用者为这个类根据需要注入不同的依赖。通常情况下，这些依赖表现为对象、闭包或者回调方式，他们完成类所必要的要求以执行预期行为。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="设计模式" scheme="https://weizhimiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="策略模式" scheme="https://weizhimiao.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP常见设计模式之观察者模式</title>
    <link href="https://weizhimiao.github.io/2016/10/18/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/10/18/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-10-18T14:40:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式类似于javascript的事件。其核心在于允许我们的应用程序注册一个回调，当某个特定的事件发生时便会触发它。在javascript中，这些事件由单机（onclick）、页面加载（onload）、或者鼠标移动（onmousevoer）等动作组成。</p><p>观察者设计模式能够是我们更便利地创建查看目标对象状态的对象，并且提供与核心对象非耦合的指定功能性。</p><p>观察者设计模式使用场景（插件系统、缓存系统）</p><ul><li>对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。</li><li></li><li>对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。</li></ul><span id="more"></span><h3 id="UML设计"><a href="#UML设计" class="headerlink" title="UML设计"></a>UML设计</h3><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161018/GuanChaZheMoShi.png" alt="观察者模式"></p><p>说明：我们通过一个名为Event的类实现，这个类共有两个方法：</p><ul><li>registerCallBack（）,这个方法允许我们使用规定的名称附加许多回调到一个事件中。</li><li>trigger（）,这个方法将会触发刚才命名的事件，并调用该事件已注册的任何回调。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>event.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Event</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">static</span> <span class="token keyword">protected</span> <span class="token variable">$callbacks</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">registerCallBack</span><span class="token punctuation">(</span><span class="token variable">$eventName</span>， <span class="token variable">$callback</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_callable</span><span class="token punctuation">(</span><span class="token variable">$callback</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Invalid callback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$eventName</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$callbacks</span><span class="token punctuation">[</span><span class="token variable">$eventName</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$callback</span>；  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$eventName</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$eventName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$callbacks</span><span class="token punctuation">[</span><span class="token variable">$eventName</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$self</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$callbacks</span><span class="token punctuation">[</span><span class="token variable">$eventName</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token variable">$callback</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token comment" spellcheck="true">//回调可以是一个函数（包括匿名函数（闭包））、也可以是一个定义过__invoke()的对象</span>          <span class="token variable">$callback</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;  </span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调事件注册后将会被保存到Event类的静态受保护的Event::$callbacks属性中，成为一个以事件名作为Key的多为数组。如下所示，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">array</span><span class="token punctuation">(</span>  <span class="token string">"eventName"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token string">"callback 1"</span><span class="token punctuation">,</span>    <span class="token string">"callback 2"</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当触发一个事件时，我们仅遍历事件的Event::$callbacks子数组，然后依次调用每个回调。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>1、先定义一个MyDataRecord类表示数据层的一部分。这个类有个save（）方法，我们在save（）方法中添加一个save事件，每当我们调用它时，就会触发一个save事件，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">MyDataRecord</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//保存操作...</span>    <span class="token comment" spellcheck="true">//触发 save 事件</span>    Event<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">,</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、接着我们创建回调，用事件名save通过Event::registerCallBack()来注册它。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>Event<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">registerCallBack</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">echo</span> <span class="token string">"Clear Cache"</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、现在每当调用MyDataRecord-&gt;save();方法时，都将使回调生效。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//实例化一个daterecord类</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDataRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$data</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre><code>Clear Cachearray(2)&#123;  [0] =&gt;  string(5) &quot;Hello&quot;  [1] =&gt;  string(5) &quot;world&quot;&#125;</code></pre><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>1、同一个事件我们可以注册多个回调，这些回调将会通过FIFO（先进先出）来调用。</p><p>2、回调可以是一个函数（包括匿名函数，又称闭包），也可以是定义过 <code>__invoke()</code> 魔术方法的对象。<code>__invoke()</code>方法的作用是当我们试图将当前的这个对象作为函数使用时，这个方法就会自动调用。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//Logger callback</span><span class="token keyword">class</span> <span class="token class-name">LogCallback</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__invoke</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">echo</span> <span class="token string">"Log Data"</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token comment" spellcheck="true">//注册 log callback</span>Event<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">registerCallBack</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LogCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注册 clear cache callback</span>Event<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">registerCallBack</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">echo</span> <span class="token string">"Clear cache"</span><span class="token punctuation">.</span><span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;);</span><span class="token comment" spellcheck="true">//实例化一个 data record</span><span class="token variable">$data</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDataRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$data</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre><code>Log Dataarray(2)&#123;  [0] =&gt;  string(5) &quot;Hello&quot;  [1] =&gt;  string(5) &quot;world&quot;&#125;Clear Cachearray(2)&#123;  [0] =&gt;  string(5) &quot;Hello&quot;  [1] =&gt;  string(5) &quot;world&quot;&#125;</code></pre><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;观察者模式类似于javascript的事件。其核心在于允许我们的应用程序注册一个回调，当某个特定的事件发生时便会触发它。在javascript中，这些事件由单机（onclick）、页面加载（onload）、或者鼠标移动（onmousevoer）等动作组成。&lt;/p&gt;
&lt;p&gt;观察者设计模式能够是我们更便利地创建查看目标对象状态的对象，并且提供与核心对象非耦合的指定功能性。&lt;/p&gt;
&lt;p&gt;观察者设计模式使用场景（插件系统、缓存系统）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="设计模式" scheme="https://weizhimiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="观察者模式" scheme="https://weizhimiao.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP中is_func函数汇总</title>
    <link href="https://weizhimiao.github.io/2016/10/18/PHP%E4%B8%ADis_function%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/10/18/PHP%E4%B8%ADis_function%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</id>
    <published>2016-10-18T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161018/is_func.png" alt="PHP中is_func函数汇总"></p><span id="more"></span><h2 id="is-float"><a href="#is-float" class="headerlink" title="is_float"></a>is_float</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_float — 检测变量是否是浮点型</p></blockquote><p>描述</p><pre><code>bool is_float ( mixed $var )</code></pre><p>如果 var 是 float 则返回 TRUE，否则返回 FALSE。</p><h2 id="is-soap-fault"><a href="#is-soap-fault" class="headerlink" title="is_soap_fault"></a>is_soap_fault</h2><blockquote><p>is_soap_fault — 检查SOAP调用是否失败</p></blockquote><p>说明</p><pre><code>bool is_soap_fault ( mixed $object )</code></pre><p>此函数用于检查SOAP调用是否失败，但不使用异常。 要使用它，请创建一个SoapClient对象，将异常选项设置为零或FALSE。 在这种情况下，SOAP方法将返回封装故障详细信息（faultcode，faultstring，faultactor和faultdetails）的特殊SoapFault对象。</p><p>如果未设置异常，那么SOAP调用将在错误时抛出异常。 is_soap_fault（）检查给定的参数是否是SoapFault对象。</p><h2 id="is-bool"><a href="#is-bool" class="headerlink" title="is_bool"></a>is_bool</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_bool — 检测变量是否是布尔型</p></blockquote><p>描述</p><pre><code>bool is_bool ( mixed $var )</code></pre><p>如果 var 是 boolean 则返回 TRUE。</p><h2 id="is-integer"><a href="#is-integer" class="headerlink" title="is_integer"></a>is_integer</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_integer — is_int() 的别名</p></blockquote><p>描述</p><p>此函数是 is_int() 的别名函数。</p><h2 id="is-dir"><a href="#is-dir" class="headerlink" title="is_dir"></a>is_dir</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_dir — 判断给定文件名是否是一个目录</p></blockquote><p>说明</p><pre><code>bool is_dir ( string $filename )</code></pre><p>判断给定文件名是否是一个目录。</p><h2 id="is-writeable"><a href="#is-writeable" class="headerlink" title="is_writeable"></a>is_writeable</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_writeable — is_writable() 的别名</p></blockquote><p>说明</p><p>此函数是该函数的别名：is_writable()。</p><h2 id="is-real"><a href="#is-real" class="headerlink" title="is_real"></a>is_real</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_real — is_float() 的别名</p></blockquote><p>描述</p><p>此函数是 is_float() 的别名函数。</p><h2 id="is-file"><a href="#is-file" class="headerlink" title="is_file"></a>is_file</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_file — 判断给定文件名是否为一个正常的文件</p></blockquote><p>说明</p><pre><code>bool is_file ( string $filename )</code></pre><p>判断给定文件名是否为一个正常的文件。</p><h2 id="is-subclass-of"><a href="#is-subclass-of" class="headerlink" title="is_subclass_of"></a>is_subclass_of</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_subclass_of — 如果此对象是该类的子类，则返回 TRUE</p></blockquote><p>说明</p><pre><code>bool is_subclass_of ( object $object , string $class_name )</code></pre><p>如果对象 object 所属类是类 class_name 的子类，则返回 TRUE，否则返回 FALSE。</p><h2 id="is-tainted"><a href="#is-tainted" class="headerlink" title="is_tainted"></a>is_tainted</h2><blockquote><p>(PECL taint &gt;=0.1.0)</p><p>is_tainted — 检查字符串是否被污染</p></blockquote><p>说明</p><pre><code>bool is_tainted ( string $string )</code></pre><p>检查字符串是否被污染</p><h2 id="is-resource"><a href="#is-resource" class="headerlink" title="is_resource"></a>is_resource</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_resource — 检测变量是否为资源类型</p></blockquote><p>描述</p><pre><code>bool is_resource ( mixed $var )</code></pre><p>如果给出的参数 var 是 resource 类型，is_resource() 返回 TRUE，否则返回 FALSE。</p><p>PHP中<a href="http://php.net/manual/zh/resource.php">资源类型列表</a></p><h2 id="is-readable"><a href="#is-readable" class="headerlink" title="is_readable"></a>is_readable</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_readable — 判断给定文件名是否可读</p></blockquote><p>说明</p><pre><code>bool is_readable ( string $filename )</code></pre><p>判断给定文件名是否存在并且可读。</p><h2 id="is-writable"><a href="#is-writable" class="headerlink" title="is_writable"></a>is_writable</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_writable — 判断给定的文件名是否可写</p></blockquote><p>说明</p><pre><code>bool is_writable ( string $filename )</code></pre><p>如果文件存在并且可写则返回 TRUE。filename 参数可以是一个允许进行是否可写检查的目录名。</p><p><strong>记住 PHP 也许只能以运行 webserver 的用户名（通常为 ‘nobody’）来访问文件。不计入安全模式的限制。</strong></p><h2 id="is-scalar"><a href="#is-scalar" class="headerlink" title="is_scalar"></a>is_scalar</h2><blockquote><p>PHP 4 &gt;= 4.0.5, PHP 5, PHP 7)</p><p>is_scalar — 检测变量是否是一个标量</p></blockquote><p>描述</p><pre><code>bool is_scalar ( mixed $var )</code></pre><p>如果给出的变量参数 var 是一个标量，is_scalar() 返回 TRUE，否则返回 FALSE。</p><p>标量变量是指那些包含了 integer、float、string 或 boolean的变量，而 array、object 和 resource 则不是标量。</p><h2 id="is-long"><a href="#is-long" class="headerlink" title="is_long"></a>is_long</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_long — is_int() 的别名</p></blockquote><p>描述</p><p>此函数是 is_int() 的别名函数。</p><h2 id="is-double"><a href="#is-double" class="headerlink" title="is_double"></a>is_double</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_double — is_float() 的别名</p></blockquote><p>描述</p><p>此函数是 is_float() 的别名函数。</p><h2 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_array — 检测变量是否是数组</p></blockquote><p>描述</p><pre><code>bool is_array ( mixed $var )</code></pre><p>如果 var 是 array，则返回 TRUE，否则返回 FALSE。</p><h2 id="is-object"><a href="#is-object" class="headerlink" title="is_object"></a>is_object</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_object — 检测变量是否是一个对象</p></blockquote><p>描述</p><pre><code>bool is_object ( mixed $var )</code></pre><p>如果 var 是一个 object 则返回 TRUE，否则返回 FALSE。</p><h2 id="is-null"><a href="#is-null" class="headerlink" title="is_null"></a>is_null</h2><blockquote><p>(PHP 4 &gt;= 4.0.4, PHP 5, PHP 7)</p><p>is_null — 检测变量是否为 NULL</p></blockquote><p>描述</p><pre><code>bool is_null ( mixed $var )</code></pre><p>如果 var 是 null 则返回 TRUE，否则返回 FALSE。</p><p>查看 NULL 类型获知变量什么时候被认为是 NULL，而什么时候不是。</p><p>特殊的 NULL 值表示一个变量没有值。NULL 类型唯一可能的值就是 NULL。在下列情况下一个变量被认为是 NULL：</p><ul><li><p>被赋值为 NULL。</p></li><li><p>尚未被赋值。</p></li><li><p>被 unset()。</p></li></ul><h2 id="is-string"><a href="#is-string" class="headerlink" title="is_string"></a>is_string</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_string — 检测变量是否是字符串</p></blockquote><p>描述</p><pre><code>bool is_string ( mixed $var )</code></pre><p>如果 var 是 string 则返回 TRUE，否则返回 FALSE。</p><h2 id="is-finite"><a href="#is-finite" class="headerlink" title="is_finite"></a>is_finite</h2><blockquote><p>(PHP 4 &gt;= 4.2.0, PHP 5, PHP 7)</p><p>is_finite — 判断是否为有限值</p></blockquote><p>说明</p><pre><code>bool is_finite ( float $val )</code></pre><p>检查 val 是否是是本机平台上浮点数所允许范围中的一个合法的有限值。</p><h2 id="is-callable"><a href="#is-callable" class="headerlink" title="is_callable"></a>is_callable</h2><blockquote><p>(PHP 4 &gt;= 4.0.6, PHP 5, PHP 7)</p><p>is_callable — 检测参数是否为合法的可调用结构</p></blockquote><p>说明</p><pre><code>bool is_callable ( callable $name [, bool $syntax_only = false [, string &amp;$callable_name ]] )</code></pre><p>验证变量的内容能否作为函数调用。 这可以检查包含有效函数名的变量，或者一个数组，包含了正确编码的对象以及函数名。</p><h2 id="is-numeric"><a href="#is-numeric" class="headerlink" title="is_numeric"></a>is_numeric</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_numeric — 检测变量是否为数字或数字字符串</p></blockquote><p>描述</p><pre><code>bool is_numeric ( mixed $var )</code></pre><p>如果 var 是数字和数字字符串则返回 TRUE，否则返回 FALSE。</p><h2 id="is-infinite"><a href="#is-infinite" class="headerlink" title="is_infinite"></a>is_infinite</h2><blockquote><p>(PHP 4 &gt;= 4.2.0, PHP 5, PHP 7)</p><p>is_infinite — 判断是否为无限值</p></blockquote><p>说明</p><pre><code>bool is_infinite ( float $val )</code></pre><p>如果 val 为无穷大（正的或负的），例如 log(0) 的结果或者任何超出本平台的浮点数范围的值，则返回 TRUE。</p><h2 id="is-executable"><a href="#is-executable" class="headerlink" title="is_executable"></a>is_executable</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_executable — 判断给定文件名是否可执行</p></blockquote><p>说明</p><pre><code>bool is_executable ( string $filename )</code></pre><p>判断给定文件名是否可执行。</p><h2 id="is-int"><a href="#is-int" class="headerlink" title="is_int"></a>is_int</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_int — 检测变量是否是整数</p></blockquote><p>描述 ¶</p><pre><code>bool is_int ( mixed $var )</code></pre><p>如果 var 是 integer 则返回 TRUE，否则返回 FALSE。</p><p><strong>Note:</strong><br>若想测试一个变量是否是数字或数字字符串（如表单输入，它们通常为字符串），必须使用 is_numeric()。</p><h2 id="is-nan"><a href="#is-nan" class="headerlink" title="is_nan"></a>is_nan</h2><blockquote><p>(PHP 4 &gt;= 4.2.0, PHP 5, PHP 7)</p><p>is_nan — 判断是否为合法数值</p></blockquote><p>说明</p><pre><code>bool is_nan ( float $val )</code></pre><p>如果 val 为“非数值”，例如 acos(1.01) 的结果，则返回 TRUE。</p><h2 id="is-link"><a href="#is-link" class="headerlink" title="is_link"></a>is_link</h2><blockquote><p>(PHP 4, PHP 5, PHP 7)</p><p>is_link — 判断给定文件名是否为一个符号连接</p></blockquote><p>说明</p><pre><code>bool is_link ( string $filename )</code></pre><p>判断给定文件名是否为一个符号连接。</p><h2 id="is-uploaded-file"><a href="#is-uploaded-file" class="headerlink" title="is_uploaded_file"></a>is_uploaded_file</h2><blockquote><p>(PHP 4 &gt;= 4.0.3, PHP 5, PHP 7)</p><p>is_uploaded_file — 判断文件是否是通过 HTTP POST 上传的</p></blockquote><p>说明</p><pre><code>bool is_uploaded_file ( string $filename )</code></pre><p>如果 filename 所给出的文件是通过 HTTP POST 上传的则返回 TRUE。这可以用来确保恶意的用户无法欺骗脚本去访问本不能访问的文件，例如 /etc/passwd。</p><p><strong>这种检查显得格外重要</strong>，如果上传的文件有可能会造成对用户或本系统的其他用户显示其内容的话。</p><p>为了能使 is_uploaded_file() 函数正常工作，变量指定类似于 $_FILES[‘userfile’][‘tmp_name’] 的变量，而在从客户端上传的文件名 $_FILES[‘userfile’][‘name’] 不能正常运作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161018/is_func.png&quot; alt=&quot;PHP中is_func函数汇总&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP常见设计模式之工厂模式</title>
    <link href="https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-10-14T13:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><p>工厂模式是我们最常用的实例化对象模式了，顾名思义工厂设计模式，就是用于制造对象的一种设计模式，是一种用来代替new操作的一种模式。</p><p>其的最大价值在于它可以将多个对象设置封装成单一、简单的方法调用。</p><p>对外提供获取某个对象的新实例的接口，同时使调用代码避免确定实际实例化基类的步骤。</p><span id="more"></span><h2 id="工厂模式的应用和使用场景"><a href="#工厂模式的应用和使用场景" class="headerlink" title="工厂模式的应用和使用场景"></a>工厂模式的应用和使用场景</h2><p>通常情况下，虽然我们很少使用工厂模式，但它仍然最适合初始化基于驱动安装的许多变种中的一种。例如，不同的配置、会话或缓存存储引擎。例如，当我们设置一个日志对象时，我们需要设置日志类型（如，基于文本、MySQL或者其他）、日志的位置、以及类似于凭证条目。</p><h2 id="工厂模式的实现"><a href="#工厂模式的实现" class="headerlink" title="工厂模式的实现"></a>工厂模式的实现</h2><h3 id="UML设计"><a href="#UML设计" class="headerlink" title="UML设计"></a>UML设计</h3><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161014/GongChangMoShiUMLTu.png" alt="UML设计图"></p><p>说明：</p><ul><li>三个基类Log_File、Log_Mysql、Log_Sqlite,都具有名为dosomething()的公用方法，该方法采用他们各自独特的方式执行具体的逻辑。且其返回类型也应该完全相同。</li><li>Log_factory类用于创建下面三个任意一个基类的实例，并将其返回至代码流。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>工厂类Log_factory实现</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Log_factory</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">getLog</span><span class="token punctuation">(</span><span class="token variable">$type</span> <span class="token operator">=</span> <span class="token string">'file'</span><span class="token punctuation">,</span> <span class="token keyword">array</span> <span class="token variable">$options</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$type</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$class</span> <span class="token operator">=</span> <span class="token string">"Log_"</span><span class="token punctuation">.</span><span class="token function">unfirst</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">require_once</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token constant">DIRECTORY_SEPARATOR</span><span class="token punctuation">,</span> <span class="token variable">$class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'.php'</span><span class="token punctuation">;</span>    <span class="token variable">$log</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token variable">$class</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token variable">$type</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">case</span> <span class="token string">'file'</span><span class="token punctuation">:</span>        <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setPath</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string">'location'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">'mysql'</span><span class="token punctuation">:</span>        <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDBname</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string">'location'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token keyword">case</span> <span class="token string">'sqlite'</span><span class="token punctuation">:</span>        <span class="token variable">$log</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDBPath</span><span class="token punctuation">(</span><span class="token variable">$options</span><span class="token punctuation">[</span><span class="token string">'location'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$log</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Tips:</strong><br>在实际应用中，我们可以把getLog()方法生成的对象添加到Registry，这样就不用一遍又一遍的实例化这些对象。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是工厂模式&quot;&gt;&lt;a href=&quot;#什么是工厂模式&quot; class=&quot;headerlink&quot; title=&quot;什么是工厂模式&quot;&gt;&lt;/a&gt;什么是工厂模式&lt;/h2&gt;&lt;p&gt;工厂模式是我们最常用的实例化对象模式了，顾名思义工厂设计模式，就是用于制造对象的一种设计模式，是一种用来代替new操作的一种模式。&lt;/p&gt;
&lt;p&gt;其的最大价值在于它可以将多个对象设置封装成单一、简单的方法调用。&lt;/p&gt;
&lt;p&gt;对外提供获取某个对象的新实例的接口，同时使调用代码避免确定实际实例化基类的步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="设计模式" scheme="https://weizhimiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="工厂模式" scheme="https://weizhimiao.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP常见设计模式之注册表模式</title>
    <link href="https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-10-14T12:40:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是注册表模式"><a href="#什么是注册表模式" class="headerlink" title="什么是注册表模式"></a>什么是注册表模式</h2><p>注册表（registry）模式仅是一个单独的全局类，在我们需要时允许代码检索一个对象的相同实例，也可以在我们需要的时候创建另一个实例。</p><p>注册表就像是一个对象库，只要我们随时签入或者签出对象，而不必担心因为将这些对象保留太久而引起功能障碍。</p><p>我们认为注册表模式中最简单的方式就是键/值存储，键作为一个对象的实例，而值就是实例本身。当我们需要管理键/值对的数组时，这个模式便开始发挥功效，存储最早实例化的实例，并且返回一个引用到请求中的同一个实例。</p><h2 id="注册表模式和单例模式的关系"><a href="#注册表模式和单例模式的关系" class="headerlink" title="注册表模式和单例模式的关系"></a>注册表模式和单例模式的关系</h2><p>相同点：</p><blockquote><p>和单例模式一样，注册表模式也是用于访问全局可重用的对象；</p></blockquote><p>区别：</p><blockquote><p>注册表模式不负责创建对象，纯粹用于保持全局存储，可以容纳任何数量的相同类的实例。这使得它非常适合类似于数据库连接和配置对象等的采用单例模式满足不了其需求的情况。</p></blockquote><span id="more"></span><h2 id="注册表模式的实现"><a href="#注册表模式的实现" class="headerlink" title="注册表模式的实现"></a>注册表模式的实现</h2><p>示例，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Registry</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$_store</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$object</span><span class="token punctuation">,</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$name</span> <span class="token punctuation">:</span> <span class="token function">get_class</span><span class="token punctuation">(</span><span class="token variable">$object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$return</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$return</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; else&amp;#123;</span>      self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$object</span><span class="token punctuation">;</span>      <span class="token variable">$return</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$return</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"object does not exist in registry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token function">unset</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_store</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;  </span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注册表模式的4个实现方法：</p><ul><li>Registry::set(),添加一个对象到注册表，你可以指定一个名称（为多个实例）或者使用默认的类名（为单例，与行为类似）</li><li>Registry::get(),从注册表的名字中检索一个对象</li><li>Registry::contains(),在注册表中检查一个对象是否存在</li><li>Registry::unset(),通过对象名在注册表中删除一个对象</li></ul><h2 id="注册表模式的应用"><a href="#注册表模式的应用" class="headerlink" title="注册表模式的应用"></a>注册表模式的应用</h2><p>创建了Registry类之后，我们可以通过两种方式来使用它。</p><ul><li>外部</li><li>内部</li></ul><p>示例，两种方式的数据库连接代码。</p><h3 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$read</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DBReadConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$read</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$write</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DBWriteConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$wite</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在之后的任何代码中，我们可以通过以下方式获得对应实例</span>  <span class="token variable">$read</span> <span class="token operator">=</span> Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'DBReadConnection'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$write</span> <span class="token operator">=</span> Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'DBWriteConnection'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例中，我们没有传入实例名称，而是通过使用类名从注册表中提取对象。<br>在Registry类能访问到的任何地方该对象都可用。</p><h3 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DBConnection</span> extend <span class="token constant">PDO</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> statuc <span class="token keyword">function</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token variable">$name</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$class</span> <span class="token operator">=</span> <span class="token function">get_called_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_null</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$name</span> <span class="token punctuation">:</span> <span class="token variable">$class</span><span class="token punctuation">;</span>    <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token variable">$class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token variable">$instance</span><span class="token punctuation">,</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> Registry<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token keyword">class</span> <span class="token class-name">DBWriteConnection</span> extend DBConnection<span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__contruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">parent</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">_contruct</span><span class="token punctuation">(</span><span class="token constant">APP_DB_DSN</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_USER</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_PWD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token keyword">class</span> <span class="token class-name">DBReadConnection</span> extend DBConnection<span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__contruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">parent</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">_contruct</span><span class="token punctuation">(</span><span class="token constant">APP_DB_DSN</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_USER</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_PWD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要使用这些代码，我们只需在任一读或者写连接类中调用DBConnection::getInstance()即可，就像</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token comment" spellcheck="true">//获得一个读实例</span>  <span class="token variable">$read_db</span> <span class="token operator">=</span> DBReadConnection<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获得一个写实例</span>  <span class="token variable">$write_db</span>  <span class="token operator">=</span> DBWriteConnection<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获得另一个读实例</span>  <span class="token variable">$another_read_db</span> <span class="token operator">=</span> DBReadConnection<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"another_db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在某些方面，这是一个单例模式和工厂模式的混合物。</p><h2 id="注册的若干问题"><a href="#注册的若干问题" class="headerlink" title="注册的若干问题"></a>注册的若干问题</h2><p>对于外部注册表，你不能延迟加载；也就是说，在我们使用之前，必须初始化注册表中的每一个对象。如果操作顺序变得更为复杂，我们可能就会错过某个对象而产生预料之外的错误。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是注册表模式&quot;&gt;&lt;a href=&quot;#什么是注册表模式&quot; class=&quot;headerlink&quot; title=&quot;什么是注册表模式&quot;&gt;&lt;/a&gt;什么是注册表模式&lt;/h2&gt;&lt;p&gt;注册表（registry）模式仅是一个单独的全局类，在我们需要时允许代码检索一个对象的相同实例，也可以在我们需要的时候创建另一个实例。&lt;/p&gt;
&lt;p&gt;注册表就像是一个对象库，只要我们随时签入或者签出对象，而不必担心因为将这些对象保留太久而引起功能障碍。&lt;/p&gt;
&lt;p&gt;我们认为注册表模式中最简单的方式就是键/值存储，键作为一个对象的实例，而值就是实例本身。当我们需要管理键/值对的数组时，这个模式便开始发挥功效，存储最早实例化的实例，并且返回一个引用到请求中的同一个实例。&lt;/p&gt;
&lt;h2 id=&quot;注册表模式和单例模式的关系&quot;&gt;&lt;a href=&quot;#注册表模式和单例模式的关系&quot; class=&quot;headerlink&quot; title=&quot;注册表模式和单例模式的关系&quot;&gt;&lt;/a&gt;注册表模式和单例模式的关系&lt;/h2&gt;&lt;p&gt;相同点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;和单例模式一样，注册表模式也是用于访问全局可重用的对象；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注册表模式不负责创建对象，纯粹用于保持全局存储，可以容纳任何数量的相同类的实例。这使得它非常适合类似于数据库连接和配置对象等的采用单例模式满足不了其需求的情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="设计模式" scheme="https://weizhimiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="注册表模式" scheme="https://weizhimiao.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP常见设计模式之单例模式</title>
    <link href="https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/10/14/PHP%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-10-14T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>当我们实例化一个对象时，他可以确保我们实例化的这个类将仅有一个实例，并且我们在我们的代码中的任何地方都可以轻易的召回相同的对象。</p><p>就是说，当我们使用单例模式第一次调用对象时，他就会被实例化，之后每一次调用都将会返回同一个对象。</p><p>单例模式通常用于对象，它代表在应用程序不同部分被再三使用的资源，而且始终为同一对象。</p><p>常见的示例包括数据库连接和配置信息。</p><span id="more"></span><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式最重要的方面就是在于对创建示例的限制能力。如果不这样做的话，应用程序中同一个对象可能会被创建多个实例，可能会造成资源的浪费。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过创建私有的构造器来实现限制对象创建实例的能力。示例，</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Database</span> extend <span class="token constant">PDO</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token comment" spellcheck="true">//私有静态变量，用来保存单例实例</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token variable">$_instance</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//私有构造函数，保证这个类只能被本省的静态发放实例化</span>  <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">_contruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//调用PDO的构造函数</span>    <span class="token keyword">parent</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">_contruct</span><span class="token punctuation">(</span><span class="token constant">APP_DB_DSN</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_USER</span><span class="token punctuation">,</span> <span class="token constant">APP_DB_PWD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">//获得单例实例的方法。如果实例已经存在，则直接返回；否则先构造一个，然后返回；</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_instance</span> <span class="token keyword">instanceof</span> <span class="token class-name">Database</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_instance</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$_instance</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现单例的三个关键点：</p><ul><li>使用一个静态成员来保持一个单例实例。在这个例子中，我们有一个私有的DB::$_instance属性。</li><li>然后，一个私有的构造函数将决定这个类只能被本身所包含的静态方法实例化。</li><li>DB::getInstance()静态方法将用于数据库类。当他被调用时，DB::getInstance()将实例化一个Database类的对象并将这个对象指定给DB::$_instance属性，然后返回这个对象，或只返回先前已经实例化的对象。</li></ul><p>我们之所以使用单例模式，是因为静态方法可以在全局范围内被访问，无论哪里，当我们需要一个数据库连接时，只需要调用DB::getInstance()即可。</p><h2 id="使用单例模式的问题"><a href="#使用单例模式的问题" class="headerlink" title="使用单例模式的问题"></a>使用单例模式的问题</h2><p><strong>尽管单例思想很伟大，但当我们确实需要多个实例的时候，其局限性就显而易见。</strong></p><blockquote><p>比如，我们拆分了数据库之后，就需要在不同的服务器上进行读写操作。而这时单例就满足不了我们的需求了。</p></blockquote><p>所以单例模式不恰当的使用就会抑制自身的发展和重用。所以当想通过一个类创建两个实例，我们可以考虑通过注册表模式来实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是单例模式&quot;&gt;&lt;a href=&quot;#什么是单例模式&quot; class=&quot;headerlink&quot; title=&quot;什么是单例模式&quot;&gt;&lt;/a&gt;什么是单例模式&lt;/h2&gt;&lt;p&gt;当我们实例化一个对象时，他可以确保我们实例化的这个类将仅有一个实例，并且我们在我们的代码中的任何地方都可以轻易的召回相同的对象。&lt;/p&gt;
&lt;p&gt;就是说，当我们使用单例模式第一次调用对象时，他就会被实例化，之后每一次调用都将会返回同一个对象。&lt;/p&gt;
&lt;p&gt;单例模式通常用于对象，它代表在应用程序不同部分被再三使用的资源，而且始终为同一对象。&lt;/p&gt;
&lt;p&gt;常见的示例包括数据库连接和配置信息。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="设计模式" scheme="https://weizhimiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="https://weizhimiao.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>大话MySQL性能优化</title>
    <link href="https://weizhimiao.github.io/2016/10/13/%E5%A4%A7%E8%AF%9DMySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://weizhimiao.github.io/2016/10/13/%E5%A4%A7%E8%AF%9DMySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2016-10-13T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161013/MySQLXingNenDiaoYou.jpg" alt="MYSQL性能优化"></p><p>性能是MySQL一直引以为豪的一点。在性能和功能两个方面，MySQL第一考虑的还是性能。</p><span id="more"></span><h2 id="影响MySQL性能的相关因素"><a href="#影响MySQL性能的相关因素" class="headerlink" title="影响MySQL性能的相关因素"></a>影响MySQL性能的相关因素</h2><h3 id="商业需求对性能的影响"><a href="#商业需求对性能的影响" class="headerlink" title="商业需求对性能的影响"></a>商业需求对性能的影响</h3><p>对于某一些功能在整个系统中是画蛇添足的，那么这些需求就可能会影响系统性能。比如，一个论坛要求对在线人数进行实时统计。</p><h3 id="系统架构及实现对性能的影响"><a href="#系统架构及实现对性能的影响" class="headerlink" title="系统架构及实现对性能的影响"></a>系统架构及实现对性能的影响</h3><p>服务器调优</p><p>应用程序调优</p><ul><li>不可是存储到数据库的数据<ul><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li></ul></li><li>合理的利用应用层Cache（适合Cache的数据有：）<ul><li>系统的各种配置和规则数据</li><li>活跃用户的基本信息数据</li><li>活跃用户的个性化定制信息数据</li><li>准实时的统计信息</li><li>其他一些访问频繁但变更很少的数据</li></ul></li><li>数据层实现精简</li><li>过度依赖数据库SQL语句功能</li><li>常见的架构设计不当带来的性能问题和资源浪费<ul><li>Cache系统设计不合理，导致Cache命中率低下</li><li>过度依赖面向对象</li><li>对可扩展性的过度追求（促使系统设计的时候对象拆分的过于分散，造成系统中出现大量的join语句）</li><li>对数据库的过于依赖（将不适合存储在数据库中的数据存储在数据库中）</li><li>过度理想化系统的用户体验（使大量非核心业务消耗大量系统资源）</li></ul></li></ul><h3 id="Query语句对性能的影响"><a href="#Query语句对性能的影响" class="headerlink" title="Query语句对性能的影响"></a>Query语句对性能的影响</h3><h4 id="分析手段"><a href="#分析手段" class="headerlink" title="分析手段"></a>分析手段</h4><ul><li><p>explain</p><blockquote><p>分析选项：</p><ul><li>索引（key），query语句中是用到的索引</li><li>row中的rows，查找的记录数</li></ul></blockquote></li><li><p>profiling</p><blockquote><p>先打开profiling；set profiling=1；</p><p>查看profiling信息：show profiling \G;</p><p>show profile CPU,BLOCK IO FOR query 1(2);</p><p>分析选项</p><ul><li>CPU IO消耗</li></ul></blockquote></li></ul><h4 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h4><blockquote><p><strong>锁机制的目的：</strong> 保证数据的一致完整性</p><p><strong>锁机制的影响：</strong> 直接影响一个数据库系统的并发处理能力和性能</p></blockquote><ul><li><p>行级锁（row-level）</p><blockquote><p><strong>优点：</strong> 锁定对象的粒度最小，发生锁定资源争用的概率就最小，能给予最大可能的并发处理能力。</p><p><strong>缺点：</strong> 由于粒度最小，所以每次获得锁和释放锁需要做的工作也最多。带来的消耗也就最大。另外，容易发生死锁。</p></blockquote></li><li><p>表级锁（table-level）</p><blockquote><p><strong>优点：</strong> 最大粒度的锁定机制。所以逻辑简单，实现也较为容易。获得锁和释放锁的速度也很快。而且能很好的避免死锁问题。</p><p><strong>缺点：</strong> 出现锁定资源争用的概率会提高，导致并发处理能力大打折扣。</p></blockquote></li><li><p>页级锁（page-level）</p><blockquote><p>介于row-level和table-level二者之间。</p></blockquote></li></ul><h4 id="合理的应用锁机制"><a href="#合理的应用锁机制" class="headerlink" title="合理的应用锁机制"></a>合理的应用锁机制</h4><p>MyISAM表锁优化</p><blockquote><p>关键：提高并发度</p></blockquote><ul><li>缩短锁定时间，即query的执行时间要尽可能的短<ul><li>尽量减少大的、复杂的query，将复杂的query拆分</li><li>尽可能的建立高效索引，使数据的检索更加迅速</li><li>尽量让MySQL的表只存放必要的信息，控制字段类型</li></ul></li><li>分离能并行的操作<ul><li>关键：Concurrent insert（并发插入特性）</li><li>打开 Concurrent_insert功能，选项有0，1和2。具体说明如下：</li><li>concurrent_insert=2,无论MyISAM表数据文件中间部分是否存在因删除而留下的空闲空间，都允许在尾部进行concurrent insert操作。</li><li>concurrent_insert=1,当MyISAM表数据文件中间部分不存在因删除而留下的空闲空间，可以在尾部进行concurrent insert操作。</li><li>concurrent_insert=0,无论MyISAM表数据文件中间部分是否存在因删除而留下的空闲空间，都不允许在尾部进行concurrent insert操作。</li><li>建议：如果数据删除的肯呢个性很小，则建议将concurrent_insert设置成1，如不在乎浪费少量空间设置成2也可以。但当有少量删除时，设置成1更合适。</li></ul></li><li>读写优先级设置<ul><li>默认，写的优先级大于读的优先级</li><li>参数选项，low_priority_updates=1(将写的优先级调低)</li></ul></li></ul><p>InnoDB行锁优化</p><ul><li>尽可能让所有的数据检索都通过索引来完成，避免InnoDB因为无法通过索引键加锁升级成为表级锁定</li><li>合理设计索引，让InnoDB加锁是尽可能准确，尽可能缩小锁定范围</li><li>尽可能的减少基于范围的数据检索过滤条件</li><li>尽量控制事务的大小，尽量减少锁定的资源量和锁定的时间长度</li><li>尽量使用级别低的事务隔离级别，减少MySQL因为事务隔离带来的附加成本</li><li>尽可能减少死锁产生的概率<ul><li>类似业务模块中，尽可能用相同的访问顺序来访问，防止产生死锁</li><li>同一事务中，尽可能一次锁定所有需要的资源</li><li>对于非常容易产生死锁的业务部分，可以尝试升级锁定粒度，通过表级锁定减少死锁产生的概率</li></ul></li><li>系统锁定争用情况的查询<ul><li>标记锁定争用状态变量<pre><code>mysql&gt; show status like &#39;table%&#39;variable_name valuetable_lock_immediate 100  //产生标记锁定次数table_lock_waited 0       //出现标记锁定争用出现的等待的次数</code></pre></li><li>行级锁定争用状态变量<pre><code>mysql&gt; show status like &#39;innodb_row_lock%&#39;innodb_row_lock_current_waits 0   //当前正在等待锁定的数量innodb_row_lock_time 3999999      //从系统启动到现在锁定的总时间长度innodb_row_lock_time_avg 36666    //每次等待所花费平均时间innodb_row_lock_time_max 122222   //从启动到现在等待最长一次所花时间长度innodb_row_lock_waits 20          //从启动到现在共等待的次数</code></pre></li></ul></li></ul><h2 id="垂直和水平联合切分的使用"><a href="#垂直和水平联合切分的使用" class="headerlink" title="垂直和水平联合切分的使用"></a>垂直和水平联合切分的使用</h2><p>优点：</p><ul><li>充分利用垂直切分和水平切分各自的优势，而避免各自的缺陷</li><li>让系统扩展性得到最大提升</li></ul><p>缺点：</p><ul><li>数据库系统架构比较复杂，使维护难度更大</li><li>应用程序架构也相对更复杂</li></ul><h2 id="合理的设计并利用索引"><a href="#合理的设计并利用索引" class="headerlink" title="合理的设计并利用索引"></a>合理的设计并利用索引</h2><h3 id="MySQL常用的四种索引类型"><a href="#MySQL常用的四种索引类型" class="headerlink" title="MySQL常用的四种索引类型"></a>MySQL常用的四种索引类型</h3><ul><li>B-tree索引</li><li>Hash索引</li><li>Fulltext索引</li><li>Rtree索引</li></ul><h3 id="索引的弊端"><a href="#索引的弊端" class="headerlink" title="索引的弊端"></a>索引的弊端</h3><ul><li>增加了更新所带来的IO量，和调整索引导致的计算量</li><li>占用存储空间，并会跟数据量的增加而增加</li></ul><h3 id="如何判断是否需要索引"><a href="#如何判断是否需要索引" class="headerlink" title="如何判断是否需要索引"></a>如何判断是否需要索引</h3><ul><li>较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合做单独的索引，即使它频繁作为查询条件</li><li>更新非常频繁的字段不适合做索引</li><li>不会出现在where子句中的字段不适合做索引</li></ul><h3 id="MySQL索引的限制"><a href="#MySQL索引的限制" class="headerlink" title="MySQL索引的限制"></a>MySQL索引的限制</h3><ul><li>MyISAM存储引擎索引键长度总和长度不能超过1000字节</li><li>Text和Blob类型的字段只能创建前缀索引</li><li>使用不等于（!= 或 &lt;&gt; ）的时候MySQL无法使用索引</li><li>过滤字段使用了函数运算后（如，abs（culumn）），MySQL无法使用索引</li><li>join语句中join条件字段类型不一致不能使用索引</li><li>使用LIKE操作的时候，如果条件以通配符开始（如，’%abc’）MySQL无法使用索引</li><li>使用非等值查询时，MySQL无法使用索引</li></ul><h2 id="Query的优化"><a href="#Query的优化" class="headerlink" title="Query的优化"></a>Query的优化</h2><h3 id="优化更需要优化的query"><a href="#优化更需要优化的query" class="headerlink" title="优化更需要优化的query"></a>优化更需要优化的query</h3><p>高并发低消耗的query（相对）对整个系统的影响远比低并发高消耗的query要大。</p><h3 id="定位优化对象的性能瓶颈（profiling）"><a href="#定位优化对象的性能瓶颈（profiling）" class="headerlink" title="定位优化对象的性能瓶颈（profiling）"></a>定位优化对象的性能瓶颈（profiling）</h3><ul><li>IO，数据访问方面</li><li>CPU，数据运算（如分组、排序）</li></ul><h3 id="明确优化手段"><a href="#明确优化手段" class="headerlink" title="明确优化手段"></a>明确优化手段</h3><p>优化更偏向与对系统功能比较重要的query</p><h3 id="从explain入手"><a href="#从explain入手" class="headerlink" title="从explain入手"></a>从explain入手</h3><p>获取一个query在当前状态的数据库中的执行计划</p><h3 id="多用profile"><a href="#多用profile" class="headerlink" title="多用profile"></a>多用profile</h3><h3 id="永远用小结果集驱动大结果集"><a href="#永远用小结果集驱动大结果集" class="headerlink" title="永远用小结果集驱动大结果集"></a>永远用小结果集驱动大结果集</h3><h3 id="尽可能在索引中完成排序"><a href="#尽可能在索引中完成排序" class="headerlink" title="尽可能在索引中完成排序"></a>尽可能在索引中完成排序</h3><h3 id="只需取出自己需要的column"><a href="#只需取出自己需要的column" class="headerlink" title="只需取出自己需要的column"></a>只需取出自己需要的column</h3><h3 id="仅适用最有效的过滤条件"><a href="#仅适用最有效的过滤条件" class="headerlink" title="仅适用最有效的过滤条件"></a>仅适用最有效的过滤条件</h3><p>where字句中的条件并非越多越好</p><h3 id="尽可能的避免复杂的join查询和子查询"><a href="#尽可能的避免复杂的join查询和子查询" class="headerlink" title="尽可能的避免复杂的join查询和子查询"></a>尽可能的避免复杂的join查询和子查询</h3><p>query语句涉及的表越多，需要锁定的资源就越多，所阻塞的其他线程也就越多。</p><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="join的实现与优化"><a href="#join的实现与优化" class="headerlink" title="join的实现与优化"></a>join的实现与优化</h4><p>join是一种算法，即大名鼎鼎的Nested Loop Join。它是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。</p><ul><li><p>尽可能的Join语句中的Nested Loop的循环次数</p><blockquote><p>最有效的方法只有一个：让驱动表的结果集尽可能的小。即『永远用小结果集驱动大结果集』</p></blockquote></li><li><p>优先优化Nested Loop的内层循环</p></li><li><p>保证Join语句中被驱动表上的join字段已经被索引</p></li><li><p>当无法保证被驱动表join字段被索引且内存充足的前提下，不要太吝啬joinBuffer的设置</p></li></ul><h4 id="order-by的优化"><a href="#order-by的优化" class="headerlink" title="order by的优化"></a>order by的优化</h4><ul><li>加大max_length_for_sort_data参数的设置</li><li>去掉不必要的返回字段</li><li>增大sort_buffer_size参数设置</li></ul><h4 id="Schema设计优化"><a href="#Schema设计优化" class="headerlink" title="Schema设计优化"></a>Schema设计优化</h4><ul><li>范式理论</li><li>十度冗余，尽量减少join</li></ul><h4 id="大字段垂直拆分"><a href="#大字段垂直拆分" class="headerlink" title="大字段垂直拆分"></a>大字段垂直拆分</h4><p>什么样的字段适合</p><ul><li>大字段（比如，文章内容、帖子内容、产品的介绍、小说内容等）</li><li>表中和其他字段比较，访问明显要少的字段</li></ul><p>优点</p><ul><li>数据库拆分简单明了，拆分规则明确</li><li>应用程序模块清晰明了，整合容易</li><li>数据维护方便易行，容易定位</li></ul><p>缺点</p><ul><li>部分表关联无法在数据库级别完成，需要在程序中完成</li><li>对于访问极其频繁且数据量超大的表任然存在性能瓶颈，不一定满足要求</li><li>事务处理相对更为复杂</li><li>切分达到一定程度后，扩展性会收到限制</li><li>过度切分可能会带来系统过度复杂而难以维护</li></ul><h4 id="大表水平拆分"><a href="#大表水平拆分" class="headerlink" title="大表水平拆分"></a>大表水平拆分</h4><p>基于类型的分拆优化</p><p>优点</p><ul><li>表关联基本能在数据库端完成</li><li>不会存在某些超大型数据量和高负载的表遇到的瓶颈问题</li><li>应用程序端整体架构改动相对较少</li><li>事务处理相对简单</li><li>只要切分规则能够定义好，基本上较难遇到扩展性限制</li></ul><p>缺点</p><ul><li>切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则</li><li>后期数据的维护难度有所增加，人为手工定位数据更困难</li><li>应用系统各模块耦合度较高，可能会对后面数据的迁移、拆分造成一定困难</li></ul><h2 id="MySQL的备份与恢复"><a href="#MySQL的备份与恢复" class="headerlink" title="MySQL的备份与恢复"></a>MySQL的备份与恢复</h2><p>备份使用场景</p><ul><li>数据丢失应用场景<ul><li>人为操作事务造成的某些数据丢失</li><li>如那件Bug造成的数据部分丢失或者全部丢失</li><li>硬件故障造成的数据部分或者全部丢失</li><li>安全漏洞被入侵数据被恶意破坏</li></ul></li><li>非数据丢失应用场景<ul><li>特殊应用场景下基于时间点恢复</li><li>开发测试环境数据库搭建</li><li>相同数据库的新环境搭建</li><li>数据库或者数据迁移</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161013/MySQLXingNenDiaoYou.jpg&quot; alt=&quot;MYSQL性能优化&quot;&gt;&lt;/p&gt;
&lt;p&gt;性能是MySQL一直引以为豪的一点。在性能和功能两个方面，MySQL第一考虑的还是性能。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="性能优化" scheme="https://weizhimiao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>大型网站技术架构剖析</title>
    <link href="https://weizhimiao.github.io/2016/10/13/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/"/>
    <id>https://weizhimiao.github.io/2016/10/13/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/</id>
    <published>2016-10-13T02:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161013/DaXingWangZhanJiShuJiaGouPouXi.jpg" alt="大型网站技术架构剖析"></p><h2 id="大型网站系统特点"><a href="#大型网站系统特点" class="headerlink" title="大型网站系统特点"></a>大型网站系统特点</h2><ul><li>高并发，大流量</li><li>高可用</li><li>海量数据</li><li>用户分布广泛，网络情况复杂</li><li>安全环境恶略</li><li>需求快速变更，发布频繁</li><li>渐进式发展</li></ul><span id="more"></span><h2 id="大型网站发展演化过程"><a href="#大型网站发展演化过程" class="headerlink" title="大型网站发展演化过程"></a>大型网站发展演化过程</h2><h3 id="一台服务器"><a href="#一台服务器" class="headerlink" title="一台服务器"></a>一台服务器</h3><p>特点：没人</p><p>应用程序、数据库、文件都在一个服务器。</p><h3 id="应用服务器和数据服务器分离"><a href="#应用服务器和数据服务器分离" class="headerlink" title="应用服务器和数据服务器分离"></a>应用服务器和数据服务器分离</h3><p>应用服务器</p><ul><li>处理大量业务</li><li>需要更快更强的CPU</li></ul><p>数据服务器</p><ul><li>需要快速磁盘检索和数据缓存</li><li>需要更快的磁盘和更大的内存</li></ul><p>文件服务器</p><ul><li>需要更大的硬盘</li></ul><h3 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h3><ul><li>本地缓存</li><li>远程缓存（分布式缓存）</li></ul><h3 id="使用应用服务器集群改善并发处理能力"><a href="#使用应用服务器集群改善并发处理能力" class="headerlink" title="使用应用服务器集群改善并发处理能力"></a>使用应用服务器集群改善并发处理能力</h3><ul><li>负载均衡服务器</li><li>用户服务器集群</li></ul><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>利用数据库的主从热备份，来实现数据库的读写分离。从而改善数据库的负载压力。</p><h3 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h3><blockquote><p>基本原理都是缓存（都可以缓存一些静态资源）</p></blockquote><p>反向代理服务器</p><ul><li>缓存用户请求资源</li></ul><p>CDN服务器</p><ul><li>目的：尽早返回数据给用户</li></ul><h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3><p>分布式数据库是网站数据库拆分的最后手段。不到万不得已的时网站更常用的拆分手段是业务拆分。</p><h3 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h3><p>应对更复杂的存储和检索需求</p><h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><blockquote><p>应对日益复杂的业务场景</p></blockquote><p>拆分方法</p><ul><li>根据产品线拆分成不同的应用</li></ul><p>应用产品之间的关系</p><ul><li>超链接</li><li>消息队列进行数据分发</li><li>访问同一个数据存储系统</li></ul><h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><p>通过分布式服务调用公用业务服务完成具体业务需要</p><h2 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul><li>应用层</li><li>服务层</li><li>数据层</li></ul><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>对不同的层继续进行垂直的分割</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><blockquote><p>分层、分割的主要目的就是为了便于分布式部署。</p><p>分布式就是为了用更多的计算机来完成同样的功能</p></blockquote><ul><li>分布式应用和服务</li><li>分布式静态资源</li><li>分布式数据和存储</li><li>分布式计算</li><li>分布式配置</li><li>分布式文件系统</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><blockquote><p>多台服务器部署相同应用构成一个集群。通过负载均衡设备对外提供服务</p></blockquote><p>有点：</p><ul><li>提高系统并发访问量</li><li>提高系统可用性（冗余）</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><blockquote><p>改善性能的第一手段</p></blockquote><ul><li>内容分发网络CDN</li><li>反向代理</li><li>本地缓存</li><li>分布式缓存</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li>共享内存队列（单服务器）</li><li>分布式消息队列(分布式系统)</li></ul><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>访问和负载很小的服务器也至少要部署两台构成集群。目的就是实现服务的高可用。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><ul><li>自动化报警</li><li>自动化失效转移</li><li>自动化失效恢复</li><li>自动化降级</li><li>自动化分配资源</li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li>身份认证</li><li>加密</li><li>验证码识别</li><li>对于XSS，SQL注入，进行编码转换等</li><li>敏感信息过滤</li><li>风险控制</li></ul><h2 id="网站性能测试优化"><a href="#网站性能测试优化" class="headerlink" title="网站性能测试优化"></a>网站性能测试优化</h2><h3 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h3><ul><li>响应时间</li><li>并发数</li><li>吞吐量</li><li>性能计数器</li></ul><h3 id="性能测试方法"><a href="#性能测试方法" class="headerlink" title="性能测试方法"></a>性能测试方法</h3><ul><li>性能测试</li><li>负载测试</li><li>压力测试</li><li>稳定性测试</li></ul><h3 id="常见优化手段"><a href="#常见优化手段" class="headerlink" title="常见优化手段"></a>常见优化手段</h3><p>用户视角</p><ul><li>优化页面HTML样式</li><li>利用浏览器的并发和异步</li><li>调整浏览器缓存策略</li><li>CDN和反向代理</li></ul><p>开发人员</p><ul><li>使用缓存加速数据读取速度</li><li>使用集群提高系统吞吐能力</li><li>使用异步消息加速响应及实现消峰</li><li>优化代码改善程序性能</li></ul><p>运维人员</p><ul><li>优化骨干网</li><li>使用高性价比定制服务器</li><li>使用虚拟化技术优化资源利用</li></ul><h3 id="网站性能优化"><a href="#网站性能优化" class="headerlink" title="网站性能优化"></a>网站性能优化</h3><p>web性能优化</p><ul><li>减少HTTP请求（合并css、javascript、图片）</li><li>使用浏览器缓存（使用Cache-Control和Expire属性）</li><li>启用压缩（减少网络数据传输量）</li><li>减少页面阻塞（CSS文件尽量放在最上面，javascript放在最下面）</li><li>减少Cookie传输</li><li>CDN加速</li><li>反向代理<ul><li>安全</li><li>加速web请求（可以缓存一些静态资源）</li><li>负载均衡</li></ul></li></ul><p>应用服务器优化</p><ul><li><p>分布式缓存</p></li><li><p>异步操作（消息队列）</p><blockquote><p>原则：任何可以晚点在做的事都可以晚点再做</p></blockquote></li><li><p>使用集群</p><blockquote><p>使用负载均衡技术来构建</p></blockquote></li></ul><p>存储服务器优化</p><ul><li>访问频繁的页面不应该访问数据库（如首页，最好是静态的）</li><li>谨慎使用锁操作</li><li>对缓存的管理提高到和其他服务器一样的级别</li><li>大文件小文件分别对待</li></ul><h2 id="大型网站架构设计误区"><a href="#大型网站架构设计误区" class="headerlink" title="大型网站架构设计误区"></a>大型网站架构设计误区</h2><ul><li>一味追求大公司的解决方案</li><li>为了技术而技术</li><li>企图用技术解决所有问题</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161013/DaXingWangZhanJiShuJiaGouPouXi.jpg&quot; alt=&quot;大型网站技术架构剖析&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;大型网站系统特点&quot;&gt;&lt;a href=&quot;#大型网站系统特点&quot; class=&quot;headerlink&quot; title=&quot;大型网站系统特点&quot;&gt;&lt;/a&gt;大型网站系统特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高并发，大流量&lt;/li&gt;
&lt;li&gt;高可用&lt;/li&gt;
&lt;li&gt;海量数据&lt;/li&gt;
&lt;li&gt;用户分布广泛，网络情况复杂&lt;/li&gt;
&lt;li&gt;安全环境恶略&lt;/li&gt;
&lt;li&gt;需求快速变更，发布频繁&lt;/li&gt;
&lt;li&gt;渐进式发展&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="架构" scheme="https://weizhimiao.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP魔术方法小结</title>
    <link href="https://weizhimiao.github.io/2016/10/12/PHP%E7%9A%84MVC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://weizhimiao.github.io/2016/10/12/PHP%E7%9A%84MVC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2016-10-12T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>MVC模式，即模型-试图-控制器模式，是将应用程序划分成不同层次的一种方式。</p><p>即，</p><table><thead><tr><th>C</th><th>Control</th><th>控制器层</th><th>负责业务逻辑的处理。根据用户的请求确定用户可以做什么。之后，调用模型执行操作获得数据。最后调用视图将操作结果呈现给用户。</th></tr></thead><tbody><tr><td>M</td><td>Model</td><td>模型层</td><td>负责加工处理数据 返回结果。</td></tr><tr><td>V</td><td>View</td><td>视图层</td><td>负责接收信息和显示信息。</td></tr></tbody></table><p>一个典型MVC应用程序流程图</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161013/mvcYingYongChengXuLiuChengTu.png" alt="典型MVC应用程序流程图"></p><span id="more"></span><h2 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h2><h3 id="文件结构："><a href="#文件结构：" class="headerlink" title="文件结构："></a>文件结构：</h3><pre><code>$ tree shop         shop├── Control│   ├── FlinkControl.class.php│   ├── GoodsControl.class.php│   ├── IndexControl.class.php│   ├── NewsControl.class.php│   ├── OrderControl.class.php│   └── UserControl.class.php├── Model│   ├── MemcacheModel.class.php│   └── MysqlModel.class.php├── Org│   └── Vcode.class.php├── Views├── index.php└── readme4 directories, 11 files</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>Model  文件夹    模型层的Model类（操作数据 MYSQL、Memcached...）Org    文件夹      模型层的其他类(不操作数据 分页/验证码...)Controls文件夹      控制器层的类Views  文件夹      视图层(html页面)</code></pre><h3 id="主要文件内容："><a href="#主要文件内容：" class="headerlink" title="主要文件内容："></a>主要文件内容：</h3><p>index.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token comment" spellcheck="true">//类的自动加载</span>    <span class="token keyword">function</span> <span class="token function">__autoload</span><span class="token punctuation">(</span><span class="token variable">$className</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">//包含控制器的类</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$className</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'control'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">include</span> <span class="token string">'Control/'</span><span class="token punctuation">.</span><span class="token variable">$className</span><span class="token punctuation">.</span><span class="token string">'.class.php'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;elseif(strtolower(substr($className,-5))==</span><span class="token string">'model'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">include</span> <span class="token string">'Model/'</span><span class="token punctuation">.</span><span class="token variable">$className</span><span class="token punctuation">.</span><span class="token string">'.class.php'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>            <span class="token keyword">include</span> <span class="token string">'Org/'</span><span class="token punctuation">.</span><span class="token variable">$className</span><span class="token punctuation">.</span><span class="token string">'.class.php'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">//如何调用控制器</span>    <span class="token comment" spellcheck="true">//index.php?m=user&amp;a=add      表示调用用户类中的添加用户方法</span>    <span class="token comment" spellcheck="true">//index.php?m=goods&amp;a=drop    表示调用商品类中的删除商品方法</span>    <span class="token comment" spellcheck="true">//index.php?m=user&amp;a=add  </span>    <span class="token comment" spellcheck="true">//m=user ->调用UserControl类</span>    <span class="token variable">$class</span><span class="token operator">=</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token string">'Index'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//$class=user;</span>    <span class="token variable">$class</span><span class="token operator">=</span><span class="token function">ucfirst</span><span class="token punctuation">(</span><span class="token variable">$class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//$class=User;</span>    <span class="token variable">$class</span><span class="token punctuation">.</span><span class="token operator">=</span><span class="token string">'Control'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//$class=UserControl</span>    <span class="token comment" spellcheck="true">//a=add -> add</span>    <span class="token variable">$method</span><span class="token operator">=</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token string">'index'</span><span class="token punctuation">;</span>    <span class="token variable">$one</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token variable">$class</span><span class="token punctuation">;</span>    <span class="token variable">$one</span><span class="token operator">-</span><span class="token operator">></span><span class="token variable">$method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Control/UserControl.class.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">class</span> <span class="token class-name">UserControl</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">//控制器不需用属性！！！1</span>        <span class="token comment" spellcheck="true">//默认的方法index</span>        <span class="token keyword">function</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">//实例化一个模型层的扩展类</span>            <span class="token keyword">echo</span> <span class="token keyword">new</span> <span class="token class-name">Vcode</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token string">'显示用户列表'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//添加用户</span>        <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">//调用Model 查询友情连接信息</span>            <span class="token variable">$mysql</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MysqlModel</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用Model类的方法</span>            <span class="token variable">$mysql</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token string">'添加用户操作'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//删除用户</span>        <span class="token keyword">function</span> <span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'删除用户操作'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//修改用户</span>        <span class="token keyword">function</span> <span class="token function">mod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'修改用户操作'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//查询用户</span>        <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'查询用户操作'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Model/MysqlModel.class.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">class</span> <span class="token class-name">MysqlModel</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">//连接数据库的方法</span>        <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'连接数据库中&lt;br>'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//使用数据库进行查询操作</span>        <span class="token keyword">function</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'使用数据库进行查询操作&lt;br>'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//使用数据库进行删除操作</span>        <span class="token keyword">function</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'使用数据库进行删除操作&lt;br>'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//使用数据库进行修改操作</span>        <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'使用数据库进行修改操作&lt;br>'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">//使用数据库进行添加操作</span>        <span class="token keyword">function</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'使用数据库进行添加操作&lt;br>'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token keyword">echo</span> <span class="token string">'断开数据库连接'</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Org/Vcode.class.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">class</span>  <span class="token class-name">Vcode</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">private</span> <span class="token variable">$width</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//验证码图片的宽度</span>        <span class="token keyword">private</span> <span class="token variable">$height</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">//验证码图片的高度</span>        <span class="token keyword">private</span> <span class="token variable">$codeNum</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//验证码字符的个数</span>        <span class="token keyword">private</span> <span class="token variable">$disturbColorNum</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//干扰元素数量</span>        <span class="token keyword">private</span> <span class="token variable">$checkCode</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">//验证码字符</span>        <span class="token keyword">private</span> <span class="token variable">$image</span><span class="token punctuation">;</span>                               <span class="token comment" spellcheck="true">//验证码资源</span>        <span class="token comment" spellcheck="true">/**         * 构造方法用来实例化验证码对象，并为一些成员属性初使化                * @param    int    $width        设置验证码图片的宽度，默认宽度值为80像素                 * @param    int    $height        设置验证码图片的高度，默认高度值为20像素                * @param    int    $codeNum    设置验证码中字母和数字的个数，默认个数为4个           */</span>        <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$width</span><span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token variable">$height</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token variable">$codeNum</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token operator">=</span><span class="token variable">$width</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//为成员属性width初使化</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token operator">=</span><span class="token variable">$height</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//为成员属性height初使化</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">codeNum</span><span class="token operator">=</span><span class="token variable">$codeNum</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//为成员属性codeNum初使化</span>            <span class="token variable">$number</span><span class="token operator">=</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$height</span><span class="token operator">*</span><span class="token variable">$width</span><span class="token operator">/</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$number</span> <span class="token operator">></span> <span class="token number">240</span><span class="token operator">-</span><span class="token variable">$codeNum</span><span class="token punctuation">)</span>                <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">disturbColorNum</span><span class="token operator">=</span><span class="token number">240</span><span class="token operator">-</span><span class="token variable">$codeNum</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">disturbColorNum</span><span class="token operator">=</span><span class="token variable">$number</span><span class="token punctuation">;</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">checkCode</span><span class="token operator">=</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">createCheckCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//为成员属性checkCode初使化</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token comment" spellcheck="true">/**         * 用于输出验证码图片，也向服务器的SESSION中保存了验证码         * 使用echo 输出对象即可         * @return string    验证码         */</span>        <span class="token keyword">function</span> <span class="token function">__toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>            <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">"code"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">strtoupper</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">checkCode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//加到session中</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">outImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//输出验证码</span>            <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">outImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;                       </span><span class="token comment" spellcheck="true">//通过访问该方法向浏览器中输出图像</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getCreateImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//调用内部方法创建画布并对其进行初使化</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setDisturbColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//向图像中设置一些干扰像素</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">outputText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//向图像中输出随机的字符串</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">outputImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//生成相应格式的图像并输出</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">getCreateImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;              </span><span class="token comment" spellcheck="true">//用来创建图像资源，并初使化背影</span>            <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token operator">=</span><span class="token function">imagecreatetruecolor</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$backColor</span> <span class="token operator">=</span> <span class="token function">imagecolorallocate</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">225</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">225</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">225</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//背景色（随机）</span>             @<span class="token function">imagefill</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$backColor</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$border</span><span class="token operator">=</span><span class="token function">imageColorAllocate</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">imageRectangle</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token number">-1</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token number">-1</span><span class="token punctuation">,</span><span class="token variable">$border</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">createCheckCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;           </span>            <span class="token comment" spellcheck="true">//随机生成用户指定个数的字符串,去掉了容易混淆的字符oOLlz和数字012</span>            <span class="token variable">$code</span><span class="token operator">=</span><span class="token string">"3456789abcdefghijkmnpqrstuvwxyABCDEFGHIJKMNPQRSTUVWXY"</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token markup">&lt;$this-></span>codeNum<span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$char</span><span class="token operator">=</span><span class="token variable">$code</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;rand(0,strlen($code)-1)&amp;#125;;</span>                <span class="token variable">$ascii</span><span class="token punctuation">.</span><span class="token operator">=</span><span class="token variable">$char</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>            <span class="token keyword">return</span> <span class="token variable">$ascii</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">setDisturbColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;    </span>            <span class="token comment" spellcheck="true">//设置干扰像素，向图像中输出不同颜色的100个点</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token markup">&lt;=$this-></span>disturbColorNum<span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$color</span> <span class="token operator">=</span> <span class="token function">imagecolorallocate</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token function">imagesetpixel</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token variable">$color</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$color</span><span class="token operator">=</span><span class="token function">imagecolorallocate</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">imagearc</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token variable">$color</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;  </span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">outputText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;       </span>            <span class="token comment" spellcheck="true">//随机颜色、随机摆放、随机字符串向图像中输出</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token markup">&lt;=$this-></span>codeNum<span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>                <span class="token variable">$fontcolor</span> <span class="token operator">=</span> <span class="token function">imagecolorallocate</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token variable">$fontSize</span><span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token variable">$x</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">width</span><span class="token operator">/</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">codeNum</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token variable">$i</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span>                   <span class="token variable">$y</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">height</span><span class="token operator">-</span><span class="token function">imagefontheight</span><span class="token punctuation">(</span><span class="token variable">$fontSize</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">imagechar</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token variable">$fontSize</span><span class="token punctuation">,</span> <span class="token variable">$x</span><span class="token punctuation">,</span> <span class="token variable">$y</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">checkCode</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;$i&amp;#125;, $fontcolor);</span>               <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">outputImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;              </span>            <span class="token comment" spellcheck="true">//自动检测GD支持的图像类型，并输出图像</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">imagetypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">IMG_GIF</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;          </span><span class="token comment" spellcheck="true">//判断生成GIF格式图像的函数是否存在</span>                <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-type: image/gif"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//发送标头信息设置MIME类型为image/gif</span>                <span class="token function">imagegif</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//以GIF格式将图像输出到浏览器</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;elseif(imagetypes() &amp; IMG_JPG)&amp;#123;      </span><span class="token comment" spellcheck="true">//判断生成JPG格式图像的函数是否存在</span>                <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-type: image/jpeg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//发送标头信息设置MIME类型为image/jpeg</span>                <span class="token function">imagejpeg</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//以JPEN格式将图像输出到浏览器</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;elseif(imagetypes() &amp; IMG_PNG)&amp;#123;     </span><span class="token comment" spellcheck="true">//判断生成PNG格式图像的函数是否存在</span>                <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-type: image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//发送标头信息设置MIME类型为image/png</span>                <span class="token function">imagepng</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//以PNG格式将图像输出到浏览器</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;elseif(imagetypes() &amp; IMG_WBMP)&amp;#123;   </span><span class="token comment" spellcheck="true">//判断生成WBMP格式图像的函数是否存在</span>                 <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-type: image/vnd.wap.wbmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//发送标头为image/wbmp</span>                 <span class="token function">imagewbmp</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//以WBMP格式将图像输出到浏览器</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;                              </span><span class="token comment" spellcheck="true">//如果没有支持的图像类型</span>                <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"PHP不支持图像创建！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不输出图像，输出一错误消息，并退出程序</span>            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;                      </span><span class="token comment" spellcheck="true">//当对象结束之前销毁图像资源释放内存</span>             <span class="token function">imagedestroy</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">image</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用GD库中的方法销毁图像资源</span>        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;MVC模式，即模型-试图-控制器模式，是将应用程序划分成不同层次的一种方式。&lt;/p&gt;
&lt;p&gt;即，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;Control&lt;/th&gt;
&lt;th&gt;控制器层&lt;/th&gt;
&lt;th&gt;负责业务逻辑的处理。根据用户的请求确定用户可以做什么。之后，调用模型执行操作获得数据。最后调用视图将操作结果呈现给用户。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;Model&lt;/td&gt;
&lt;td&gt;模型层&lt;/td&gt;
&lt;td&gt;负责加工处理数据 返回结果。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;View&lt;/td&gt;
&lt;td&gt;视图层&lt;/td&gt;
&lt;td&gt;负责接收信息和显示信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;一个典型MVC应用程序流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161013/mvcYingYongChengXuLiuChengTu.png&quot; alt=&quot;典型MVC应用程序流程图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="MVC" scheme="https://weizhimiao.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>PHP扩展与应用库(PEAR)</title>
    <link href="https://weizhimiao.github.io/2016/10/12/PHP%E6%89%A9%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BA%93(PEAR)/"/>
    <id>https://weizhimiao.github.io/2016/10/12/PHP%E6%89%A9%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BA%93(PEAR)/</id>
    <published>2016-10-12T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>PEAR（the PHP Extension and Application Repository），PHP扩展与应用库。它是一个PHP扩展及应用的一个代码仓库。所有的扩展均以PHP代码的形式出现，功能强大，安装简单，甚至可以改改就用。使用的时候，要在代码中进行Include才能够使用。</p><p>官网：</p><p><a href="http://pear.php.net/">http://pear.php.net</a></p><span id="more"></span><h2 id="PEAR安装和使用"><a href="#PEAR安装和使用" class="headerlink" title="PEAR安装和使用"></a>PEAR安装和使用</h2><p>在官网上有说明详细的安装信息，这里作简单说明。<br><a href="http://pear.php.net/manual/en/about-pear.php">http://pear.php.net/manual/en/about-pear.php</a></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>#curl -o go-pear.php  <a href="http://pear.php.net/go-pear">http://pear.php.net/go-pear</a></p><pre><code>$ curl -o go-pear.php  http://pear.php.net/go-pear  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100 88959  100 88959    0     0  43329      0  0:00:02  0:00:02 --:--:-- 43352</code></pre><h3 id="运行go-pear-php"><a href="#运行go-pear-php" class="headerlink" title="运行go-pear.php"></a>运行go-pear.php</h3><pre><code># /usr/local/php5/bin/php go-pear.php</code></pre><h3 id="利用PEAR安装PHPDOC"><a href="#利用PEAR安装PHPDOC" class="headerlink" title="利用PEAR安装PHPDOC"></a>利用PEAR安装PHPDOC</h3><pre><code>$ pear install phpdoc/phpDocumentor-alphaAttempting to discover channel &quot;phpdoc&quot;...Attempting fallback to https instead of http on channel &quot;phpdoc&quot;...unknown channel &quot;phpdoc&quot; in &quot;phpdoc/phpDocumentor-alpha&quot;invalid package name/package file &quot;phpdoc/phpDocumentor-alpha&quot;install failed</code></pre><p>如出现上面错误，需要我们增加一个phpDocumentor pear渠道</p><pre><code>$ pear channel-discover pear.phpdoc.orgAdding Channel &quot;pear.phpdoc.org&quot; succeededDiscovery of channel &quot;pear.phpdoc.org&quot; succeeded</code></pre><p>重新安装</p><pre><code>$ pear install phpdoc/phpDocumentor-alphadownloading phpDocumentor-2.8.5.tgz ...Starting to download phpDocumentor-2.8.5.tgz (8,184,822 bytes).................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................done: 8,184,822 bytesinstall ok: channel://pear.phpdoc.org/phpDocumentor-2.8.5</code></pre><p>查看是否安装成功</p><pre><code>$ phpdoc -VphpDocumentor version 2.8.5</code></pre><h2 id="PEAR常用功能及命令"><a href="#PEAR常用功能及命令" class="headerlink" title="PEAR常用功能及命令"></a>PEAR常用功能及命令</h2><pre><code>$ phpdoc --helpUsage: project:run [-t|--target[=&quot;...&quot;]] [--cache-folder[=&quot;...&quot;]] [-f|--filename[=&quot;...&quot;]] [-d|--directory[=&quot;...&quot;]] [--encoding[=&quot;...&quot;]] [-e|--extensions[=&quot;...&quot;]] [-i|--ignore[=&quot;...&quot;]] [--ignore-tags[=&quot;...&quot;]] [--hidden] [--ignore-symlinks] [-m|--markers[=&quot;...&quot;]] [--title[=&quot;...&quot;]] [--force] [--validate] [--visibility[=&quot;...&quot;]] [--defaultpackagename[=&quot;...&quot;]] [--sourcecode] [-p|--progressbar] [--template[=&quot;...&quot;]] [--parseprivate] [--log[=&quot;...&quot;]]Aliases: runOptions: --target (-t)         模板文件生成路径 --cache-folder        缓存文件路径 --filename (-f)       要解析的文件的逗号分隔列表。 通配符？ 和*（支持多个值） --directory (-d)      逗号分隔的目录列表（递归）解析（允许多个值） --encoding            编码用于解释源文件 --extensions (-e)     以逗号分隔的解析扩展列表，默认为php，php3和phtml（允许多个值） --ignore (-i)         以逗号分隔的将被忽略的文件和目录（相对于源代码目录）列表。 通配符*和？ 支持（允许多个值） --ignore-tags         将忽略的逗号分隔的标签列表，默认为none。 package，subpackage和ignore不能被忽略。 （允许多个值） --hidden              使用此选项可以告诉phpDocumentor解析以句点（。）开头的文件和目录，默认情况下这些被忽略 --ignore-symlinks     忽略到其他文件或目录的符号链接，默认值为on --markers (-m)        要过滤的标记/标记的逗号分隔列表（允许多个值） --title               设置此项目的标题; 默认是phpDocumentor标志 --force               强制完整构建文档，不会增加现有文档 --validate            使用PHP Lint验证每个处理的文件，成本很高的性能 --visibility          指定应在文档中显示的解析可见性（逗号分隔，例如“public，protected”）（允许多个值） --defaultpackagename  用于默认软件包的名称。(default: &quot;Default&quot;) --sourcecode          是否包含语法高亮的源代码 --progressbar (-p)    是否显示进度条; 将自动静默记录到stdout --template            要使用的模板的名称（可选）（允许多个值） --parseprivate        是否解析标记有@internal标签的DocBlocks --log                 要写入的日志文件 --help (-h)           显示此帮助消息 --quiet (-q)          不输出任何消息 --verbose (-v|vv|vvv) 增加消息的详细程度：1用于正常输出，2用于更详细的输出，3用于调试 --version (-V)        显示此应用程序版本 --ansi                强制ANSI输出 --no-ansi             禁用ANSI输出 --no-interaction (-n) 不要问任何互动问题 --config (-c)         自定义配置文件的位置Help:  phpDocumentor从PHP源文件创建文档。 最简单的方法  使用它是：     $ phpdoc run -d [directory to parse] -t [output directory] 这将解析在&lt;directory to parse&gt;中以.php，.php3和.phtml结尾的每个文件，然后在&lt;output directory&gt;中输出一个包含易于阅读的文档的HTML网站。 phpDocumentor will try to look for a phpdoc.dist.xml or phpdoc.xml file in your current working directory and use that to override the default settings if present. In the configuration file can you specify the same settings (and more) as the command line provides.phpDocumentor将尝试在当前工作目录中查找phpdoc.dist.xml或phpdoc.xml文件，并使用该文件覆盖默认设置（如果存在）。 在配置文件中，您可以指定与命令行提供的相同的设置（和更多）。 Other commands 除了这个命令phpDocumentor还支持附加命令： Available commands:   help   list   parse   run   transform project   project:parse   project:run   project:transform template   template:generate   template:list   template:package您可以使用list命令获取更详细的命令列表，并通过在命令名前添加help来获取帮助。</code></pre><h2 id="常用的PEAR模块简介"><a href="#常用的PEAR模块简介" class="headerlink" title="常用的PEAR模块简介"></a>常用的PEAR模块简介</h2><ul><li><p>Benchmark/Timer 测试你的一段php代码的运行效率  </p></li><li><p>Benchmark/Benchmark_Iterate 测试你某个函数循环执行时的性能  </p></li><li><p>Cache/Output 可以将你的php脚本的输出进行缓存，可以使用多种方式缓存（存在文件，数据库或者是共享内存中）,如果使用这个模块有可能增大服务器的负载，所以，如果你想通过动态脚本的缓存来提供效率，不妨使用Zend optimize,这个模块未必适合  </p></li><li><p>Cache/Graphics 可以将你需要动态输出的图片进行缓存  </p></li><li><p>Console/Getopt 命令行参数的处理模块  </p></li><li><p>CMD 一个虚拟的shell，可以用它来运行一些系统的命令  </p></li><li><p>Crypt/CBC 实现Perl Crypt::CBC 模块的仿真  </p></li><li><p>Crypt/HCEMD5 实现Perl Crypt::HCE_MD5 模块的功能  </p></li><li><p>Date/Calc 实现日期的相关操作  </p></li><li><p>Date/Human Human历法的转换  </p></li><li><p>DB 提供统一的、抽象的数据库操作层，后端支持多种数据库  </p></li><li><p>File/Find 文件查找  </p></li><li><p>File/Passwd 操纵password类的文件，如password,httppass,cvspassword  </p></li><li><p>File/SearchReplace 在文件中查找替换字符串  </p></li><li><p>HTML/Form 可以在html中快速地创建form  </p></li><li><p>HTML/IT 实现模板定制，动态生成页面的功能，类似phplib中的模板功能，但是要简单易用  </p></li><li><p>HTML/ITX 实现对IT的扩展功能，可以更加灵活地定制你的模板，实现更复杂的操作  </p></li><li><p>HTML/Processor XML_Parser的扩展，使之可以应用于html文件的操作  </p></li><li><p>HTTP/Compress 用于Php 输出缓冲机制的一个包装类，同时可以对缓冲的内容进行压缩存储  </p></li><li><p>Image/Remote 无需把整个图片都下载到本地就可以获取远端系统的图片的信息，  </p></li><li><p>Log/composite Horde对log抽象类做的一个扩展，可以使多个日志处理对象能够获得同一个日志事件。注意，Log目录下面的模块都是Horde项目的一部分，大部分都是抽象的超类  </p></li><li><p>Log/file 将日志信息写入文件  </p></li><li><p>Log/mcal 将信息发送到本地或远端的日程管理软件-mcal的数据库中  </p></li><li><p>Log/observer Horder中Observer的一个超类  </p></li><li><p>Log/sql 将日志信息发送到sql数据库中  </p></li><li><p>Log/syslog 将信息发送到syslog中  </p></li><li><p>Mail/RFC822 检查一个email地址是否是合法的rf822 email地址  </p></li><li><p>Mail/sendmail 使用sendmail来发送信件  </p></li><li><p>Mail/smtp 使用smtp服务器来发送信件  </p></li><li><p>Math/Fraction 处理分形的数学计算  </p></li><li><p>Math/Util 计算最大公约数  </p></li><li><p>NET/Curl 对php的Curl扩展所作的面向对象的包装  </p></li><li><p>NET/Dig 操纵dig，进行dns相关的查询操作  </p></li><li><p>NET/SMTP 使用NET/Socket实现SMTP协议  </p></li><li><p>NET/Socket 通用的Socket类，实现了常用的socket操作的包装  </p></li><li><p>Numbers/Roman 阿拉伯数字和罗马数字的相互转换  </p></li><li><p>Payment/Verisign 实现和Verisign支付网关的交互  </p></li><li><p>Pear 提供Pear模块的2个基本类，PEAR 和PEARError类  </p></li><li><p>PEAR/Installer pear的安装类，提供Perl中的CPAN模块类似的功能  </p></li><li><p>PHPDoc 从php代码中自动生成API文档  </p></li><li><p>Schedule/at 和Unix 上的AT守护进程进行交互  </p></li><li><p>XML/Parser 基于php的xml扩展所作的xml的解析器  </p></li><li><p>XML/Render 将xml文档生成其它的格式（html,pdf),这只是一个抽象类，在最新的pear cvs代码中已经有了html的实现  </p></li><li><p>XML/RPC 用php实现xml-rpc的一个抽象类，在最新的pear cvs代码中已经有了xml/RPC/Server的实现  </p></li></ul><h2 id="PEAR与PECL关系"><a href="#PEAR与PECL关系" class="headerlink" title="PEAR与PECL关系"></a>PEAR与PECL关系</h2><p>PEAR（the PHP Extension and Application Repository），PHP扩展与应用库。它是一个PHP扩展及应用的一个代码仓库。</p><p>PECL（PHP Extension Community Library），PHP的扩展库。它提供了一系列已知的扩展库，由C、C++等其他语言编写而成，以.so形式出现，.so 为共享库,是shared object,用于动态连接的,和dll差不多，为比PEAR更快，但是与PEAR不同的是，PECL需要在服务器上配置并被注册到主机中。</p><p>基于他们的实现方式不同，在使用时候也有不同。</p><p>Pear：是PHP的扩展代码包，所有的扩展均以PHP代码的形式出现，功能强大，安装简单，甚至可以改改就用。使用的时候，要在代码中进行Include才能够使用。</p><p>Pecl：是PHP的标准扩展，可以补充实际开发中所需的功能，所有的扩展都需要安装，在Windows下面以Dll的形式出现，在linux下面，需要单独进行编译，它的表现形式为根据PHP官方的标准用C语言写成，尽管源码开放但是一般人无法随意更改源码。</p><p><strong>最直接的表述：Pear是PHP的上层扩展，Pecl是PHP的底层扩展。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PEAR（the PHP Extension and Application Repository），PHP扩展与应用库。它是一个PHP扩展及应用的一个代码仓库。所有的扩展均以PHP代码的形式出现，功能强大，安装简单，甚至可以改改就用。使用的时候，要在代码中进行Include才能够使用。&lt;/p&gt;
&lt;p&gt;官网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pear.php.net/&quot;&gt;http://pear.php.net&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="PEAR" scheme="https://weizhimiao.github.io/tags/PEAR/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用工具命令之rsync</title>
    <link href="https://weizhimiao.github.io/2016/10/08/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E4%B9%8Brsync/"/>
    <id>https://weizhimiao.github.io/2016/10/08/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E4%B9%8Brsync/</id>
    <published>2016-10-08T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。<br>rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。<br>rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。</p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>rsync [OPTION]... SRC DESTrsync [OPTION]... SRC [USER@]host:DESTrsync [OPTION]... [USER@]HOST:SRC DESTrsync [OPTION]... [USER@]HOST::SRC DESTrsync [OPTION]... SRC [USER@]HOST::DESTrsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</code></pre><p>对应于以上六种命令格式,rsync有六种不同的工作模式:</p><ol><li><p>拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号”:”分隔符时就启动这种工作模式。如: <code>rsync­ -a /data /backup</code></p></li><li><p>使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒 号”:”分隔符时启动该模式。如: <code>rsync­ -avz *.c foo:src</code></p></li><li><p>使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒 号”:”分隔符时启动该模式。如: <code>rsync -­avz foo:src/bar /data</code></p></li><li><p>从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。如: <code>rsync- ­av root@192.168.78.192::www /databack</code></p></li><li><p>从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。如: <code>rsync­- av /databack root@192.168.78.192::www</code></p></li><li><p>列远程机的文件列表。这类似于rsync传输,不过只要在命令中省略掉本地机信息即可。如: <code>rsync­ -v rsync://192.168.78.192/www</code></p></li></ol><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><pre><code>­-v, --­­verbose 详细模式输出。­-q, ­­--quiet 精简输出模式。­-c, ­­--checksum 打开校验开关,强制对文件传输进行校验。­-a, ­­--archive 归档模式,表示以递归方式传输文件,并保持所有文件属性,等于­rlptgoD。 ­-r, ­­--recursive 对子目录以递归模式处理。-­R, ­­--relative 使用相对路径信息。­-b, ­­--backup 创建备份,也就是对于目的已经存在有同样的文件名时,将老的文件重新命名为~filename。可以使用­­ suffix选项来指定不同的备份文件前缀。--­­backup­-dir 将备份文件(如~filename)存放在在目录下。-­suffix=SUFFIX 定义备份文件前缀。­-u, ­­--update 仅仅进行更新,也就是跳过所有已经存在于DST,并且文件时间晚于要备份的文件,不覆盖更新的文件。 ­-l, ­­--links 保留软链结。-­L, ­­--copy-links 想对待常规文件一样处理软链结。­--­copy-­unsafe-­links 仅仅拷贝指向SRC路径目录树以外的链结。­­--safe-­links 忽略指向SRC路径目录树以外的链结。­-H, ­­--hard-­links 保留硬链结。­-p, ­­--perms 保持文件权限。­-o, ­­--owner 保持文件属主信息。­-g, ­­--group 保持文件属组信息。­-D, ­­--devices 保持设备文件信息。­-t, ­­--times 保持文件时间信息。­-S, ­­--sparse 对稀疏文件进行特殊处理以节省DST的空间。­-n, ­­--dry­-run现实哪些文件将被传输。­-w, ­­--whole-file 拷贝文件,不进行增量检测。­-x, ­­-one-file-system 不要跨越文件系统边界。­-B, ­­--block­-size=SIZE 检验算法使用的块尺寸,默认是700字节。­-e, ­­--rsh=command 指定使用rsh、ssh方式进行数据同步。­--­rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。­-C, ­­--cvs-­exclude 使用和CVS一样的方法自动忽略文件,用来排除那些不希望传输的文件。­­--existing 仅仅更新那些已经存在于DST的文件,而不备份那些新创建的文件。­­--delete 删除那些DST中SRC没有的文件。­­--delete-­excluded 同样删除接收端那些被该选项指定排除的文件。­­--delete-after 传输结束以后再删除。­­--ignore-­errors 及时出现IO错误也进行删除。­­--max-delete=NUM 最多删除NUM个文件。­­--partial 保留那些因故没有完全传输的文件,以是加快随后的再次传输。­­--force 强制删除目录,即使不为空。­­--numeric-ids 不将数字的用户和组id匹配为用户名和组名。­­--timeout=time ip超时时间,单位为秒。­-I, --­­ignore-times 不跳过那些有同样的时间和长度的文件。­­--size-­only 当决定是否要备份文件时,仅仅察看文件大小而不考虑文件时间。­­--modify-­window=NUM 决定文件是否时间相同时使用的时间戳窗口,默认为0。­-T --­­temp-dir=DIR 在DIR中创建临时文件。­­--compare-­dest=DIR 同样比较DIR中的文件来决定是否需要备份。­-P等同于 ­--­partial。­­-progress 显示备份过程。­-z, ­--­compress 对备份的文件在传输时进行压缩处理。­­--exclude=PATTERN 指定排除不需要传输的文件模式。­­--include=PATTERN 指定不排除而需要传输的文件模式。­­--exclude-­from=FILE 排除FILE中指定模式的文件。­­--include-­from=FILE 不排除FILE指定模式匹配的文件。­­--version 打印版本信息。­­--address 绑定到特定的地址。­­--config=FILE 指定其他的配置文件,不使用默认的rsyncd.conf文件。­­--port=PORT 指定其他的rsync服务端口。­­--blocking-io 对远程shell使用阻塞IO。­--stats 给出某些文件的传输状态。­­--progress 在传输时现实传输过程。­­--log-­format=formAT 指定日志文件格式。­­--password­-file=FILE 从FILE中得到密码。­­--bwlimit=KBPS 限制I/O带宽,KBytes per second。-­h, --­­help 显示帮助信息。</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="SSH方式"><a href="#SSH方式" class="headerlink" title="SSH方式"></a>SSH方式</h3><p>首先在服务端启动ssh服务:</p><pre><code>service sshd start启动 sshd: [确定]</code></pre><h3 id="使用rsync进行同步"><a href="#使用rsync进行同步" class="headerlink" title="使用rsync进行同步"></a>使用rsync进行同步</h3><p>接下来就可以在客户端使用rsync命令来备份服务端上的数据了,SSH方式是通过系统用户来进行备份的,如下:</p><pre><code>rsync ­vzrtopg ­­progress ­e ssh ­­delete work@172.16.78.192:/www/* /databack/experiment/rsyncwork@172.16.78.192&#39;s password:receiving file list ...5 files to considertest/a0 100% 0.00kB/s 527:35:41 (1, 20.0% of 5) b67 100% 65.43kB/s 0:00:00 (2, 40.0% of 5) c0 100% 0.00kB/s 527:35:41 (3, 60.0% of 5) dd100663296 100% 42.22MB/s 0:00:02 (4, 80.0% of 5) sent 96 bytes received 98190 bytes 11563.06 bytes/sec total size is 100663363 speedup is 1024.19</code></pre><p>上面的信息描述了整个的备份过程,以及总共备份数据的大小。</p><h3 id="后台服务方式"><a href="#后台服务方式" class="headerlink" title="后台服务方式"></a>后台服务方式</h3><p>启动rsync服务,编辑 /etc/xinetd.d/rsync文件,将其中的 disable=yes改为 disable=no,并重启 xinetd服务,如下:</p><pre><code>vi /etc/xinetd.d/rsync#default: off# description: The rsync server is a good addition to an ftp server, as it \ # allows crc checksumming etc.service rsync &#123;disable = nosocket_type = streamwait = nouser = rootserver = /usr/bin/rsyncserver_args = ­­daemonlog_on_failure += USERID&#125;</code></pre><pre><code>/etc/init.d/xinetd restart停止 xinetd: [确定]启动 xinetd: [确定]</code></pre><p>创建配置文件,默认安装好rsync程序后,并不会自动创建rsync的主配置文件,需要手工来创建,其主配置文件<br>为“/etc/rsyncd.conf”,创建该文件并插入如下内容:</p><pre><code>vi /etc/rsyncd.confuid=rootgid=rootmax connections=4log file=/var/log/rsyncd.log pid file=/var/run/rsyncd.pid lock file=/var/run/rsyncd.lock secrets file=/etc/rsyncd.passwd hosts deny=172.16.78.0/22[www]comment= backup web path=/wwwread only = no exclude=testauth users=work</code></pre><p>创建密码文件,采用这种方式不能使用系统用户对客户端进行认证,所以需要创建一个密码文件,其格式 为“username:password”,用户名可以和密码可以随便定义,最好不要和系统帐户一致,同时要把创建的密码文 件权限设置为600,这在前面的模块参数做了详细介绍。</p><pre><code>echo &quot;work:abc123&quot; &gt; /etc/rsyncd.passwdchmod 600 /etc/rsyncd.passwd</code></pre><p>备份,完成以上工作,现在就可以对数据进行备份了,如下:</p><pre><code>rsync ­avz ­­progress ­­delete work@172.16.78.192::www /databack/experiment/rsyncPassword:receiving file list ...6 files to consider./ files...a0 100% 0.00kB/s 528:20:41 (1, 50.0% of 6)b67 100% 65.43kB/s 0:00:00 (2, 66.7% of 6)c0 100% 0.00kB/s 528:20:41 (3, 83.3% of 6)dd100663296 100% 37.49MB/s 0:00:02 (4, 100.0% of 6) sent 172 bytes received 98276 bytes 17899.64 bytes/sec total size is 150995011 speedup is 1533.75</code></pre><p>恢复,当服务器的数据出现问题时,那么这时就需要通过客户端的数据对服务端进行恢复,但前提是服务端允许客 户端有写入权限,否则也不能在客户端直接对服务端进行恢复,使用rsync对数据进行恢复的方法如下:</p><pre><code>rsync ­avz ­­progress /databack/experiment/rsync/ work@172.16.78.192::wwwPassword:building file list ...6 files to consider./ab67 100% 0.00kB/s 0:00:00 (2, 66.7% of 6)csent 258 bytes received 76 bytes 95.43 bytes/sec total size is 150995011 speedup is 452080.87</code></pre><p>来自: <a href="http://man.linuxde.net/rsync">http://man.linuxde.net/rsync</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。&lt;br&gt;rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。&lt;br&gt;rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，我们下面就对它的选项一一进行分析说明。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="rsync" scheme="https://weizhimiao.github.io/tags/rsync/"/>
    
  </entry>
  
  <entry>
    <title>PHP输出缓冲区</title>
    <link href="https://weizhimiao.github.io/2016/10/07/PHP%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <id>https://weizhimiao.github.io/2016/10/07/PHP%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA/</id>
    <published>2016-10-07T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区?"></a>什么是缓冲区?</h2><p>简单而言,缓冲区的作用就是,把输入或者输出的内容先放进内存,而不显示或者读取.</p><p>其实缓冲区最本质的作用就是,协调高速CPU和相对缓慢的IO设备(磁盘等)的运作.</p><h2 id="PHP在执行的时候-在什么地方有用到缓冲区"><a href="#PHP在执行的时候-在什么地方有用到缓冲区" class="headerlink" title="PHP在执行的时候,在什么地方有用到缓冲区?"></a>PHP在执行的时候,在什么地方有用到缓冲区?</h2><p>想要了解PHP的缓冲区,就要知道执行PHP的时候,缓冲区被设置到了什么地方.</p><p>当执行PHP的时候,如果碰到了echo print_r之类的会输出数据的代码,PHP就会将要输出的数据放到PHP自身的缓冲区,等待输出.</p><p>当PHP自身的缓冲区接到指令,指示要输出缓冲区的内容时,将会把缓冲区内的数据输出到apache上, apache接受到PHP输出的数据,然后再把该数据存在到apache自身的缓冲区内,等到输出。</p><p>当apache接受到指令,只是要输出缓冲区的内容时, 将会把缓冲区的内容输出,返回到浏览器.</p><p>由此可见,PHP要输出数据的时候,将会经过两个缓冲区(先是自身的,然后是apache的),再返回到浏览器.</p><span id="more"></span><h2 id="缓冲区在PHP中起到什么作用"><a href="#缓冲区在PHP中起到什么作用" class="headerlink" title="缓冲区在PHP中起到什么作用?"></a>缓冲区在PHP中起到什么作用?</h2><h3 id="最常见的就是在使用header函数之前"><a href="#最常见的就是在使用header函数之前" class="headerlink" title="最常见的就是在使用header函数之前"></a>最常见的就是在使用header函数之前</h3><p>header();函数要求在其之前不能有输出。如在header之前有输出时会报错： Cannot modify header information – headers already sent by;</p><pre><code>echo &quot;this is test&quot;;header(&quot;LOCATION http://www.baidu.com&quot;);</code></pre><p>出现这个错误的原因是, 在header之前已经输出了某些数据,而输出这些数据的同时, apache将会同时发送一个响应状态到浏览器上(既然有输出,即这个请求是有效的),而其后你又再次使用header函数发送http头,则会返回这个错误,错误的意思是:HTTP头已经发送出去了,你不能对他再做修改.</p><p>为什么使用缓冲区可以避免这个错误呢?</p><p>因为header函数是不受缓冲区影响的,当一碰到header函数的时候,PHP马上执行apache发送这一个http头都浏览器.<br>而输出的数据PHP打开输出缓冲区后, 这些数据将会存放在缓冲区,等待输出.这样就可以避免了之前所发生的错误.</p><h3 id="通过PHP写文件下载程序的时候"><a href="#通过PHP写文件下载程序的时候" class="headerlink" title="通过PHP写文件下载程序的时候."></a>通过PHP写文件下载程序的时候.</h3><p>为了让文件下载更安全,同时提高更多的可控性,很多朋友都喜欢用PHP写文件下载页面.</p><p>其原理很简单,就是通过fwrite把文件内容读出并显示,然后通过header来发送HTTP头,让浏览器知道这是一个附件,这样就可以达到提供下载的效果.</p><p>如果用上面的办法提供下载页面,会碰到一个效率问题,如果一个文件很大,假设为100M,那么在不开启缓冲区输出的情况下,必须要把100M数据全部读出,然后一次返回到页面上,如果这样做,用户将会在所有数据读完之后才会得到响应,降低了用户体验感.</p><p>如果开启了输出缓冲区,当PHP程序读完文件的某一段,然后马上输出到apache,然后让apache马上返回到浏览器,这样就可以减少用户等待时间.</p><p>那后面的数据怎么办呢?</p><p>我们可以写一个while循环,一直一段一段地读取文件，每读一段,就马上输出,直到把文件全部输出为止,这样浏览器就可以持续地接受到数据,而不必等到所有文件读取完毕.</p><p>另外,该做法还解决了另外一个很严重的问题.</p><p>例如一个文件是100M,如果不开启缓冲区的情况下,则需要把100M文件全部读入内存,然后再输出.</p><p>但是,如果PHP程序做了内存限制呢?<br>为了保证服务器的稳定,管理员通常会把PHP的执行内存设一个限制(通过php.ini总的memory_limit, 其默认值是8M), 也就是每个PHP程序使用的内存不能使用超过这个值的内存.</p><p>假设该值为8M,而要读入的文件是100M,根本就没有足够的内存来读入该文件.这个时候,我们就需要用到上面的办法来解决这个问题,每次只读某一段,这样就可以避免了内存的限制</p><h3 id="静态文件缓存"><a href="#静态文件缓存" class="headerlink" title="静态文件缓存"></a>静态文件缓存</h3><p>现在很多公司有这么一个需求, 就是某一个页面在第一次访问的时候,会执行PHP,然后把显示的内容返回到浏览器,同时需要把这次显示的内容保存到服务器上,这样下次访问的时候,就直接把保存在服务器上的文件直接显示,而不需要通过PHP来做操作这就是所谓的”静态页面缓存”.</p><p>那怎么样才能做到把内容返回到浏览器的同时把数据保存到服务器上呢?</p><p>这就要用到输出缓冲区了.</p><pre><code>ob_start();echo &#39;aaa&#39;;$string = ob_get_contents();file_put_contents(&#39;a.html&#39;, $string);ob_flush();flush();</code></pre><h2 id="与输出缓冲区有关的配置"><a href="#与输出缓冲区有关的配置" class="headerlink" title="与输出缓冲区有关的配置"></a>与输出缓冲区有关的配置</h2><p>在PHP.INI中,有两个跟缓冲区紧密相关的配置项</p><h3 id="output-buffering"><a href="#output-buffering" class="headerlink" title="output_buffering"></a>output_buffering</h3><p>该配置直接影响的是php本身的缓冲区,有3种配置参数.on/off/xK(x为某个整型数值);</p><pre><code>on    - 开启缓冲区off    - 关闭缓冲区256k    - 开启缓冲区,而且当缓冲区的内容超过256k的时候,自动刷新缓冲区(把数据发送到apache);</code></pre><h3 id="implicit-flush"><a href="#implicit-flush" class="headerlink" title="implicit_flush"></a>implicit_flush</h3><p>该配置直接影响apache的缓冲区,有2种配置参数. on/off</p><pre><code>on    - 自动刷新apache缓冲区,也就是,当php发送数据到apache的缓冲区的时候,不需要等待其他指令,直接就把输出返回到浏览器off    - 不自动刷新apache缓冲区,接受到数据后,等待刷新指令</code></pre><h2 id="与缓冲区有关的函数"><a href="#与缓冲区有关的函数" class="headerlink" title="与缓冲区有关的函数"></a>与缓冲区有关的函数</h2><ul><li><p>ob_implicit_flush</p><blockquote><p>作用和implicit_flush一样,是否自动刷新apache的缓冲区</p></blockquote></li><li><p>flush</p><blockquote><p>作用是发送指令到apache,让apache刷新自身的输出缓冲区.</p></blockquote></li><li><p>ob_start</p><blockquote><p>打开输出缓冲区,无论php.ini的文件如何配置,如果使用该函数,即使output_buffering设置成off,也会打开输出缓冲区</p><p>ob_start函数还接受一个参数,该参数是一个函数的回调,意思是,在输入缓冲区内容之前,需要使用调用传递进来的参数把缓冲区的内容处理一次,再放入缓冲区内</p></blockquote></li><li><p>ob_flush</p><blockquote><p>指示php本身刷新自身的缓冲区,把数据发送到apache</p></blockquote></li><li><p>ob_clean</p><blockquote><p>清除php缓冲区里面的内容</p></blockquote></li><li><p>ob_end_clean</p><blockquote><p>清除php缓冲区内的内容,并且关闭输出缓冲区</p></blockquote></li><li><p>ob_end_flush</p><blockquote><p>把php自身的缓冲区里的内容发送到apache,并把清除自身缓冲区内的内容</p></blockquote></li><li><p>ob_get_clean</p><blockquote><p>获取缓冲区的内容之后,清除缓冲区.</p></blockquote></li><li><p>ob_get_contents</p><blockquote><p>获取输出缓冲区里的内容</p></blockquote></li><li><p>ob_get_flush</p><blockquote><p>获取缓冲区里的内容,并且把这些内容发送到apache</p></blockquote></li><li><p>ob_get_length</p><blockquote><p>获取缓冲区里内容的长度</p></blockquote></li><li><p>ob_list_handlers</p><blockquote><p>获取运行ob_start时,所回调的函数名称, 例如:</p></blockquote></li></ul><pre><code>ob_start(‘ob_gzhandler’);print_r(ob_list_handlers);</code></pre><p>将打印出ob_gzhandler;</p><ul><li>ob_gzhandler<blockquote><p>该函数的作用是作为ob_start的回调参数, 在缓冲区刷新之前,会调用该函数对数据进行到底gzip或者deflate压缩.这个函数需要zlib扩展的支持.</p></blockquote></li></ul><h2 id="使用缓冲区的相关内容"><a href="#使用缓冲区的相关内容" class="headerlink" title="使用缓冲区的相关内容"></a>使用缓冲区的相关内容</h2><ul><li><p>ob_flush和flush的次序关系.</p><blockquote><p>上面的分析可以看出,ob_flush是和php自身相关的,而flush操作的是apache的缓冲区,所有我们在使用这两个函数的时候,需要先执行ob_flush,<br>再执行flush,因为我们需要先把数据从PHP上发送到apache,然后再由apache返回到浏览器.如果php还没有把数据刷新到apache,就调用了flush,则apache无任何数据返回到浏览器.</p></blockquote></li><li><p>有的浏览器,如果接受到的字符太少,则不会把数据显示出来</p><blockquote><p>例如老版的IE(必须要大于256k才显示).这样就会造成一个疑问, 明明在php和apache都进行了刷新缓冲区的操作,但是浏览器就是没有出现自己想要的数据,也许就是这个原因造成的.所以才测试的时候,可以在输出数据的后面加上多个空格,以填满数据,确定不会浏览器造成这类诡异的问题.</p></blockquote></li><li><p>有些webserver,他自身的输出缓冲区会有一些限制</p><blockquote><p>比如nginx,他有一个配置fastcgi_buffer_size 4k, 就是是表明,当自身的输出缓冲区的内容达到4K才会刷新,所以为了保证内容的数据,可以添加以下代码,保证内容长度</p></blockquote><pre><code>&lt;?phpecho str_repeat(&quot; &quot;,4096);?&gt;</code></pre></li><li><p>在apache中,如果你开启了mod_gzip的压缩模块,这样可能会导致你的flush函数刷新不成功</p><blockquote><p>其原因是,mod_gzip有自己的输出缓冲区,当php执行了flush函数,指示apache刷新输出缓冲区,但是内容需要压缩,apache就把内容输出到自身的mod_gzip模块,mod_gzip也有自身的输出 缓冲区,他也不会马上输出,所以造成了内容不能马上输出.为了改善这个情况,可以关闭mod_gzip模块,或者在httpd.conf增加以下内容,以禁止压缩</p></blockquote></li></ul><p>转自：<a href="http://www.keepmyway.com/index.php/124.html">http://www.keepmyway.com/index.php/124.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是缓冲区&quot;&gt;&lt;a href=&quot;#什么是缓冲区&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲区?&quot;&gt;&lt;/a&gt;什么是缓冲区?&lt;/h2&gt;&lt;p&gt;简单而言,缓冲区的作用就是,把输入或者输出的内容先放进内存,而不显示或者读取.&lt;/p&gt;
&lt;p&gt;其实缓冲区最本质的作用就是,协调高速CPU和相对缓慢的IO设备(磁盘等)的运作.&lt;/p&gt;
&lt;h2 id=&quot;PHP在执行的时候-在什么地方有用到缓冲区&quot;&gt;&lt;a href=&quot;#PHP在执行的时候-在什么地方有用到缓冲区&quot; class=&quot;headerlink&quot; title=&quot;PHP在执行的时候,在什么地方有用到缓冲区?&quot;&gt;&lt;/a&gt;PHP在执行的时候,在什么地方有用到缓冲区?&lt;/h2&gt;&lt;p&gt;想要了解PHP的缓冲区,就要知道执行PHP的时候,缓冲区被设置到了什么地方.&lt;/p&gt;
&lt;p&gt;当执行PHP的时候,如果碰到了echo print_r之类的会输出数据的代码,PHP就会将要输出的数据放到PHP自身的缓冲区,等待输出.&lt;/p&gt;
&lt;p&gt;当PHP自身的缓冲区接到指令,指示要输出缓冲区的内容时,将会把缓冲区内的数据输出到apache上, apache接受到PHP输出的数据,然后再把该数据存在到apache自身的缓冲区内,等到输出。&lt;/p&gt;
&lt;p&gt;当apache接受到指令,只是要输出缓冲区的内容时, 将会把缓冲区的内容输出,返回到浏览器.&lt;/p&gt;
&lt;p&gt;由此可见,PHP要输出数据的时候,将会经过两个缓冲区(先是自身的,然后是apache的),再返回到浏览器.&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP项目权限控制实现小结</title>
    <link href="https://weizhimiao.github.io/2016/10/07/PHP%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/10/07/PHP%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/</id>
    <published>2016-10-07T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>RBAC，Role Based Access Control,基于角色的访问控制。实体关系如下：</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161007/RBACShiTiGuanXi.png" alt="RBAC实体关系"></p><span id="more"></span><h2 id="实现逻辑设计"><a href="#实现逻辑设计" class="headerlink" title="实现逻辑设计"></a>实现逻辑设计</h2><p>用户表，user</p><ul><li>id,用户标识</li><li>username，用户名</li><li>passwd，密码</li><li>status,状态</li></ul><p>角色表，role</p><ul><li>id,角色标识</li><li>name，角色名称</li><li>desc，角色描述</li><li>status，状态</li></ul><p>权限节点表，node</p><ul><li>id，权限节点标识</li><li>name，权限名称</li><li>title，权限描述</li><li>status，状态</li><li>sort，排序</li><li>pid，父标识</li><li>level，层级（一般，1、项目，2、模块（类），3、操作（方法））</li></ul><p>用户角色关系表，role_user</p><ul><li>id，关系标识</li><li>role_id,角色标识</li><li>user_id,用户标识</li></ul><p>角色权限关系表, access</p><ul><li>id，关系标识</li><li>role_id，角色标识</li><li>node_id，权限标识</li></ul><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>角色 –&gt; 权限节点 –&gt; 角色权限关系 –&gt; 用户 –&gt; 角色用户关系</p><p>角色：</p><ul><li>创建角色</li><li>角色管理</li></ul><p>权限</p><ul><li>添加权限节点</li><li>权限管理</li></ul><p>权限节点列表的『权限结构』的递归显示问题，可用无限制分类来实现。</p><p>无限制分类简单实现</p><pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Tree</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token variable">$treeList</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存放无限制分类结果</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">,</span> <span class="token variable">$pid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$data</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$value</span><span class="token punctuation">[</span><span class="token string">'pid'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token variable">$pid</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$treeList</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>          <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">[</span><span class="token variable">$key</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$create</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">,</span> <span class="token variable">$value</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$treeList</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>角色权限关系</p><ul><li>添加角色-权限节点关系（添加角色新权限时，必须先删除原来的权限设置）</li><li>管理角色-权限节点关系</li></ul><p>用户：</p><ul><li>添加用户</li><li>用户管理</li></ul><p>用户角色关系</p><ul><li>添加用户-角色关系</li><li>管理用户-角色关系</li></ul><h2 id="权限控制应用"><a href="#权限控制应用" class="headerlink" title="权限控制应用"></a>权限控制应用</h2><p>实现权限控制方法步骤：</p><ol><li>通过用户-角色关系表，获得用户所属角色</li><li>从权限表中，获得所有权限列表，并应用无限级分类实现分类排序</li><li>根据用户角色，通过角色-权限关系表获得当前拥有的权限几点信息</li><li>组合所有权限列表，和当前拥有的权限数据，在所有权限节点列表中标识当前用户是否具有对各个节点的权限。去除当前用户没有权限操作的权限节点。将当前的权限信息保存到当前用户的会话中。</li><li>用户进行操作各个权限节点时，首先检测当前的操作是否在会话中的权限信息中存在。不存在则按照权限不足处理，存在则继续进行操作。</li></ol><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RBAC，Role Based Access Control,基于角色的访问控制。实体关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161007/RBACShiTiGuanXi.png&quot; alt=&quot;RBAC实体关系&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="权限控制" scheme="https://weizhimiao.github.io/tags/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    
    <category term="RBAC" scheme="https://weizhimiao.github.io/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的用户和用户组管理</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>用户账号的管理主要涉及到用户账号的添加、删除和修改。<br>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等。</p><span id="more"></span><h2 id="关于用户管理的配置文件说明"><a href="#关于用户管理的配置文件说明" class="headerlink" title="关于用户管理的配置文件说明"></a>关于用户管理的配置文件说明</h2><h3 id="用户信息文件："><a href="#用户信息文件：" class="headerlink" title="用户信息文件："></a>用户信息文件：</h3><pre><code>/etc/passwd</code></pre><p>文件内容：</p><pre><code>root:x:0:0:root:/root:/bin/bash第一位：用户名第二位：密码位（只是一个密码标志，真实密码并不是存在这）第三位：UID    用户ID        0    超级管理员        1-499    系统用户（伪用户）        &gt;500    普通用户第四位：GID    初始组ID第五位：用户说明第六位：家目录第七位：用户登录之后的权限</code></pre><h3 id="影子文件："><a href="#影子文件：" class="headerlink" title="影子文件："></a>影子文件：</h3><pre><code>/etc/shadow</code></pre><p>文件内容：</p><pre><code>root:$6$w5RBeFe7Y1bixrQR$tp0zHL1bMmAVv0SAS56LsCOyZ4KUj3V0GI0dRZ4KSlf.ggisV7dwiQ8s5xebcZghVDxwlYTjN6qKGU9zRc.En1:16247:0:99999:7:::</code></pre><p>说明：</p><pre><code>## 第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，# 这样就把passwd 和shadow中用的用户记录联系在一起；这个字段是非空的；## 第二字段：密码（已被加密），如果是有些用户在这段是x，表示这个用户不能登录到系统；这个字段是非空的；## 第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），# 您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化；## 第四字段：两次修改口令间隔最少的天数；如果设置为0,则禁用此功能；也就是说用户必须经过多少天才能修改其口令；# 此项功能用处不是太大；默认值是通过/etc/login.defs文件定义中获取，PASS_MIN_DAYS 中有定义；## 第五字段：两次修改口令间隔最多的天数；这个能增强管理员管理用户口令的时效性，应该说在增强了系统的安全性；# 如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_MAX_DAYS 中定义；## 第六字段：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将要作废；# 如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_WARN_AGE 中定义；## 第七字段：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，系统会禁用此用户，# 也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用；## 第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），# 如果这个字段的值为空，帐号永久可用；## 第九字段：保留字段，目前为空，以备将来Linux发展之用；</code></pre><h3 id="组信息文件："><a href="#组信息文件：" class="headerlink" title="组信息文件："></a>组信息文件：</h3><pre><code>/etc/group</code></pre><p>文件内容：</p><pre><code>bin:x:1:bin,daemon组名：组密码位：组ID：组中的附加用户初始组：每个用户初始组只能有一个，初始组只能有一个，一般都是和用户名相同的组作为初始组附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组</code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><pre><code>useradd    用户名useradd  选项    用户名                -g    组名        指定初始组（但最好不要手动指定）        -G    组名        指定附加组（把用户加入组，使用附加组）        -c    说明        添加说明        -d    目录        手工指定家目录        -s    /bin/bash    手工指定用户登录后之后的权限</code></pre><p>例：</p><pre><code>useradd  -g  aa  bb           添加bb用户，同时指定初始组aauseradd   -G   user1   aa        添加用户aa，指定附加组为user1</code></pre><h2 id="设定密码"><a href="#设定密码" class="headerlink" title="设定密码"></a>设定密码</h2><pre><code>passwd    用户名passwd        改变当前用户密码（普通用户只能通过这种方式来更改自己的密码）passwd    root    更改root的密码</code></pre><h2 id="删除密码"><a href="#删除密码" class="headerlink" title="删除密码"></a>删除密码</h2><pre><code>userdel    -r  用户名            -r     连带家目录一起删除</code></pre><h2 id="添加组"><a href="#添加组" class="headerlink" title="添加组"></a>添加组</h2><pre><code>groupadd    组名</code></pre><h2 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h2><pre><code>groupdel    组名        注意：组中没有初始用户</code></pre><h2 id="把已经存在的用户加入组"><a href="#把已经存在的用户加入组" class="headerlink" title="把已经存在的用户加入组"></a>把已经存在的用户加入组</h2><pre><code>gpasswd    -a  用户名   组名    用户加入组gpasswd    -d  用户名  组名    把用户从组中删除</code></pre><h2 id="查看用户相关信息"><a href="#查看用户相关信息" class="headerlink" title="查看用户相关信息"></a>查看用户相关信息</h2><pre><code>id   用户名        显示用户的UID，初始组，和附加组</code></pre><pre><code>例#id   sc   uid=0(root) gid=0(root) 组=0(root)</code></pre><h2 id="用户间的相互切换"><a href="#用户间的相互切换" class="headerlink" title="用户间的相互切换"></a>用户间的相互切换</h2><pre><code>su  -  用户名        切换用户身份      -    连带环境变量一起切换</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;用户账号的管理主要涉及到用户账号的添加、删除和修改。&lt;br&gt;添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><p>格式：命令    [选项]    [参数]</p><p>例如：</p><pre><code>#ls     -list     显示目录下内容</code></pre><blockquote><p>命令操作的对象（文件、目录、用户、进程）<br>Linux中以”.”开头的文件是隐藏文件</p></blockquote><p>提示符：[root@localhost src]#</p><blockquote><p>[当前登录用户@主机名 当前所在目录]#</p><h1 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h1><p>$    普通用户</p></blockquote><p>当前所在目录：    用户家目录</p><blockquote><p>   管理员        /root<br>   普通用户        /home/用户名</p></blockquote><p><strong>tips：</strong></p><blockquote><p>ctrl +  c        强制终止<br>ctrl+l            清屏<br>ctrl+u        光标删除到行首<br>ctrl+a        光标移动到行首<br>ctrl+e        光标移动到行尾</p></blockquote><span id="more"></span><h2 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h2><p><strong>切换所在目录</strong></p><p><code>cd</code></p><p>例：</p><pre><code>cd  /usr/local/srccd   ~    或cd          进入当前用户的家目录cd  -        进入上次目录cd  ..        进入上一级目录cd  .        进入当前目录</code></pre><p><strong>显示当前所在目录</strong></p><p><code>pwd</code></p><p><strong>建立目录</strong></p><p><code>mkdir</code></p><p>例：</p><pre><code>mkdir      -p  11/22/33/44        递归建立目录</code></pre><p><strong>删除目录</strong></p><pre><code>rmdir    目录        只能删除空目录rm    文件名        删除文件rm    -rf    目录        删除文件和目录        -f    强制        -r    递归、删除目录</code></pre><p><strong>显示指定目录下的所有内容的目录树</strong></p><p>tree    目录名</p><p>例：</p><pre><code>tree    /var/</code></pre><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><p><strong>创建空文件或修改文件时间</strong></p><pre><code>touch  文件名</code></pre><p><strong>删除</strong></p><pre><code>rm  –rf  文件名        -f    强制        -r    删除目录</code></pre><p><strong>查看文件内容</strong></p><pre><code>cat    文件名        （从头到尾）        -n    列出行号more    文件名        （分屏显示文件内容）空格向下翻        b  向上翻        q  退出head    文件名        （显示文件头几行）    head  –n  行数    文件名    指定显示文件头几行    head  -20  文件名</code></pre><p><strong>链接文件</strong></p><pre><code>ln  -s  源文件   目标文件        （文件名都必须写绝对路径）链接文件相当于windows中的快捷方式，链接文件和源文件修改一个两个都变，删除原文件，软链接打不开。</code></pre><h2 id="文件和目录都能操作的命令"><a href="#文件和目录都能操作的命令" class="headerlink" title="文件和目录都能操作的命令"></a>文件和目录都能操作的命令</h2><p><strong>删除文件或目录</strong></p><pre><code>rm</code></pre><p><strong>复制</strong></p><pre><code>cp  源文件   目标文件        -r    复制目录        -p    带文件属性复制        -d    若源文件为链接文件，则复制链接属性        -a    相当于  -pdr例：cp   aa  /tmp/            原名复制cp  aa  /tmp/bb            改名复制</code></pre><p><strong>剪切或改名</strong></p><pre><code>mv    源文件   目标位置剪切目录不需要加“-r”选项（特殊）例：mv  /root/aa  /tmp/    剪切mv  aa  bb            改名</code></pre><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p><strong>权限位</strong></p><pre><code>-rw-r--r--   1   root root     0 08-11 01:45 aa</code></pre><p>权限位是十位<br>第一位：代表文件类型</p><blockquote><p>-    普通文件<br>   d    目录文件<br>   f    链接文件</p></blockquote><p>常见的文件类型就有以上3种，Linux和Unix系统中共有7种文件类型，分别有<br>    -    Block        块设备文件，如某个磁盘分区，软驱和光驱等。<br>    -    Char        字符设备，如键盘、打印机等。<br>    -    Dir        目录类型，目录也是文件的一种。<br>    -    Fifo        命名管道，常用于将信息从一个进程传递到另一个进程。<br>    -    File        普通文件。<br>    -    Link        符号链接文件，即指向文件指针的指针。<br>    -    Unknown    未知类型</p><p>其他九位：属主权限u        属主权限g        其他人权限o<br>    -    r    读        4<br>    -    w    写        2<br>    -    x    执行        1</p><p><strong>修改权限</strong></p><p>chmod</p><blockquote><p>格式：chmod  {u,g,o }{+,-,=}{w,r,x} 文件名或目录</p></blockquote><p>例：</p><pre><code>chmod  u+x  aachmod u-x  aachmod  g+w,o-r   aachmod  u=rwx  aachmod  755  aachmod  644  aa</code></pre><p><strong>权限对于文件和目录的意义</strong></p><p>对于文件的意义</p><ul><li>r：读取文件的内容。cat、more、head、tail</li><li>w：编辑、修改文件内容。vi、echo</li><li>x：可执行</li></ul><p>对于目录的意义</p><ul><li>r：可以查询目录下的文件名。ls</li><li>   w：具有修改目录结构的权限。比如新建文件和目录，删除此目录下文件和目录，剪切等操作。touch、mv、cp</li><li>   x：可以进入目录    。    cd</li></ul><p>对于目录来说，r和x权限一般是一起给的，及对于目录的权限一般至少会给到6.</p><p><strong>更改文件或目录的属主和属组命令</strong></p><p>chown</p><blockquote><p>格式：chown  用户名  文件名  </p></blockquote><p>例</p><pre><code>chown user1  aachown  user1：user1   aa    （更改属主的同时改变属主）</code></pre><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p><strong>查找命令的的帮助</strong></p><pre><code>man  命令名</code></pre><p><strong>查看常见的选项</strong></p><pre><code>命令  --help</code></pre><p>Tips：Linux中通配符和正则的使用原则：</p><ul><li><p>在搜索目录或者文件名时Linux使用的是通配符，如find.        </p><blockquote><p>Find:    在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配<br>通配符是完全匹配</p></blockquote></li><li><p>在搜索文件中的内容是，Linux使用的事正则表达式，如grep.        </p><blockquote><p>Grep：    在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式匹配<br>正则表达是包含匹配</p></blockquote></li></ul><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p><strong>查找命令的命令，同时查看帮助文档的位置</strong></p><pre><code>whereis格式：whereis   命令</code></pre><p><strong>搜索命令</strong></p><pre><code>find格式：find   查找位置   -name   文件名例find /   -name   aabbcc            -user   用户名        按属主用户查找文件        -group   组名        按属组组名查找文件        -nouser            查找没有属主的文件按照文件属性查找：        -name            按照文件名        -size                 文件大小。+50k：大于50k，-50k：小雨50k，50k：等于50k    （可用的单位有k，M）        -type                文件类型。（f:普通文件，l：链接文件，d目录文件）        -perm    644        按文件的权限值查找。        -iname            文件名查找，不区分大小写        -inum                按照文件i节点查找在查找出的结果中，直接进行命令操作。find  /var/log/   -mtime   +10  -exec   rm  -rf  &#123;&#125;  \;    查找出十天前修改的文件名删除find   /root  -inum   112033   -exec  ls   -l   &#123;&#125;  \;    用文件i节点查找到文件并且显示文件的长格式。</code></pre><p><strong>查找文件中的字符串</strong></p><pre><code>grep原理：先把命令操作的结果存在文件中，然后后面的命令去操作文件格式：grep  “字符串”   文件名例：grep  -i  “root” /etc/passwd        -i    忽略大小写        -v    反向选择比较：find：在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配。通配符是完全匹配。grep：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式匹配，正则表达式是包含匹配</code></pre><p><strong>管道符</strong></p><pre><code>命令1  |  命令2  |   命令3        命令1的执行结果，作为命令2执行的执行条件，以此类推。例：netstat   -an  |  grep  ESTABLISHED  |  wc  -l    统计正在连接的网络连接的个数cat  文件名  |  grep  “字符串”      提取含有字符串的行ls  -l  /etc  |  more         分屏显示ls内容ll  /etc、  |  grep  my</code></pre><h2 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h2><p>Linux中常见的压缩包格式</p><blockquote><p>.gz        bz2        Linux可以识别的常见压缩格式<br>.tar.gz    .tar.bz2    常见的压缩和打包命令</p></blockquote><p><strong>压缩打包命令</strong></p><ul><li>压缩同时打包<pre><code>tar  -zcvf   压缩文件名    源文件tar  -zcvf  aa.tar.gz   aa  -z:识别.gz格式  -c:压缩  -v:显示压缩过程  -f:指定压缩包名</code></pre></li><li>解压缩同时解打包<pre><code>tar   -zxvf  压缩文件名  -x: 解压缩</code></pre></li><li>压缩同时打包<pre><code>tar  -jcvf  压缩文件名    源文件  -j：识别.tar.gz2文件格式</code></pre></li><li>解打包同时解压缩<pre><code>tar  -jxvf  aa.tar.bz2  </code></pre></li><li>查看不解包<pre><code>tar   -ztvf   aa.tar.gztar  -jtvf   aa.tar.bz2  -t:  只查看，不解压</code></pre></li><li>解压到指定压缩位置<pre><code>tar  -jxvf  root.tar.bz2   -C  /tmp/      （-C一定要写在后边）</code></pre></li></ul><h2 id="关闭和重启命令"><a href="#关闭和重启命令" class="headerlink" title="关闭和重启命令"></a>关闭和重启命令</h2><pre><code>shutdown        没有特殊情况建议使用此命令来关机shutdown  -h  now    立刻关机    -h    关机    -r     重启reboot 重启命令</code></pre><h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><p>Linux下所有的存储设备都必须挂载使用，包括硬盘</p><ul><li>挂载<br>```<br>mount<br>设备文件：<br>  /dev/sda1        第一个SCSI硬盘的第一个分区<br>  /dev/cdrom        光盘（链接）<br>  /dev/hdc        光盘        CentOS 5.5<br>  /dev/sr0        光盘        CentOS6.x<br>mount  -t  文件系统  设备描述文件   挂载点（已经存在的空目录）<br>mount  -t iso9660  /dev/cdrom  /mnt/cdrom(-t iso9660也可省略)<br>mount  /dev/cdrom  /mnt/cdrom</li></ul><p>fdisk  -l        列出指定的外围设备的分区表状况<br>mount  -t  vfat  /dev/sdb1  /mnt/usb</p><pre><code>- 卸载</code></pre><p>umount<br>umount    /dev/cdrom<br>umount   /mnt/cdrom<br>强调：退出挂载目录，才能卸载</p><pre><code>## 网络命令ping测试网络连通性</code></pre><p>ping   -c  次数  ip     （测试网络的通畅）</p><pre><code>ifconfig        查询本机网络信息&gt;    -a    列出所有的网卡信息（包括没启动的）## 输出重定向和多命令顺序执行输出重定向 把应该输出到屏幕的输出，重定向到文件。</code></pre><blockquote><p>   覆盖</p><blockquote><p>   追加<br>ls  &gt;  aa        覆盖到aa<br>ls  &gt;&gt;  aa        追加到aa<br>ls  gdlslga  2&gt;&gt;aa        错误信息输出到aa<br>强调：错误输出，不能有空格</p></blockquote></blockquote><pre><code>错误信息重定向</code></pre><p>ls  &gt;&gt;  aa  2&gt;&amp;1        错误和正确都输入到aa，可以追加<br>        2&gt;&amp;1        把标准错误重定向到标准正确输出</p><p>ls  &gt;&gt;  aa  2&gt;&gt;/tmp/bb        正确信息输入aa，错误信息输入bb</p><pre><code>## 补充命令date  查看系统时间</code></pre><pre><code>date         date    -s   20140701        设定日期date    -s    09:30:00        设定时间</code></pre><pre><code>du统计目录大小</code></pre><pre><code>    -sh    目录名        统计目录大小    -s        和    -h        习惯单位</code></pre><pre><code>netstat  </code></pre><p>netstat          查看网络状态的命令<br>    -t    查看TCP端口<br>    -u    查看UDP端口<br>    -l    监听<br>    -n    以IP地址和端口号显示，不用域名和服务名显示<br>    -a    查询所有连接<br>例<br>netstat  -tlun        </p><pre><code></code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux命令格式&quot;&gt;&lt;a href=&quot;#Linux命令格式&quot; class=&quot;headerlink&quot; title=&quot;Linux命令格式&quot;&gt;&lt;/a&gt;Linux命令格式&lt;/h2&gt;&lt;p&gt;格式：命令    [选项]    [参数]&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ls     -list     显示目录下内容
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;命令操作的对象（文件、目录、用户、进程）&lt;br&gt;Linux中以”.”开头的文件是隐藏文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示符：[root@localhost src]#&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[当前登录用户@主机名 当前所在目录]#&lt;/p&gt;
&lt;h1 id=&quot;超级用户&quot;&gt;&lt;a href=&quot;#超级用户&quot; class=&quot;headerlink&quot; title=&quot;超级用户&quot;&gt;&lt;/a&gt;超级用户&lt;/h1&gt;&lt;p&gt;$    普通用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前所在目录：    用户家目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   管理员        /root&lt;br&gt;   普通用户        /home/用户名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ctrl +  c        强制终止&lt;br&gt;ctrl+l            清屏&lt;br&gt;ctrl+u        光标删除到行首&lt;br&gt;ctrl+a        光标移动到行首&lt;br&gt;ctrl+e        光标移动到行尾&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux文件和目录权限小结</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E5%B0%8F%E7%BB%93/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通权限"><a href="#普通权限" class="headerlink" title="普通权限"></a>普通权限</h2><p>文件的权限：    - r  w  -  -  w  x  r  -  x</p><pre><code>第一位：文件的类型    -：文件    d：文件夹    l：连接    c：字符设备文件    b：块设备    s：套接口文件第二位：所有者读权限第三位：所有者写权限第四位：所有者执行权限第五位：所有者组读权限第六位：所有者组写权限第七位：所有者组执行权限第八位：其他组读权限第九位：其他组写权限第十位：其他组执行权限r        4w        2x        1</code></pre><span id="more"></span><h2 id="特殊权限（SUID-SGID-SBIT）"><a href="#特殊权限（SUID-SGID-SBIT）" class="headerlink" title="特殊权限（SUID/SGID/SBIT）"></a>特殊权限（SUID/SGID/SBIT）</h2><p>先来看看两个特殊的文件与目录</p><pre><code>[root@yufei ~]# ls -l /usr/bin/passwd-rwsr-xr-x. 1 root root 26968 Jan 29  2010 /usr/bin/passwd[root@yufei ~]# ls -l /usr/bin/wall-r-xr-sr-x. 1 root tty 10932 Apr 27  2010 /usr/bin/wall[root@yufei ~]# ls -ld /tmp/drwxrwxrwt. 7 root root 4096 Jan 20 11:00 /tmp/</code></pre><p>第一个passwd命令在所有者的地方多了一个s，<br>第二个wall命令在用户组的位置多了一个s，<br>第三个tmp目录，多了一个t。</p><p>这是为什么呢？下面我们就来具体看看，这些特殊的权限是什么意思？如何设置？</p><h3 id="特殊权限的介绍Set-UID"><a href="#特殊权限的介绍Set-UID" class="headerlink" title="特殊权限的介绍Set UID**"></a>特殊权限的介绍Set UID**</h3><p>当s这个标志出现在文件所有者的x权限上时，如/usr/bin/passwd这个文件的权限状态：“-rwsr-xr-x.”，此时就被称为Set UID，简称为SUID。那么这个特殊权限的特殊性的作用是什么呢？</p><ul><li>1、SUID权限仅对二进制程序(binary program)有效；</li><li>2、执行者对于该程序需要具有x的可执行权限；</li><li>3、本权限仅在执行该程序的过程中有效(run-time)；</li><li>4、执行者将具有该程序拥有者(owner)的权限。</li></ul><p>SUID的目的就是：让本来没有相应权限的用户运行这个程序时，可以访问他没有权限访问的资源。passwd就是一个很鲜明的例子，下面我们就来了解一下这相passwd执行的过程。</p><p>我们知道，系统中的用户密码是保存在/etc/shadow中的，而这个文件的权限是———-. （这个权限和以前版本的RHEL也有差别，以前的是-r——–）。其实有没有r权限不重要，因为我们的root用户是拥有最高的权限，什么都能干了。关键是要把密码写入到/etc/shadow中。我们知道，除了root用户能修改密码外，用户自己同样也能修改密码，为什么没有写入权限，还能修改密码，就是因为这个SUID功能。</p><p>下面就是passwd这个命令的执行过程</p><ul><li>1、因为/usr/bin/passwd的权限对任何的用户都是可以执行的，所以系统中每个用户都可以执行此命令。</li><li>2、而/usr/bin/passwd这个文件的权限是属于root的。</li><li>3、当某个用户执行/usr/bin/passwd命令的时候，就拥有了root的权限了。</li><li>4、于是某个用户就可以借助root用户的权力，来修改了/etc/shadow文件了。</li><li>5、最后，把密码修改成功。</li></ul><p>注：这个SUID只能运行在二进制的程序上（系统中的一些命令），不能用在脚本上（script），因为脚本还是把很多的程序集合到一起来执行，而不是脚本自身在执行。同样，这个SUID也不能放到目录上，放上也是无效的。</p><h3 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h3><p>我们前面讲过，当s这个标志出现在文件所有者的x权限上时，则就被称为Set UID。那么把这个s放到文件的所属用户组x位置上的话，就是SGID。如开头的/usr/bin/wall命令。<br>那么SGID的功能是什么呢？和SUID一样，只是SGID是获得该程序所属用户组的权限。</p><p>这相SGID有几点需要我们注意：</p><ul><li>1、SGID对二进制程序有用；</li><li>2、程序执行者对于该程序来说，需具备x的权限；</li><li>3、SGID主要用在目录上；<br>理解了SUID，我想SGID也很容易理解。如果用户在此目录下具有w权限的话，若使用者在此目录下建立新文件，则新文件的群组与此目录的群组相同。</li></ul><h3 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h3><p>这个就是针对others来设置的了，和上面两个一样，只是功能不同而已。</p><p>SBIT（Sticky Bit）目前只针对目录有效，对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除。</p><p>最具有代表的就是/tmp目录，任何人都可以在/tmp内增加、修改文件（因为权限全是rwx），但仅有该文件/目录建立者与 root能够删除自己的目录或文件。</p><p><strong>注：这个SBIT对文件不起作用。</strong></p><h3 id="SUID-SGID-SBIT权限设置"><a href="#SUID-SGID-SBIT权限设置" class="headerlink" title="SUID/SGID/SBIT权限设置"></a>SUID/SGID/SBIT权限设置</h3><p>和我们前面说的rwx差不多，也有两种方式，一种是以字符，一种是以数字。</p><ul><li>4 为 SUID ＝ u+s</li><li>2 为 SGID ＝ g+s</li><li>1 为 SBIT ＝ o+t</li></ul><p>下面我们就来看看如何设置，并看看达到的效果。</p><h4 id="先看SUID的作用及设置"><a href="#先看SUID的作用及设置" class="headerlink" title="先看SUID的作用及设置"></a>先看SUID的作用及设置</h4><pre><code>[root@yufei ~]# cd /tmp/[root@yufei tmp]# cp /usr/bin/passwd ./[root@yufei tmp]# mkdir testdir</code></pre><p>上面两步是在/tmp目录下创建passwd文件和testdir目录</p><p>下面看看这两个的权限</p><pre><code>[root@yufei tmp]# ls -l passwd ; ls -ld testdir/-rwxr-xr-x. 1 root root 26968 Jan 20 23:27 passwddrwxr-xr-x. 2 root root 4096 Jan 20 19:25 testdir/</code></pre><p>我们切换到yufei用户，然后修改自己的密码</p><pre><code>[root@yufei tmp]# su yufei[yufei@yufei tmp]$ ./passwdChanging password for user yufei.Changing password for yufei.(current) UNIX password:New password:           Retype new password:passwd: Authentication token manipulation error</code></pre><p>发现上面的yufei改不了自己的密码，为什么呢？就是因为没有权限把密码写入到/etc/shadow中。想让普通用户能修改/etc/shadow的话，那就需要用到SUID了。</p><pre><code>[yufei@yufei tmp]$ su rootPassword:[root@yufei tmp]# chmod u+s passwd[root@yufei tmp]# ls -l passwd-rwsr-xr-x. 1 root root 26968 Jan 20 23:27 passwd</code></pre><p>看到有SUID权限了，下面再来修改yufei自己的密码</p><pre><code>[yufei@yufei tmp]$ ./passwdChanging password for user yufei.Changing password for yufei.(current) UNIX password:New password:Retype new password:passwd: all authentication tokens updated successfully.</code></pre><p>我们发现已经成功了。</p><p>我想这一下，你对SUID的作用已经了解了吧。</p><p>如果想把这个改回来（就是把SUID的权限去掉），我们用数字方式来设置</p><pre><code>[root@yufei tmp]# chmod 0755 passwd[root@yufei tmp]# ls -l passwd-rwxr-xr-x. 1 root root 26968 Jan 20 23:27 passwd</code></pre><p>OK这样就改过来了，这个数字的原理和我们前面讲的rwx是一样的，只是在最前面设置相应的数字而已。</p><p><strong>注：在普通用户修改自己的密码是，密码要设置的复杂点，否则的话，通过不了认证，普通用户和root用户的权限是不同的。</strong></p><h4 id="再看SGID的作用及设置"><a href="#再看SGID的作用及设置" class="headerlink" title="再看SGID的作用及设置"></a>再看SGID的作用及设置</h4><p>我们以前面建立的/tmp/testdir为例子</p><pre><code>[root@yufei tmp]# ls -ld testdir/[root@yufei tmp]# chmod 757 testdir/[root@yufei tmp]# ls -ld testdir/drwxr-xrwx. 2 root root 4096 Jan 20 19:25 testdir/</code></pre><p>这时候，任何用户对此目录都有写入权限，那么我们就在这个目录里面创建文件与目录，并看看他们的权限如何</p><pre><code>[root@yufei tmp]# su yufei[yufei@yufei tmp]$ touch testdir/file1[yufei@yufei tmp]$ mkdir testdir/dir1[yufei@yufei tmp]$ ls -l testdirtotal 0drw-rw-r–. 1 yufei yufei 0 Jan 21 10:33 dir1-rw-rw-r–. 1 yufei yufei 0 Jan 21 10:33 file1</code></pre><p>这时候的文件与目录权限都是创建者的本身<br>下面我们就来看看，把这个目录加上SGID权限后，再创建文件与目录，会是什么样的效果</p><pre><code>[yufei@yufei tmp]$ su rootPassword:[root@yufei tmp]# chmod g+s testdir/[root@yufei tmp]# ls -ld testdir/drwxr-srwx. 2 root root 4096 Jan 21 10:33 testdir/[root@yufei tmp]# su yufei[yufei@yufei tmp]$ touch testdir/file2[yufei@yufei tmp]$ mkdir testdir/dir2[yufei@yufei tmp]$ ls -l testdir/total 0drw-rw-r–. 1 yufei yufei 0 Jan 21 10:33 dir1drw-rw-r–. 1 yufei root  0 Jan 21 10:36 dir2-rw-rw-r–. 1 yufei yufei 0 Jan 21 10:33 file1-rw-rw-r–. 1 yufei root  0 Jan 21 10:35 file2[yufei@yufei tmp]$ ls -ld testdir/drwxr-srwx. 2 root root 4096 Jan 21 10:36 testdir/</code></pre><p>这时候我们就发现，file2和dir2的用户组变成了root了，也就是他们上层目录testdir这个目录的所属用户组。<br>这个应用，应用在一个项目的共同开发上，是很方便的。</p><pre><code>[yufei@yufei tmp]$ su rootPassword:[root@yufei tmp]# chmod g-s testdir/[yufei@yufei tmp]$ ls -ld testdir/drwxr-xrwx. 2 root root 4096 Jan 21 10:36 testdir/</code></pre><p>这样就还原了</p><h4 id="最后我们来看SBIT的作用及设置"><a href="#最后我们来看SBIT的作用及设置" class="headerlink" title="最后我们来看SBIT的作用及设置"></a>最后我们来看SBIT的作用及设置</h4><pre><code>[root@yufei tmp]# rm -fr testdir/*[root@yufei tmp]# ls -ld testdir/drwxr-xrwx. 2 root root 4096 Jan 21 11:42 testdir/</code></pre><p>清空/tmp/testdir/目录里面的全部内容。</p><p>我们切换成普通用户，然后再里面创建文件，至少需要两个普通用户来测试这个，如果没有的话，就自己建立。</p><pre><code>[root@yufei tmp]# su yufei[yufei@yufei tmp]$ touch testdir/yufei_file[yufei@yufei tmp]$ ls -l testdir/total 0-rw-rw-r– 1 yufei yufei 0 Jan 21 11:45 yufei_file</code></pre><p>这时候我们建立了一个文件，我们换成另外一个用户</p><pre><code>[yufei@yufei tmp]$ suopsersPassword:[opsers@yufei tmp]$ ls -ld testdir/drwxr-xrwx. 2 root root 4096 Jan 21 11:45 testdir/</code></pre><p>我们看到，虽然其他用户对yufei_file只有只读权限，但由于yufei_file所在的目录，对其他人是全部的权限，所以，我们换其他用户还是可以删除这个文件的，看操作</p><pre><code>[opsers@yufei tmp]$ rm -f testdir/yufei_file[opsers@yufei tmp]$ ls testdir/</code></pre><p>发现我们已经删除了这个不属于我们的权限。<br>下面我们就给这个目录加上SBIT权限，再来看看效果</p><pre><code>[opsers@yufei tmp]$ su rootPassword:[root@yufei tmp]# chmod o+t testdir[root@yufei tmp]# ls -ld testdir/drwxr-xrwt. 2 root root 4096 Jan 21 11:49 testdir/</code></pre><p>再一次切换普通用户，创建文件</p><pre><code>[root@yufei tmp]# su yufei[yufei@yufei tmp]$ touch testdir/yufei_file[yufei@yufei tmp]$ ls -l testdir/yufei_file-rw-rw-r– 1 yufei yufei 0 Jan 21 11:51 testdir/yufei_file</code></pre><p>这个文件的权限还是和第一次创建的时候是一样的，我们再换成其他的用户，看看能不能再次删除这个文件</p><pre><code>[yufei@yufei tmp]$ su opsersPassword:[opsers@yufei tmp]$ rm -f testdir/yufei_filerm: cannot remove `testdir/yufei_file’: Operation not permitted</code></pre><p>看到提示，说权限不够了，只能由这个文件的创建者或root用户才能删除。这个我们就不演示了。<br>如果要还原权限的话，</p><pre><code>[opsers@yufei tmp]$ su rootPassword:[root@yufei tmp]# chmod o-t testdir[root@yufei tmp]# ls -ld testdir/drwxr-xrwx. 2 root root 4096 Jan 21 11:51 testdir/</code></pre><p>两个需要注意的问题</p><p>OK，关于SUID/SGID/SBIT这些特殊权限的应用和作用我们已经完了。但如果你仔细一点的话，会发现，我并没有用数字方式来更改这个特殊的权限，为什么呢？且看下面的分析。</p><h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3><h4 id="问题1：用数字改变目录的特殊权限，不起作用。"><a href="#问题1：用数字改变目录的特殊权限，不起作用。" class="headerlink" title="问题1：用数字改变目录的特殊权限，不起作用。**"></a>问题1：用数字改变目录的特殊权限，不起作用。**</h4><p>我们把/tmp/下面，我们自己建立的实验文件删除</p><pre><code>[root@yufei tmp]# rm -fr testdir/[root@yufei tmp]# rm -fr passwd</code></pre><p>然后再重新创建一个文件和目录，</p><pre><code>[root@yufei tmp]# cp /usr/bin/passwd ./[root@yufei tmp]# mkdir testdir[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rwxr-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-xr-x 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>下面我们就来用数字方式来更改这三个特殊的权限，看看会有什么样的结果</p><pre><code>[root@yufei tmp]# chmod 4755 passwd[root@yufei tmp]# chmod 3755 testdir/[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rwsr-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-sr-x 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>发现用这种方式增加这三个特殊权限没有问题，那么我们再把权限改回去看看</p><pre><code>[root@yufei tmp]# chmod 0755 passwd[root@yufei tmp]# chmod 0755 testdir/[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rwxr-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-sr-x 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>我们发现，对文件，权限是改回去了，而对于目录，只改回去了SBIT的权限，对SUID和SGID改不回去。这是RHEL6上的实验结果，可能是出于安全性的考虑吗？这个我就不清楚了，也找不到相关的资料。</p><p>所以说，建议大家还是用最明了的方式，直接用+-来更改，无论方法如何，最终能得到结果就OK了。哈哈……</p><h4 id="问题2：为什么会有大写的S和T。"><a href="#问题2：为什么会有大写的S和T。" class="headerlink" title="问题2：为什么会有大写的S和T。"></a>问题2：为什么会有大写的S和T。</h4><p>还是用上面的文件和目录</p><pre><code>[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rwxr-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-sr-x 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>我们把passwd和testdir的x权限去掉</p><pre><code>[root@yufei tmp]# chmod u-x passwd[root@yufei tmp]# chmod o-x testdir/[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rw-r-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-sr– 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>再给他们加上SUID和SBIT权限</p><pre><code>[root@yufei tmp]# chmod u+s passwd[root@yufei tmp]# chmod o+t testdir/[root@yufei tmp]# ls -l passwd ;ls -ld testdir/-rwSr-xr-x 1 root root 26968 Jan 21 12:00 passwddrwxr-sr-T 2 root root 4096 Jan 21 12:00 testdir/</code></pre><p>我们看到，这时候的小s和小t已经变成了大S和大T了，为什么呢？因为他们这个位置没有了x权限，如果没有了x权限，根据我们上面讲的内容，其实，这个特殊的权限就相当于一个空的权限，没有意义。也就是说，如果你看到特殊权限位置上变成了大写的了，那么，就说明，这里有问题，需要排除。</p><h2 id="ACL权限（用来解决用户权限身份不足的问题）"><a href="#ACL权限（用来解决用户权限身份不足的问题）" class="headerlink" title="ACL权限（用来解决用户权限身份不足的问题）"></a>ACL权限（用来解决用户权限身份不足的问题）</h2><p>问题：只要使用ACL权限递归赋予权限，就很有可能出现权限溢出的危险（应为文件和目录的wrx权限含义是不同的）</p><p>举例：</p><pre><code>/www    sc --&gt; root    61 --&gt;  fgroup    o    770        </code></pre><pre><code>[root@localhost ~]# mkdir /www[root@localhost ~]# chmod 770 /www/[root@localhost ~]# groupadd fgroup[root@localhost ~]# gpasswd -a sc fgroup</code></pre><p>正在将用户“sc”加入到“fgroup”组中</p><pre><code>[root@localhost ~]# gpasswd -a aa fgroup</code></pre><p>正在将用户“aa”加入到“fgroup”组中</p><pre><code>[root@localhost ~]# chown root:fgroup  /www[root@localhost ~]# ll -d  /www/drwxrwx--- 2 root fgroup 4096 04-25 14:56 /www/</code></pre><h3 id="getfacl-文件名-查询文件的acl权限"><a href="#getfacl-文件名-查询文件的acl权限" class="headerlink" title="getfacl  文件名        查询文件的acl权限"></a>getfacl  文件名        查询文件的acl权限</h3><h3 id="setfacl-选项-文件名-设定acl权限"><a href="#setfacl-选项-文件名-设定acl权限" class="headerlink" title="setfacl  选项  文件名        设定acl权限"></a>setfacl  选项  文件名        设定acl权限</h3><pre><code>    -m            设定权限    -b            删除权限setfacl  -m  u:用户名:权限   文件名setfacl  -m  g:组名：权限   文件名setfacl  -m u:aa:rwx  /test        给test目录赋予aa是读写执行的acl权限setfacl -m u:cc:rx -R soft/        赋予递归acl权限，只能赋予目录        -R  递归setfacl  -b  /test        删除acl权限</code></pre><h3 id="setfacl-m-d-u-aa-rwx-R-test-acl默认权限。"><a href="#setfacl-m-d-u-aa-rwx-R-test-acl默认权限。" class="headerlink" title="setfacl  -m d:u:aa:rwx -R /test    acl默认权限。"></a>setfacl  -m d:u:aa:rwx -R /test    acl默认权限。</h3><blockquote><p>注意：默认权限只能赋予目录</p><p>注意：如果给目录赋予acl权限，两条命令都要输入</p></blockquote><ul><li>-R 递归</li><li>-m  u:用户名：-R 权限        只对已经存在的文件生效</li><li>-m  d:u:用户名：-R 权限        只对未来要新建的文件生效</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;普通权限&quot;&gt;&lt;a href=&quot;#普通权限&quot; class=&quot;headerlink&quot; title=&quot;普通权限&quot;&gt;&lt;/a&gt;普通权限&lt;/h2&gt;&lt;p&gt;文件的权限：    - r  w  -  -  w  x  r  -  x&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一位：文件的类型
    -：文件
    d：文件夹
    l：连接
    c：字符设备文件
    b：块设备
    s：套接口文件
第二位：所有者读权限
第三位：所有者写权限
第四位：所有者执行权限
第五位：所有者组读权限
第六位：所有者组写权限
第七位：所有者组执行权限
第八位：其他组读权限
第九位：其他组写权限
第十位：其他组执行权限
r        4
w        2
x        1
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux目录结构介绍</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://www.centoscn.com/uploads/allimg58981378314368.jpg" alt="Linux目录结构"></p><span id="more"></span><h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><pre><code>/        根目录/bin        命令保存目录（普通用户就可以读取的命令）/boot        启动目录，启动相关文件/dev        设备文件保存目录/etc        配置文件保存目录/etc/rc.d        主要在记录一些开关机过程中的 scripts 档案， scripts 有点像是 DOS 下的批次档（.bat檔名）/etc/rc.d/init.d    所以服务预设的启动 scripts 都是放在这里的，例如要启动与关闭 iptables 的话，可以：/etc/rc.d/init.d/iptables start/etc/rc.d/init.d/iptables stop/etc/xinetd.d        这个路径在较新的 Linux distribution 当中才有，由于早期的版本用来开启服务的档案是 inetd.conf ，但是在较新的版本中，开启服务的项目已经变成使用 xinetd.conf 这个档案，因此，你若需要启动一些额外的服务的话，在 Mandrake 9.0 或者是 Red Hat 7.0 以后就要到 /etc/xinetd.d 这个目录下了。/etc/X11    这是与 X windows 有关的设定文件所在的目录，尤其里面的 XF86Config-4 更是重要呢！/etc/opt/        /opt/的配置文件/etc/sgml/        SGML的配置文件/etc/xml/        XML的配置文件/home        普通用户的家目录/lib        系统库保存目录/mnt        系统挂载目录（空目录）（一般建议将光盘、U盘等都关在在此目录下）/media        挂载目录（空目录）/root        超级用户的家目录/tmp        临时目录/sbin        命令保存目录（超级用户才能使用的目录）/proc        直接写入内存的/proc/cpuinfo        关于处理器的信息，如类型、厂家、型号和性能等/proc/devices        当前运行内核所配置的所有设备清单/proc/dma        当前正在使用的DMA通道。/proc/filesystems 当前运行内核所配置的文件系统/proc/interrupts        正在使用的中断，和曾经有多少个中断/proc/ioports        当前正在使用的I/O端口/sys        同上/usr        系统软件资源目录/usr/bin/        系统命令（普通用户）/usr/sbin/        系统命令（超级用户）/usr/locate/        源码包安装的软件存放目录/usr/X11        同/usr/X11R6 （/usr/X11R6的符号连接）/usr/X11R6        X Window System存放相关档案的目录/usr/X11R6/bin        大量的小X-WINDOWS应用程序（也可能是一些在其它子目录下大执行文件的符号连接）/usr/include        一些套件的header檔。基本上，当我们在以 tarball 方式（ *.tar.gz 的方式安装软件）安装某些数据时，会使用到的一些函式库都在这个目录底下喔！/usr/lib        内含许多程序与子程序所需的函式库。/usr/local        在你安装完了 Linux 之后，基本上所有的配备你都有了，但是软件总是可以升级的，例如你要升级你的 proxy 服务，则通常软件预设的安装地方就是在 /usr/local 中（ local 是『当地』的意思），同时，安装完毕之后所得到的执行文件，为了与系统原先的执行文件有分别，因此升级后的执行档通常摆在 /usr/local/bin 这个地方。/usr/local/bin        可能是用户安装的小的应用程序，和一些在/usr/local目录下大应用程序的符号连接/usr/share/doc        放置一些系统说明文件的地方，例如你安装了 lilo 了，那么在该目录底下找一找，就可以查到 lilo 的说明文件了！很是便利！/usr/share/man        放置一些程序的说明文件的地方，那是什么？呵呵！就是你使用 man 的时候，会去查询的路径呀！例如你使用 man ls 这个指令时，就会查出 /usr/share/man/man1/ls.1.bz2 这个说明档的内容啰！/usr/src        这是放置核心原始码的预设目录，未来我们要编译核心的时候，就必须到这个目录底下呦！/var        系统相关文档内容/var/log/    系统日志位置/var/spool/mail/        系统默认邮箱位置/var/lib/mysql/        默认安装的mysql的库文件目录/ost+found /        分区的复目录（当系统非正常关机时，可以进行恢复，每个分区都会有这样一个lost+found目录）系统不正常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。例如你加装一棵硬盘于 /disk 中，那在这个目录下就会自动产生一个这样的目录 /disk/lost+found</code></pre><h2 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc/目录"></a>/etc/目录</h2><p>特定主机系统范围内的配置文件：</p><pre><code>/etc/rc /etc/rc.d        启动、或改变运行级时运行的scripts或scripts的目录./etc/rc*.d/etc/hosts            本地域名解析文件/etc/sysconfig/network    IP、掩码、网关、主机名配置/etc/resolv.conf        DNS服务器配置/etc/fstab            开机自动挂载系统，所有分区开机都会自动挂载/etc/inittab    设定系统启动时Init进程将把系统设置成什么样的runlevel及加载相关的启动文件配置/etc/exports            设置NFS系统用的配置文件路径/etc/init.d            这个目录来存放系统启动脚本/etc/profile,/etc/csh.login,/etc/csh.cshrc        全局系统环境配置变量/etc/issue            认证前的输出信息，默认输出版本内核信息/etc/motd            设置认证后的输出信息，/etc/mtab        当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df 命令/etc/group            类似/etc/passwd ，但说明的不是用户而是组./etc/passwd        用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息./etc/shadow        在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd         文件中的加密口令移动到/etc/shadow 中，而后者只对root可读.这使破译口令更困难./etc/sudoers            可以sudo命令的配置文件/etc/syslog.conf        系统日志参数配置/etc/login.defs        设置用户帐号限制的文件/etc/securetty        确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权./etc/printcap            类似/etc/termcap ，但针对打印机.语法不同./etc/shells        列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录./etc/xinetd.d        如果服务器是通过xinetd模式运行的，它的脚本要放在这个目录下。有些系统没有这个目录，比如Slackware，有些老的版本也没有。在Redhat Fedora中比较新的版本中存在。/etc/opt/            /opt/的配置文件/etc/X11/            X_Window系统(版本11)的配置文件/etc/sgml/            SGML的配置文件/etc/xml/            XML的配置文件/etc/skel/            默认创建用户时，把该目录拷贝到家目录下</code></pre><h2 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr/目录"></a>/usr/目录</h2><p>默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的用户工具和应用程序。</p><h2 id="var-目录"><a href="#var-目录" class="headerlink" title="/var/目录"></a>/var/目录</h2><p>/var 包括系统一般运行时要改变的数据.每个系统是特定的，即不通过网络与其他计算机共享.</p><h2 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc/目录"></a>/proc/目录</h2><p>虚拟文件系统，将内核与进程状态归档为文本文件（系统信息都存放这目录下）。</p><p>例如：uptime、 network。在Linux中，对应Procfs格式挂载。该目录下文件只能看不能改（包括root）</p><h2 id="dev-目录"><a href="#dev-目录" class="headerlink" title="/dev/目录"></a>/dev/目录</h2><p>设备文件分为两种：</p><ul><li>块设备文件(b)</li><li>字符设备文件(c)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://www.centoscn.com/uploads/allimg58981378314368.jpg&quot; alt=&quot;Linux目录结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统的简介和安装</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E7%AE%80%E4%BB%8B/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E7%AE%80%E4%BB%8B/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><h3 id="Unix发展史"><a href="#Unix发展史" class="headerlink" title="Unix发展史"></a>Unix发展史</h3><p>1965年，美国麻省理工学院（MIT）、通用电气公司（GE）及AT&amp;T的贝尔实验室联合开发Multics工程计划，其目标是开发一种交互式的具有多道程序处理能力的分时操作系统，但因Multics追求的目标过于庞大复杂，项目进度远远落后于计划，最后贝尔实验室宣布退出。</p><p>1969年，美国贝尔实验室的肯.汤普森在DEC PDP-7机器上开发出了UNIX系统</p><p>1971年，肯.汤普森的同事丹尼斯.里奇发明了C语言；1973年，UNIX系统的绝大部分源代码用C语言重写，这为提高UNIX系统的可移植性打下基础</p><span id="more"></span><h3 id="常见的Unix"><a href="#常见的Unix" class="headerlink" title="常见的Unix"></a>常见的Unix</h3><ul><li>AIX        IBM</li><li>HP-UX        HP</li><li>Solaris        SUN</li></ul><h3 id="Linux的发展史"><a href="#Linux的发展史" class="headerlink" title="Linux的发展史"></a>Linux的发展史</h3><p>由Andrew S. Tanenbaum（谭宁邦）发明。MINIX最初发布于1987年，开放全部源代码给大学教学和研究工作。2000年重新改为BSD授权，成为自由和开放源码软件。<br>Linus Torvalds（李纳斯.托瓦兹），1991年，他在芬兰的赫尔辛基大学用Minix操作平台建立了一个新的操作系统的内核，他把它叫做Linux。</p><h3 id="常见的Linux"><a href="#常见的Linux" class="headerlink" title="常见的Linux"></a>常见的Linux</h3><p>Linux的各种版本多大上千种，主要可以分为两大类：</p><ul><li><p>一类是Red Hat系列，主要有Fedora、RHEL、CentOS、SUSE、gentoo、红旗、Mandriva、turboLinux、REHL enterprise。</p></li><li><p>还有一类是以debian和ubuntu为代表的系列</p></li></ul><h3 id="Linux特点"><a href="#Linux特点" class="headerlink" title="Linux特点"></a>Linux特点</h3><ul><li>开源、免费</li><li>稳定</li><li>安全</li></ul><h3 id="Linux的应用领域："><a href="#Linux的应用领域：" class="headerlink" title="Linux的应用领域："></a>Linux的应用领域：</h3><ul><li>基于Linux的网站服务器</li><li>电影娱乐业（特别是在特效制作上）</li><li>嵌入式领域</li><li>手机、平板电脑</li><li>其他嵌入式领域</li></ul><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>Linux安装步骤：</p><blockquote><ul><li><p>分区：把大硬盘分为小的逻辑分区</p></li><li><p>格式化：写入文件系统</p></li><li><p>分区设备文件名：给每个分区定义设备文件名</p></li><li><p>挂载：给每个分区分配挂载点</p></li></ul></blockquote><h3 id="Linux磁盘分区："><a href="#Linux磁盘分区：" class="headerlink" title="Linux磁盘分区："></a>Linux磁盘分区：</h3><p>分区类型</p><ul><li>主分区，由于硬盘的限制，一个硬盘最多只能有4个主分区。</li><li>扩展分区，一个硬盘上最多只能有一个扩展分区，主分区和扩展分区加起来一个硬盘也最多有4个，且扩展分区当中不能直接写入数据，只能包含逻辑分区。</li><li>逻辑分区，逻辑分区只能建立在扩展分区之上。逻辑分区可以有多个。</li></ul><p>Linux分区表示：</p><ul><li>/dev/hda1<blockquote><p>   hd:    IDE硬盘    sd：    SCSI硬盘或者SATA硬盘<br>   a：    第一块硬盘<br>   1：    第一个分区</p></blockquote></li></ul><h3 id="Linux分区格式化（写入文件系统）"><a href="#Linux分区格式化（写入文件系统）" class="headerlink" title="Linux分区格式化（写入文件系统）"></a>Linux分区格式化（写入文件系统）</h3><p>文件系统类型</p><ul><li>Windows系统一般有一下文件系统：<ul><li>FAT16</li><li>FAT32</li><li>NTFS</li></ul></li></ul><ul><li>Linux系统有一下几种文件系统：<ul><li>EXT2</li><li>EXT3</li><li>EXT4</li></ul></li></ul><p>Inode        i节点（每个文件都有一个唯一的数字标识来唯一标识该文件）</p><blockquote><p>注意：每个i节点可以表示的硬盘空间的大小有限，一个小文件可能用一个i节点就可表示，但当一个文件非常大时，就可能对应着好多个i节点。</p></blockquote><p>Block        数据存储的最小单元（一般大小为4Kb）</p><p>格式化又称为逻辑格式化，它是指根据用户选定的文件系统，在磁盘的特定区域写入特定数据，在分区中画出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux简介&quot;&gt;&lt;a href=&quot;#Linux简介&quot; class=&quot;headerlink&quot; title=&quot;Linux简介&quot;&gt;&lt;/a&gt;Linux简介&lt;/h2&gt;&lt;h3 id=&quot;Unix发展史&quot;&gt;&lt;a href=&quot;#Unix发展史&quot; class=&quot;headerlink&quot; title=&quot;Unix发展史&quot;&gt;&lt;/a&gt;Unix发展史&lt;/h3&gt;&lt;p&gt;1965年，美国麻省理工学院（MIT）、通用电气公司（GE）及AT&amp;amp;T的贝尔实验室联合开发Multics工程计划，其目标是开发一种交互式的具有多道程序处理能力的分时操作系统，但因Multics追求的目标过于庞大复杂，项目进度远远落后于计划，最后贝尔实验室宣布退出。&lt;/p&gt;
&lt;p&gt;1969年，美国贝尔实验室的肯.汤普森在DEC PDP-7机器上开发出了UNIX系统&lt;/p&gt;
&lt;p&gt;1971年，肯.汤普森的同事丹尼斯.里奇发明了C语言；1973年，UNIX系统的绝大部分源代码用C语言重写，这为提高UNIX系统的可移植性打下基础&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux网络配置</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161007/ifconfig.png" alt="Linux网络配置"></p><span id="more"></span><p>##虚拟机网卡的配置（IP地址的配置）</p><h3 id="IP地址的配置"><a href="#IP地址的配置" class="headerlink" title="IP地址的配置"></a>IP地址的配置</h3><p>给Linux配置IP</p><pre><code>setup  进行IP地址的设置service network restart</code></pre><p>手工启动Linux网卡</p><pre><code>vi  /etc/sysconfig/network-scripts/ifcfg-eth0        编辑网卡配置文件</code></pre><p>配置文件内容如下：</p><pre><code>DEVICE=eth0IPADDR=192.168.140.158GATEWAY=192.168.140.1NETMASK=255.255.255.0HWADDR=00:0c:29:41:c7:1fUUID=&quot;60bfdea1-c598-4dc8-bf93-da162ea4fb41&quot;TYPE=EthernetBOOTPROTO=noneIPV6INIT=noONBOOT=yesUSERCTL=no</code></pre><p>修改如下配置项：</p><pre><code>ONBOOT=no        改为ONBOOT=yes        （是否开机启动）</code></pre><p>修改UUID</p><blockquote><p>解决虚拟机网卡不通：（需要进行如下修改）</p></blockquote><pre><code>vi  /etc/sysconfig/network-scripts/ifcfg-eth0</code></pre><p>删除MAC地址行</p><pre><code>rm –rf /etc/udev/rules.d/70-persistent-net.rules</code></pre><p>删除网卡和MAC地址绑定文件<br>重启系统<br>修改虚拟机配置</p><blockquote><p>网卡连接方式改为桥接模式<br>确定桥接到有线网卡上<br>（桥接方式是虚拟机和真实机共享使用本机的真实物理网卡，故采用这种方式vMare0和8的这两块虚拟网卡可以同时禁掉）</p></blockquote><h2 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h2><h3 id="IP地址配置（3种方法，推介使用地3种）"><a href="#IP地址配置（3种方法，推介使用地3种）" class="headerlink" title="IP地址配置（3种方法，推介使用地3种）"></a>IP地址配置（3种方法，推介使用地3种）</h3><ol><li>setup<pre><code>   service   network  restart</code></pre></li><li>   ifconfig  eth0  ip    netmask       临时生效</li><li>   修改网卡配置文件</li></ol><p><strong>网卡信息文件：<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 文件内容如下：</strong></p><pre><code>DEVICE=eth0                    网卡设备名BOOTPROTO=none                是否自动获取IP。none：不生效                    static：手动        dhcp：动态获取IPBROADCAST=192.168.140.255            广播地址HWADDR=00:0c:29:21:80:48            mac地址IPADDR=192.168.140.253            IP地址IPV6INIT=yes                    IPv6开启IPV6_AUTOCONF=yes                IPv6获取NETMASK=255.255.255.0                掩码NETWORK=192.168.140.0                网段ONBOOT=yes                    网卡开机启动TYPE=Ethernet                    以太网GATEWAY=192.168.140.1                网关</code></pre><p>如果是采用DHCP方式获取IP信息，则可以只填写上述用橙色标记的配置项即可。<br>修改配置文件后，需要重启服务（如service  network  restart）</p><p><strong>主机名配置文件</strong></p><pre><code>/etc/sysconfig/network        永久生效，但是要重启</code></pre><p>文件内容如下：</p><pre><code>NETWORKING=yesHOSTNAME=localhost.localdomain</code></pre><p>另外，还可以用命令进行修改，不过只能临时生效</p><pre><code>    hostname  sc        将用户名修改为sc    hostname        查看主机名</code></pre><p><strong>DNS配置文件</strong></p><pre><code>        /etc/resolv.conf</code></pre><p>文件内容如下：</p><pre><code>nameserver  202.106.0.20如有多个DNS服务器地址，可在IP地址后面直接加，并以“，”分割，或者再起下一行写入“nameserver  xx.xx.xx.xx”</code></pre><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><ol><li><p>   ifconfig        查看网卡信息</p><blockquote><p>   -a     全部（包括没有启动的）</p></blockquote></li><li><p>   ifup  eth0        快速开启</p><blockquote><p>   ifdown    eth0        快速关闭</p></blockquote></li><li><p>   netstat   -an        查看所有网络连接</p><blockquote><p>netstat  -tlun        查看TCP和UDP协议监听的端口</p><p>   netstat   -rn        查看路由default：默认路由（网关）</p></blockquote></li><li><p>   route        查看路由</p><blockquote><p>   route  add   default   gw    192.168.140.1     手工设定网关，临时生效<br>   route  del    default   gw  192.168.190.6       删除网关</p></blockquote></li><li><p>   ping    IP    探测网络畅通</p></li><li><p>   traceroute    ip或域名        探测到目的地址的路径（Linux命令）</p><blockquote><p>   tracert   ip       （windows命令）</p></blockquote></li><li><p>   tcpdump</p><blockquote><p>   tcpdump -i eth0 -nnX port 21        抓取eth0网卡  21端口的传输信息</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161007/ifconfig.png&quot; alt=&quot;Linux网络配置&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP魔术方法小结</title>
    <link href="https://weizhimiao.github.io/2016/10/06/PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/10/06/PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2016-10-06T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>魔术方法：</p><blockquote><p>一种特殊的函数</p></blockquote><span id="more"></span><h2 id="构造方法：-construct-或者和类名同名的方法"><a href="#构造方法：-construct-或者和类名同名的方法" class="headerlink" title="构造方法： __construct()  或者和类名同名的方法"></a>构造方法： __construct()  或者和类名同名的方法</h2><p>触发时机：在对象实例化的时候自动触发。</p><p>作用：初始化成员属性</p><p>参数：可以有，可以没有，取决于设定和逻辑</p><p>返回值：没有</p><p>注意：如果构造方法具有参数，且参数没有默认值，在实例化对象时，必须在类名()内添加对应的实参值。</p><h2 id="析构方法-destruct"><a href="#析构方法-destruct" class="headerlink" title="析构方法 __destruct()"></a>析构方法 __destruct()</h2><p>触发时机： 在销毁对象的时候自动触发(unset或者页面执行完毕)</p><p>作用：回收对象使用过程中的资源。</p><p>参数：没有</p><p>返回值：没有</p><h2 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h2><p>触发时机：访问私有成员属性的时候自动触发</p><p>功能：1.防止报错  2.为私有属性访问提供后门</p><p>参数：1个    访问的私有属性名称</p><p>返回值：可以有，可以没有</p><h2 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h2><p>触发时机: 对私有成员属性进行设置值的时候自动触发</p><p>功能:1.屏蔽错误  2.为私有成员属性设置</p><p>参数: 2个   1私有成员属性名  2 要设置的值</p><p>返回值:无</p><h2 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h2><p>触发时机:对私有成员属性进行isset检测时自动触发</p><p>功能: 1.代替对象外部的isset检测，返回结果</p><p>参数: 1个   1私有成员属性名</p><p>返回值:有  一般返回 isset(属性)结果</p><h2 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h2><p>触发时机:在对象外部对私有成员属性进行unset操作时自动触发</p><p>功能: 1.代替对象外部的unset操作，返回结果</p><p>参数: 1个   1私有成员属性名</p><p>返回值:无</p><h2 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h2><p>触发时机：在对象进行串行化操作时触发.</p><p>功能：指定需要串行化的成员属性.</p><p>参数:无</p><p>返回值: 需要返回一个数组类型，每个元素都是需要串行化的成员属性名.</p><h2 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h2><p>触发时机：.在对象进行反串行化时自动触发</p><p>功能：.反串行化时自动修改部分成员属性值.</p><p>参数:无</p><p>返回值: 无</p><h2 id="tostring"><a href="#tostring" class="headerlink" title="__tostring()"></a>__tostring()</h2><p>触发时机：对一个对象进行echo操作时 自动触发</p><p>功能：简化操作或者为对象输出值</p><p>参数:无</p><p>返回值:必须有且必须为字符串类型.</p><h2 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h2><p>触发时机:对对象进行克隆操作时自动触发</p><p>功能：修改克隆之后的对象的部分属性值.</p><p>参数:无</p><p>返回值:无</p><p>注意：对象的赋值默认就是引用赋值，不能通过赋值操作获取一个新的对象，获取新对象的操作应该使用克隆操作</p><p>格式： 变量=clone 对象变量</p><h2 id="call（）"><a href="#call（）" class="headerlink" title="__call（）"></a>__call（）</h2><p>触发时机:    调用了类中不存在的方法时自动触发</p><p>功能：1.屏蔽错误  2.为不存在的方法定义个一个功能.</p><p>参数:2个   1 不存在的方法名   2所有的实参组成的数组</p><p>返回值:可有可无(根据实际功能来看)</p><h2 id="autoload-唯一一个类外部的魔术方法"><a href="#autoload-唯一一个类外部的魔术方法" class="headerlink" title="__autoload()(唯一一个类外部的魔术方法)"></a>__autoload()(唯一一个类外部的魔术方法)</h2><p>触发时机:    当页面中需要一个 类而该类不存在时自动触发</p><p>功能：实现类的自动加载.</p><p>参数1个 不存在的类名</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;魔术方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一种特殊的函数&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见的配置文件</title>
    <link href="https://weizhimiao.github.io/2016/10/06/Linux%E5%B8%B8%E8%A7%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://weizhimiao.github.io/2016/10/06/Linux%E5%B8%B8%E8%A7%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2016-10-06T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中我们经常需要修改各种配置文件，例如，启动引导程序配置文件、系统启动文件核脚本、网络配置文件、文件系统配置文件、文件服务程序配置文件等等。</p><span id="more"></span><h2 id="etc-passwd-用户信息配置文件"><a href="#etc-passwd-用户信息配置文件" class="headerlink" title="/etc/passwd    用户信息配置文件"></a>/etc/passwd    用户信息配置文件</h2><ul><li>文件作用：保存Linux用户信息</li><li>文件内容：<pre><code>root:x:0:0:root:/root:/bin/bash</code></pre></li></ul><p>说明：</p><ul><li><p>第一位：用户名</p></li><li><p>第二位：密码位（只是一个密码标志，真实密码并不是存在这）</p></li><li><p>第三位：UID    用户ID</p><blockquote><p>   0    超级管理员<br>   1-499    系统用户（伪用户）<br>   &gt;500    普通用户</p></blockquote></li><li><p>第四位：GID    初始组ID</p></li><li><p>第五位：用户说明</p></li><li><p>第六位：家目录</p></li><li><p>第七位：用户登录之后的权限</p><blockquote><p>常见的两种权限：</p><p>   /bin/bash</p><p>   /sbin/nologin伪用户，不能进行登陆</p></blockquote></li></ul><h2 id="etc-shadow-影子文件"><a href="#etc-shadow-影子文件" class="headerlink" title="/etc/shadow    影子文件"></a>/etc/shadow    影子文件</h2><ul><li>文件作用：保存用户密码，及密码的有效期</li><li>文件内容：<pre><code>root:$6$w5RBeFe7Y1bixrQR$tp0zHL1bMmAVv0SAS56LsCOyZ4KUj3V0GI0dRZ4KSlf.ggisV7dwiQ8s5xebcZghVDxwlYTjN6qKGU9zRc.En1:16247:0:99999:7:::</code></pre></li></ul><p>说明：</p><ul><li><p>第一字段：用户名（也被称为登录名），在/etc/shadow中，用户名和/etc/passwd 是相同的，这样就把passwd 和shadow中用的用户记录联系在一起；这个字段是非空的</p></li><li><p>第二字段：密码（已被加密），如果是有些用户在这段是x，表示这个用户不能登录到系统；这个字段是非空的</p></li><li><p>第三字段：上次修改口令的时间；这个时间是从1970年01月01日算起到最近一次修改口令的时间间隔（天数），您可以通过passwd 来修改用户的密码，然后查看/etc/shadow中此字段的变化</p></li><li><p>第四字段：两次修改口令间隔最少的天数；如果设置为0,则禁用此功能；也就是说用户必须经过多少天才能修改其口令；此项功能用处不是太大；默认值是通过/etc/login.defs文件定义中获取，PASS_MIN_DAYS 中有定义</p></li><li><p>第五字段：两次修改口令间隔最多的天数；这个能增强管理员管理用户口令的时效性，应该说在增强了系统的安全性；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_MAX_DAYS 中定义</p></li><li><p>第六字段：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将要作废；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_WARN_AGE 中定义</p></li><li><p>第七字段：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，系统会禁用此用户，也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用</p></li><li><p>第八字段：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用</p></li><li><p>第九字段：保留字段，目前为空，以备将来Linux发展之用</p></li></ul><h2 id="etc-group-用户组配置文件"><a href="#etc-group-用户组配置文件" class="headerlink" title="/etc/group    用户组配置文件"></a>/etc/group    用户组配置文件</h2><ul><li><p>文件作用：用户组配置</p></li><li><p>文件内容：</p><pre><code>root:x:0:bin:x:1:bin,daemon</code></pre><p>说明：</p></li><li><p>组名：组密码位：组ID：组中的附加用户</p></li><li><p>初始组：每个用户初始组只能有一个，初始组只能有一个，一般都是和用户名相同的组作为初始组</p></li><li><p>附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组</p></li></ul><h2 id="etc-sysconfig-network-scripts-ifcfg-eth0-网卡信息文件"><a href="#etc-sysconfig-network-scripts-ifcfg-eth0-网卡信息文件" class="headerlink" title="/etc/sysconfig/network-scripts/ifcfg-eth0    网卡信息文件"></a>/etc/sysconfig/network-scripts/ifcfg-eth0    网卡信息文件</h2><ul><li>文件作用：保存网卡配置</li><li>文件内容：<pre><code>DEVICE=eth0                    网卡设备名BOOTPROTO=none                是否自动获取IP。none：不生效                    static：手动        dhcp：动态获取IPBROADCAST=192.168.140.255            广播地址HWADDR=00:0c:29:21:80:48            mac地址IPADDR=192.168.140.253            IP地址IPV6INIT=yes                    IPv6开启IPV6_AUTOCONF=yes                IPv6获取NETMASK=255.255.255.0                掩码NETWORK=192.168.140.0                网段ONBOOT=yes                    网卡开机启动TYPE=Ethernet                    以太网GATEWAY=192.168.140.1                网关</code></pre></li></ul><p>说明：</p><ul><li><p>如果是采用DHCP方式获取IP信息，则可以只填写上述用橙色标记的配置项即可。</p></li><li><p>修改配置文件后，需要重启服务（如service  network  restart）。</p></li></ul><h2 id="etc-udev-rules-d-70-persistent-net-rules-网卡和MAC地址绑定文件"><a href="#etc-udev-rules-d-70-persistent-net-rules-网卡和MAC地址绑定文件" class="headerlink" title="/etc/udev/rules.d/70-persistent-net.rules    网卡和MAC地址绑定文件"></a>/etc/udev/rules.d/70-persistent-net.rules    网卡和MAC地址绑定文件</h2><ul><li>文件作用：绑定网卡和MAC地址</li><li>文件内容：<pre><code>SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:41:c7:1f&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot;</code></pre></li></ul><p>说明：</p><ul><li>当虚拟机网卡不通是，有时需要删除<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 中的MAC地址行，并且要删掉此文件。</li></ul><h2 id="etc-inittab-系统默认运行级别配置文件"><a href="#etc-inittab-系统默认运行级别配置文件" class="headerlink" title="/etc/inittab    系统默认运行级别配置文件"></a>/etc/inittab    系统默认运行级别配置文件</h2><ul><li>文件作用：设置默认系统运行级别。</li><li>文件内容：<pre><code>id:3:initdefault:</code></pre></li></ul><p>说明：</p><pre><code>运行级别可分为：# Default runlevel. The runlevels used are:#   0 - halt (Do NOT set initdefault to this)#   1 - Single user mode#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)#   3 - Full multiuser mode    命令行#   4 - unused#   5 - X11            图形界面#   6 - reboot (Do NOT set initdefault to this)</code></pre><h2 id="etc-rc-local—-gt-etc-rc-d-rc-local-自启动程序配置文件"><a href="#etc-rc-local—-gt-etc-rc-d-rc-local-自启动程序配置文件" class="headerlink" title="/etc/rc.local—-&gt;/etc/rc.d/rc.local    自启动程序配置文件"></a>/etc/rc.local—-&gt;/etc/rc.d/rc.local    自启动程序配置文件</h2><ul><li>文件作用：设置自启动程序，系统启动时会一次执行该文件中的命令</li><li>文件内容<pre><code># This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don&#39;t# want to do the full Sys V style init stuff.touch /var/lock/subsys/localulimit -SHn 65535</code></pre></li></ul><h2 id="etc-services-所有系统常见端口"><a href="#etc-services-所有系统常见端口" class="headerlink" title="/etc/services    所有系统常见端口"></a>/etc/services    所有系统常见端口</h2><ul><li>文件作用：显示系统常见的端口及绑定的协议</li></ul><h2 id="etc-sysconfig-network-主机名配置文件"><a href="#etc-sysconfig-network-主机名配置文件" class="headerlink" title="/etc/sysconfig/network        主机名配置文件"></a>/etc/sysconfig/network        主机名配置文件</h2><ul><li>文件作用：配置主机名，永久保存</li><li>文件内容：<pre><code>NETWORKING=yesHOSTNAME=localhost.localdomain</code></pre></li></ul><p>说明：</p><ul><li>建议不要更改。</li></ul><h2 id="etc-resolv-conf-DNS配置文件"><a href="#etc-resolv-conf-DNS配置文件" class="headerlink" title="/etc/resolv.conf        DNS配置文件"></a>/etc/resolv.conf        DNS配置文件</h2><ul><li>文件作用：设置ＤＮＳ服务器</li><li>文件内容：<pre><code>nameserver  202.106.0.20</code></pre></li></ul><p>说明：</p><ul><li>如有多个DNS服务器地址，可在IP地址后面直接加，并以“，”分割，或者再起下一行写入“nameserver  xx.xx.xx.xx”</li></ul><h2 id="etc-vimrc-vim配置文件"><a href="#etc-vimrc-vim配置文件" class="headerlink" title="/etc/vimrc vim配置文件"></a>/etc/vimrc vim配置文件</h2><p>别名配置文件</p><pre><code>~.bashrc</code></pre><h2 id="etc-selinux-config-seLinux的配置文件"><a href="#etc-selinux-config-seLinux的配置文件" class="headerlink" title="/etc/selinux/config seLinux的配置文件"></a>/etc/selinux/config seLinux的配置文件</h2><ul><li>文件内容<pre><code># This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of these two values:#     targeted - Targeted processes are protected,#     mls - Multi Level Security protection.SELINUXTYPE=targeted</code></pre></li></ul><p>关闭seLinux</p><ul><li>将配置文件中seLinux项改为SELINUX=disabled，然后重启Linux。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Linux中我们经常需要修改各种配置文件，例如，启动引导程序配置文件、系统启动文件核脚本、网络配置文件、文件系统配置文件、文件服务程序配置文件等等。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch整理</title>
    <link href="https://weizhimiao.github.io/2016/10/05/ElasticSearch%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/10/05/ElasticSearch%E6%95%B4%E7%90%86/</id>
    <published>2016-10-05T13:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>ElasticSearch是由Shay Banon发起的一个开源搜索服务器项目。由于其分布式特性和实时搜索能力，成为当前搜索和数据分析解决方案领域的重要成员。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161006/ElasticSearch.png" alt="ElasticSearch"></p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>索引</p><blockquote><p>索引（index）是ElasticSearch存放数据的一种逻辑结构。类比关系型数据库中的数据表。</p></blockquote><p>文档</p><blockquote><p>文档（document）是ElasticSearch中存储的主要实体。每个ElasticSearch文档类比关系型数据库中数据表的没一行数据。<br>文档由字段（行数据的列）组成，一个文档由多个字段组成，并且ElasticSearch允许一个字段重复出现多次，该类型字段被称为多只字段。每个字段对应一种类型（字符串型、数值型、日期型等），并且ElasticSearch可以自动确定字段类型。不同于关系型数据库，ElasticSearch的文档结构可以是不固定的。即不同的文档可以有不同的字段集合。</p></blockquote><p>文档类型</p><blockquote><p>ElasticSearch中，一个索引可以存储许多不同用途的对象。按照不同的用途我们可以将文档划分成不同的类型加以区分。</p></blockquote><p>节点和集群</p><blockquote><p>ElasticSearch既可以作为一个独立搜索服务器工作，也支持多台一起协作进行运行，构成一个集群（cluster），其中的每个服务器被称为节点（node）。ElasticSearch可以通过索引分片,将海量的数据进行分割并分布到不同的节点，来实现更强的可用性和更高的性能。</p></blockquote><p>分片</p><blockquote><p>对于存储大规模的文档，ElasticSearch会将数据进行切分，每部分切成一个单独的Apache Lucene索引，称为分片（shared）。每个分片可以存储在集群的不同的节点上，当一个查询需要用到多个分片时，ElasticSearch会将请求发送至多个分片，之后结果进行合并。</p></blockquote><p>副本</p><blockquote><p>分片副本是对原始分片的一个拷贝，每个主分片可以有零个或者多个副分片。当主分片丢失时，副分片就会被提升为主分片。启用分片副本功能，可以提高查询的吞吐或实现系统的高可用性。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>JDK6+</p><p>JDK的安装方式比较简单，只需将下载回来的程序包解压到相应的目录即可。</p><pre><code>wget http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.tar.gzmkdir /usr/local/javatar -zxf jdk-8u101-linux-x64.tar.gz -C /usr/local/java/</code></pre><p>设置JDK的环境变量，如下：</p><pre><code># tail -3 ~/.bash_profileexport JAVA_HOME=/usr/local/java/jdk1.8.0_101export PATH=$PATH:$JAVA_HOME/binexportCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$CLASSPATH</code></pre><p>重新加载环境变量</p><pre><code># source .bash_profile</code></pre><p>在Shell提示符中执行java –version命令，显示如下结果，说明安装成功：</p><pre><code># java -versionjava version &quot;1.8.0_45&quot;Java(TM) SE Runtime Environment (build 1.8.0_45-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02,mixed mode)</code></pre><h3 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h3><p>下载Elasticsearch后，解压到对应的目录就完成Elasticsearch的安装。</p><pre><code># wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.7.0.zip# unzip elasticsearch-1.7.0.zip# mv elasticsearch-1.7.0 /usr/local/elasticsearch</code></pre><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>elasticsearch/├── bin│   ...#运行elasticsearch和进行插件管理所需的脚本├── config│   ...#elasticsearch配置文件所在目录├── data│   ...#存储elasticsearch用到的数据├── lib│   ...#elasticsearch运行中用到的库├── LICENSE.txt├── logs│   ...#存储elasticsearch运行中产生的事件信息和错误信息├── nohup├── NOTICE.txt└── README.textile10 directories, 60 files</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>所有的配置文件都位于config目录下。该目录下包含两个文件。</p><pre><code>├── config│   ├── elasticsearch.yml│   └── logging.yml</code></pre><p>elasticsearch.yml</p><blockquote><p>负责设置服务器的默认配置。<br>比较重要的两个值cluster.name 和 node.name.</p><ul><li>cluster.name,保存的是集群名称。通过集群名称可以区分不同的集群。配置具有相同名称的节点将尝试组成一个集群。</li><li>node.name，节点名称。我们也可以不指定该名称，elasticsearch会自动为节点选择一个唯一名称。但每次启动时这个唯一名称会发生改变。</li></ul></blockquote><p>其他配置</p><pre><code>##################### Elasticsearch Configuration Example #####################＃此文件包含各种配置设置的概述，＃针对操作人员。应用程序开发人员应该＃在咨询&lt;http://elasticsearch.org/guide&gt;指南。#＃安装过程被覆盖在＃&lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/setup.html&gt;。#＃Elasticsearch附带了大多数设置合理的默认值，＃所以你可以尝试使用它而不用修改。#＃大多数时候，这些默认值是蛮好的运行生产＃集群。如果你正在微调群集，或者想知道的某些配置选项＃效果，请_DO ask_上＃邮件列表或IRC频道[http://elasticsearch.org/community。#＃配置中的任何元素都可以用环境变量替换＃通过将它们放置在$ &#123;...&#125;符号。 例如：##node.rack: $&#123;RACK_ENV_VAR&#125;＃有关支持的格式和配置文件信息语法，请参阅＃&lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/setup-configuration.html&gt;################################### Cluster 集群###################################＃集群名称标识群集的自动发现。如果你在同一个网络上的正在运行多个群集，请确保您使用的是唯一的名称。＃＃cluster.name：elasticsearch#################################### Node 节点#####################################＃节点名称是在启动时动态生成的，但你也可以手动配置它们。你可以给这个节点起一个特定的名称：＃#node.name: &quot;Franz Kafka&quot;＃每个节点可以被配置为允许或拒绝称为集群主节点，＃和允许或拒绝来存储数据。＃＃允许此节点可以作为主节点（默认启用）：＃#node.master: true## 允许此节点可以用来存储数据（默认启用）：##node.data: true＃你可以利用这些设置，以设计高级集群拓扑。＃＃1，你想这个节点永远不会成为一个主节点，只保存数据。这将是群集的“主力”。＃＃#node.master: false#node.data: true#＃2，你要这个节点只能作为主：不存储任何数据和有免费的资源。这将是群集的“协调员”。＃＃#node.master: true#node.data: false#＃3，你希望这个节点是不是主数据节点，但可以充当“搜索负载平衡器”（取从节点的数据，聚集结果等）＃#node.master: false#node.data: false＃使用群集健康状况API[http://localhost:9200/_cluster/health]，＃节点信息API[http://localhost:9200/_nodes]或GUI工具＃如&lt;http://www.elasticsearch.org/overview/marvel/&gt;＃&lt;http://github.com/karmi/elasticsearch-paramedic&gt;＃&lt;http://github.com/lukas-vlcek/bigdesk&gt;和＃&lt;http://mobz.github.com/elasticsearch-head&gt;检查群集状态。＃一个节点可以有与之关联的通用属性，可用于定制分片分配过滤，或分配意识。＃＃属性是一个简单的键值对，类似node.key：值，下面是一个例子：＃#node.rack: rack314＃默认情况下，多个节点被允许从相同的安装位置# 如果要禁用的话，设置如下：#node.max_local_storage_nodes: 1#################################### Index 索引#####################################＃您可以设置一些选项（如分片/副本选项，映射或分析器的定义，事务日志设置...）对全局参数，在这个文件中。## Note, that it makes more sense to configure index settings specifically for# a certain index, either when creating it or by using the index templates API.#＃请注意，它更有意义专门配置索引设置＃某个具体的索引，创造它或使用该索引模板API。# See &lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/index-modules.html&gt; and# &lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/indices-create-index.html&gt;# for more information.# 设置一个索引的分片（副本）数量（默认 5）##index.number_of_shards: 5＃设置索引（默认值为1）的副本（额外副本）数量：＃#index.number_of_replicas: 1# Note, that for development on a local machine, with small indices, it usually# makes sense to &quot;disable&quot; the distributed features:#＃注意，对于在本地机器，它通常比较小的值。禁用分布式特点是很有必要的＃#index.number_of_shards: 1#index.number_of_replicas: 0＃这些设置直接影响索引和搜索操作的性能＃在集群中。假设你有足够多的机器来保存分片及＃副本，经验法则是：## 1. 更多的分片能提高索引效率，一个大的索引允许存储在不同的服务器上# 2. 更多的副本能够提高搜索效率，并且能够增强系统的可用性##  &quot;number_of_shards&quot; 对于一个索引不能动态修改设置一次.## T &quot;number_of_replicas&quot; 可以增加或者减少在任何时候，通过索引更新或者api操作## Elasticsearch takes care about load balancing, relocating, gathering the# results from nodes, etc. Experiment with different settings to fine-tune# your setup.＃Elasticsearch需要关心负载均衡，搬迁，从节点收集结果，等。# 你可以通过不断的微调进行设置＃使用索引状态API（&lt;http://localhost:9200/A/_status&gt;）检查＃索引状态。#################################### Paths ##################################### 路径包含目录配置（此文件并logging.yml）：#path.conf: /path/to/conf# 索引数据存储路径配置#path.data: /path/to/data#＃可以任选地包括一个以上的位置，方便扩展和使用。 例如：##path.data: /path/to/data1,/path/to/data2# 临时文件路径：##path.work: /path/to/work# 日志文件路径:##path.logs: /path/to/logs# 插件安装目录##path.plugins: /path/to/plugins#################################### Plugin #################################### 如果这里列出的插件没有安装用于当前节点，该节点将无法启动。##plugin.mandatory: mapper-attachments,lang-groovy################################### Memory ####################################＃Elasticsearch表现不佳时，JVM启动交换：你应该确保它永远不会_交换。## 将此属性设置为true锁定内存：##bootstrap.mlockall: true# 确保ES_MIN_MEM和ES_MAX_MEM环境变量设置＃为相同的值，并且该机器有足够的内存来分配＃为Elasticsearch，留出足够的内存为操作系统本身。＃## You should also make sure that the Elasticsearch process is allowed to lock# the memory, eg. by using `ulimit -l unlimited`.# 你还应该确保该Elasticsearch允许进程锁定内存＃例如。通过使用`ulimit -l unlimited`。############################## Network And HTTP ###############################＃Elasticsearch，默认情况下，本身绑定到0.0.0.0地址，并监听＃端口[9200-9300] HTTP流量和端口[9300-9400]节点到节点＃沟通。（范围意味着，如果端口忙，它会自动将＃尝试下口）。# 设置绑定专用地址（IPv4或IPv6）：#network.bind_host: 192.168.0.1＃设置其他节点将使用与该节点通信的地址。否则＃，它会自动的产生。它必须指向一个实际的IP地址。##network.publish_host: 192.168.0.1# 同时设置“bind_host&#39;和&#39;publish_host”：##network.host: 192.168.0.1# 设置一个自定义的节点间通讯端口，（默认为 9300）#transport.tcp.port: 9300# 启用节点间通讯压缩##transport.tcp.compress: true# 设置自定义端口侦听HTTP流量：##http.port: 9200# 设置自定义允许的内容长度：##http.max_content_length: 100mb# 完全禁用HTTP：##http.enabled: false################################### Gateway ###################################＃网关允许持收集集群之间的群集状态＃集群中每个状态改变（例如添加一个索引），都将会存储＃在网关，并且当集群首次启动时，＃它会从网关读出其状态。＃有几种类型的网关实现的。欲了解更多信息，请参阅# &lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/modules-gateway.html&gt;.＃默认网关类型为“本地”网关（推荐）：##gateway.type: local# 设置当集群崩溃时，如何重新启动并恢复进程（使用共享网关时，尽可能多的使用本地数据）# 允许恢复后，在一个集群中有N个节点：##gateway.recover_after_nodes: 1＃设置超时时间，在启动恢复过程中，前面设置的N个节点全部重启（接受时间值）：##gateway.recover_after_time: 5m＃设置在一个句群众预计的节点数#一旦这些N个节点全部启用（满足recover_after_nodes），立即开始恢复过程（无需等待恢复时间后到期）：##gateway.expected_nodes: 2############################# Recovery Throttling 恢复节流 #############################＃这些设置可以控制碎片分配的过程，在节点恢复期间、副本定位、重新平衡，或添加和删除节点时## 设置一个节点上同时恢复数量# 1. 初步恢复期间##cluster.routing.allocation.node_initial_primaries_recoveries: 4## 2. 在添加/删除节点，再平衡期间##cluster.routing.allocation.node_concurrent_recoveries: 2# 设置一个恢复时的吞吐量值（如100MB，默认20MB）##indices.recovery.max_bytes_per_sec: 20mb# 设置一个并发流数量限制，在同级别的分片恢复时##indices.recovery.concurrent_streams: 5################################## Discovery 发现##################################＃发现基础设施，确保节点可以在群集内找到和主节点的选举。是默认是通过多播方式来进行发现。# 设置一个节点确保能在集群内发现N个其他合格的节点能成为主节点。#discovery.zen.minimum_master_nodes: 1# 设置一个过期时间，在通过ping发现其他节点时# 在一个较差的网络环境中设置一个较长的值，可以最大限度的减少报错#discovery.zen.ping.timeout: 3s# 更多的信息，请看# &lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/modules-discovery-zen.html&gt;＃单播发现允许明确地控制哪些节点将被用于发现群集。它可以在多播不存在，或限制集群通信时使用。## 1. 多播发现（默认启用）##discovery.zen.ping.multicast.enabled: false## 2. 配置一个初始清单在集群的主节点上，为了发现一个刚启用的节点##discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]# 为了发现 ，EC2允许使用AWS EC2 API# 你必须安装云AWS插件启用EC2发现。## 更多信息请查看# &lt;http://elasticsearch.org/guide/en/elasticsearch/reference/current/modules-discovery-ec2.html&gt;## See &lt;http://elasticsearch.org/tutorials/elasticsearch-on-ec2/&gt;# 一步一步的教程# 为了发现 ，GCE发现允许使用谷歌Compute Engine的API## 你必须安装云GCE GCE插件启用的发现。## For more information, see &lt;https://github.com/elasticsearch/elasticsearch-cloud-gce&gt;.# Azure的发现允许以执行发现使用Azure的API。## 你必须安装云cloud-azure插件启用的发现。# For more information, see &lt;https://github.com/elasticsearch/elasticsearch-cloud-azure&gt;.################################## Slow Log ################################### 分片级查询并会的对应等级的日志#index.search.slowlog.threshold.query.warn: 10s#index.search.slowlog.threshold.query.info: 5s#index.search.slowlog.threshold.query.debug: 2s#index.search.slowlog.threshold.query.trace: 500ms#index.search.slowlog.threshold.fetch.warn: 1s#index.search.slowlog.threshold.fetch.info: 800ms#index.search.slowlog.threshold.fetch.debug: 500ms#index.search.slowlog.threshold.fetch.trace: 200ms#index.indexing.slowlog.threshold.index.warn: 10s#index.indexing.slowlog.threshold.index.info: 5s#index.indexing.slowlog.threshold.index.debug: 2s#index.indexing.slowlog.threshold.index.trace: 500ms################################## GC Logging #################################monitor.jvm.gc.young.warn: 1000ms#monitor.jvm.gc.young.info: 700ms#monitor.jvm.gc.young.debug: 400ms#monitor.jvm.gc.old.warn: 10s#monitor.jvm.gc.old.info: 5s#monitor.jvm.gc.old.debug: 2s################################## Security ################################# Uncomment if you want to enable JSONP as a valid return transport on the# http server. With this enabled, it may pose a security risk, so disabling# it unless you need it is recommended (it is disabled by default).＃不推荐，如果要启用JSONP作为HTTP服务器上的返回。#启用此功能，它可能会带来安全风险，因此禁用它，除非你需要的建议（它被默认禁用）。#http.jsonp.enable: true</code></pre><p>logging.yml</p><blockquote><p>定义多少信息写入系统日志、定义日志文件，并定期创建新文件</p></blockquote><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>启动Elasticsearch</p><pre><code># /usr/local/elasticsearch/bin/elasticsearch  -d</code></pre><blockquote><p>-d 表示将进程放入后台运行</p></blockquote><p>或者通过nohup命令</p><pre><code># nohup /usr/local/elasticsearch/bin/elasticsearch &gt; nohup</code></pre><p>将elasticsearch设置成开机自启动</p><pre><code># echo &quot;nohup /usr/local/elasticsearch/bin/elasticsearch &gt; nohup&quot; &gt; /etc/rc.local</code></pre><p>确认elasticsearch的9200端口已监听，说明elasticsearch已成功运行</p><pre><code># netstat -anp |grep :9200tcp        0      0 :::9200                     :::*                        LISTEN      3362/java</code></pre><p>如何关闭elasticsearch</p><ul><li>方法一：如果节点与控制台相连并且当前elasticsearch是使用-f选项运行，则只需要按下Ctrl+C组合键即可</li><li>方法二：通过发送TERM信号来终止服务器进程 kill -9 进程ID</li><li>方法三：使用REST API</li></ul><p>关闭整个集群</p><pre><code># curl -XPOST http://localhost:9200/_cluster/nodes/_shutdown</code></pre><p>关闭单个节点</p><pre><code># curl -XPOST  http://127.0.0.1:9200/_cluster/nodes/2ens0yuEQ12G6ct1UDpihQ/_shutdown</code></pre><p>2ens0yuEQ12G6ct1UDpihQ ，为要关闭的节点标志符</p><p>查看节点标志符，可以从elasticsearch日志中或者通过REST API中获得</p><pre><code># curl http://localhost:9200/_nodes/?pretty&#123;  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;nodes&quot; : &#123;    &quot;13QfvIdATEurGAhVAlO6tQ&quot; : &#123;      &quot;name&quot; : &quot;Edwin Jarvis&quot;,      ...    &#125;  &#125;&#125;</code></pre><p>13QfvIdATEurGAhVAlO6tQ,即为节点标志符</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code># curl http://localhost:9200&#123;  &quot;status&quot; : 200,  &quot;name&quot; : &quot;Destroyer of Demons&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;1.7.0&quot;,    &quot;build_hash&quot; : &quot;929b9739cae115e73c346cb5f9a6f24ba735a743&quot;,    &quot;build_timestamp&quot; : &quot;2015-07-16T14:31:07Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;4.10.4&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><p>查看elasticsearch服务器当前运行状况</p><pre><code># curl http://localhost:9200/_cluster/health?pretty&#123;  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;status&quot; : &quot;green&quot;,  &quot;timed_out&quot; : false,  &quot;number_of_nodes&quot; : 1,  &quot;number_of_data_nodes&quot; : 1,  &quot;active_primary_shards&quot; : 0,  &quot;active_shards&quot; : 0,  &quot;relocating_shards&quot; : 0,  &quot;initializing_shards&quot; : 0,  &quot;unassigned_shards&quot; : 0,  &quot;delayed_unassigned_shards&quot; : 0,  &quot;number_of_pending_tasks&quot; : 0,  &quot;number_of_in_flight_fetch&quot; : 0&#125;</code></pre><h2 id="使用（基于REST-API数据操作）"><a href="#使用（基于REST-API数据操作）" class="headerlink" title="使用（基于REST API数据操作）"></a>使用（基于REST API数据操作）</h2><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST 定义了一组体系架构原则，您可以根据这些原则设计以系统资源为中心的 Web 服务，包括使用不同语言编写的客户端如何通过 HTTP 处理和传输资源状态。 它用简洁易行的方式向HTTP中的条目暴露CRUD（Create、Replace、Update、Delete，创建、替换、更新、删除）的应用功能。</p><h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>示例：创建一个文档用来存储一篇blog，内容如下：</p><pre><code>&#123;  &quot;title&quot;:&quot;my first article title&quot;,  &quot;content&quot;:&quot;this is article content&quot;,  &quot;date&quot;:&quot;2016-10-05&quot;&#125;</code></pre><p>操作：</p><pre><code># curl -XPUT  http://localhost:9200/blog/article/1 -d &#39;&#123;&quot;title&quot;:&quot;my first article title&quot;,&quot;content&quot;:&quot;this is article content&quot;,&quot;date&quot;:&quot;2016-10-05&quot;&#125;&#39;</code></pre><p>返回结果如下：</p><pre><code>&#123;&quot;_index&quot;:&quot;blog&quot;,&quot;_type&quot;:&quot;article&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:1,&quot;created&quot;:true&#125;</code></pre><p>返回了操作结果信息，并显示新文档的存储位置。并且包含文档的唯一标识符以及当前版本信息。</p><h3 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h3><p>按照REST风格，我们想要查看刚才创建的文档。</p><pre><code># curl -XGET  http://localhost:9200/blog/article/1</code></pre><p>结果</p><pre><code>curl -XGET  http://localhost:9200/blog/article/1?pretty&#123;  &quot;_index&quot; : &quot;blog&quot;,  &quot;_type&quot; : &quot;article&quot;,  &quot;_id&quot; : &quot;1&quot;,  &quot;_version&quot; : 1,  &quot;found&quot; : true,  &quot;_source&quot;:&#123;&quot;title&quot;:&quot;my first article title&quot;,&quot;content&quot;:&quot;this is article content&quot;,&quot;date&quot;:&quot;2016-10-05&quot;&#125;&#125;</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>Elasticsearch中更新索引中的文档是非常复杂的工作。必须先提取文档、从_source字段获得数据、移除旧文档、应用变更，作为新文档创建索引。</p><p>示例，更改之前创建的blog，并增加author字段</p><pre><code># curl -XPOST  http://localhost:9200/blog/article/1 -d &#39;&#123;&quot;title&quot;:&quot;my first article title&quot;,&quot;content&quot;:&quot;this is article content&quot;,&quot;date&quot;:&quot;2016-10-05&quot;,&quot;author&quot;:&quot;zhimiao&quot;&#125;&#39;</code></pre><p>结果：</p><pre><code># &#123;&quot;_index&quot;:&quot;blog&quot;,&quot;_type&quot;:&quot;article&quot;,&quot;_id&quot;:&quot;1&quot;,&quot;_version&quot;:3,&quot;created&quot;:false&#125;</code></pre><p>查看是否更新成功</p><pre><code># curl -XGET  http://localhost:9200/blog/article/1?pretty&#123;  &quot;_index&quot; : &quot;blog&quot;,  &quot;_type&quot; : &quot;article&quot;,  &quot;_id&quot; : &quot;1&quot;,  &quot;_version&quot; : 4,  &quot;found&quot; : true,  &quot;_source&quot;:&#123;&quot;title&quot;:&quot;my first article title&quot;,&quot;content&quot;:&quot;this is article content&quot;,&quot;date&quot;:&quot;2016-10-05&quot;,&quot;author&quot;:&quot;zhimiao&quot;&#125;&#125;</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><pre><code># curl -XDELETE  http://localhost:9200/blog/article/1?pretty&#123;  &quot;found&quot; : true,  &quot;_index&quot; : &quot;blog&quot;,  &quot;_type&quot; : &quot;article&quot;,  &quot;_id&quot; : &quot;1&quot;,  &quot;_version&quot; : 7&#125;</code></pre><p>查看是否已删除</p><pre><code># curl -XGET  http://localhost:9200/blog/article/1?pretty&#123;  &quot;_index&quot; : &quot;blog&quot;,  &quot;_type&quot; : &quot;article&quot;,  &quot;_id&quot; : &quot;1&quot;,  &quot;found&quot; : false&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;ElasticSearch是由Shay Banon发起的一个开源搜索服务器项目。由于其分布式特性和实时搜索能力，成为当前搜索和数据分析解决方案领域的重要成员。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161006/ElasticSearch.png&quot; alt=&quot;ElasticSearch&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="ElasticSearch" scheme="https://weizhimiao.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>keepalive工作原理和配置(转)</title>
    <link href="https://weizhimiao.github.io/2016/10/05/keepalived%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/10/05/keepalived%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2016-10-05T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keepalived是什么"><a href="#keepalived是什么" class="headerlink" title="keepalived是什么"></a>keepalived是什么</h2><p>keepalived是集群管理中保证集群高可用的一个服务软件，其功能类似于<a href="https://github.com/chenzhiwei/linux/tree/master/heartbeat">heartbeat</a>，用来防止单点故障。</p><h2 id="keepalived工作原理"><a href="#keepalived工作原理" class="headerlink" title="keepalived工作原理"></a>keepalived工作原理</h2><p>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即<a href="http://en.wikipedia.org/wiki/VRRP">虚拟路由冗余协议</a>。</p><p>虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据<a href="http://tools.ietf.org/html/rfc5798#section-5.1">VRRP的优先级</a>来选举一个backup当master。这样的话就可以保证路由器的高可用了。</p><p>keepalived主要有三个模块，分别是core、check和vrrp。</p><ul><li>core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。</li><li>check负责健康检查，包括常见的各种检查方式。</li><li>vrrp模块是来实现VRRP协议的。</li></ul><span id="more"></span><h2 id="keepalived的配置文件"><a href="#keepalived的配置文件" class="headerlink" title="keepalived的配置文件"></a>keepalived的配置文件</h2><p>keepalived只有一个配置文件keepalived.conf，里面主要包括以下几个配置区域，分别是global_defs、static_ipaddress、static_routes、vrrp_script、vrrp_instance和virtual_server。</p><h3 id="global-defs区域"><a href="#global-defs区域" class="headerlink" title="global_defs区域"></a>global_defs区域</h3><blockquote><p>主要是配置故障发生时的通知对象以及机器标识</p></blockquote><pre><code>global_defs &#123;    notification_email &#123;        a@abc.com        b@abc.com        ...    &#125;    notification_email_from alert@abc.com    smtp_server smtp.abc.com    smtp_connect_timeout 30    enable_traps    router_id host163&#125;</code></pre><ul><li>notification_email 故障发生时给谁发邮件通知。</li><li>notification_email_from 通知邮件从哪个地址发出。</li><li>smpt_server 通知邮件的smtp地址。</li><li>smtp_connect_timeout 连接smtp服务器的超时时间。</li><li>enable_traps 开启SNMP陷阱（<a href="http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">Simple Network Management Protocol</a>）。</li><li>router_id 标识本节点的字条串，通常为hostname，但不一定非得是hostname。故障发生时，邮件通知会用到。</li></ul><h3 id="static-ipaddress和static-routes"><a href="#static-ipaddress和static-routes" class="headerlink" title="static_ipaddress和static_routes"></a>static_ipaddress和static_routes</h3><blockquote><p>static_ipaddress和static_routes区域配置的是是本节点的IP和路由信息。如果你的机器上已经配置了IP和路由，那么这两个区域可以不用配置。<br>其实，一般情况下你的机器都会有IP地址和路由信息的，因此没必要再在这两个区域配置。</p></blockquote><pre><code>static_ipaddress &#123;    10.210.214.163/24 brd 10.210.214.255 dev eth0    ...&#125;</code></pre><pre><code>static_routes &#123;    10.0.0.0/8 via 10.210.214.1 dev eth0    ...&#125;</code></pre><p>以上分别表示启动/关闭keepalived时在本机执行的如下命令：</p><pre><code># /sbin/ip addr add 10.210.214.163/24 brd 10.210.214.255 dev eth0# /sbin/ip route add 10.0.0.0/8 via 10.210.214.1 dev eth0# /sbin/ip addr del 10.210.214.163/24 brd 10.210.214.255 dev eth0# /sbin/ip route del 10.0.0.0/8 via 10.210.214.1 dev eth0</code></pre><p>注意： 请忽略这两个区域，因为我坚信你的机器肯定已经配置了IP和路由。</p><h3 id="vrrp-script"><a href="#vrrp-script" class="headerlink" title="vrrp_script"></a>vrrp_script</h3><blockquote><p>用来做健康检查的，当时检查失败时会将vrrp_instance的priority减少相应的值。</p></blockquote><pre><code>vrrp_script chk_http_port &#123;    script &quot;&lt;/dev/tcp/127.0.0.1/80&quot;    interval 1    weight -10&#125;</code></pre><p>以上意思是如果script中的指令执行失败，那么相应的vrrp_instance的优先级会减少10个点。</p><h3 id="vrrp-instance和vrrp-sync-group区域"><a href="#vrrp-instance和vrrp-sync-group区域" class="headerlink" title="vrrp_instance和vrrp_sync_group区域"></a>vrrp_instance和vrrp_sync_group区域</h3><blockquote><p>vrrp_instance用来定义对外提供服务的VIP区域及其相关属性。</p><p>vrrp_rsync_group用来定义vrrp_intance组，使得这个组内成员动作一致。</p></blockquote><p>举个例子来说明一下其功能：</p><p>两个vrrp_instance同属于一个vrrp_rsync_group，那么其中一个vrrp_instance发生故障切换时，另一个vrrp_instance也会跟着切换（即使这个instance没有发生故障）。</p><pre><code>vrrp_sync_group VG_1 &#123;    group &#123;        inside_network   # name of vrrp_instance (below)        outside_network  # One for each moveable IP.        ...    &#125;    notify_master /path/to_master.sh    notify_backup /path/to_backup.sh    notify_fault &quot;/path/fault.sh VG_1&quot;    notify /path/notify.sh    smtp_alert&#125;vrrp_instance VI_1 &#123;    state MASTER    interface eth0    use_vmac &lt;VMAC_INTERFACE&gt;    dont_track_primary    track_interface &#123;        eth0        eth1    &#125;    mcast_src_ip &lt;IPADDR&gt;    lvs_sync_daemon_interface eth1    garp_master_delay 10    virtual_router_id 1    priority 100    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 12345678    &#125;    virtual_ipaddress &#123;        10.210.214.253/24 brd 10.210.214.255 dev eth0        192.168.1.11/24 brd 192.168.1.255 dev eth1    &#125;    virtual_routes &#123;        172.16.0.0/12 via 10.210.214.1        192.168.1.0/24 via 192.168.1.1 dev eth1        default via 202.102.152.1    &#125;    track_script &#123;        chk_http_port    &#125;    nopreempt    preempt_delay 300    debug    notify_master &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    notify_backup &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    notify_fault &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    notify &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    smtp_alert&#125;</code></pre><ul><li>notify_master/backup/fault 分别表示切换为主/备/出错时所执行的脚本。</li><li>notify 表示任何一状态切换时都会调用该脚本，并且该脚本在以上三个脚本执行完成之后进行调用，keepalived会自动传递三个参数（$1 = “GROUP”|”INSTANCE”，$2 = name of group or instance，$3 = target state of transition(MASTER/BACKUP/FAULT)）。</li><li>smtp_alert 表示是否开启邮件通知（用全局区域的邮件设置来发通知）。</li><li>state 可以是MASTER或BACKUP，不过当其他节点keepalived启动时会将priority比较大的节点选举为MASTER，因此该项其实没有实质用途。</li><li>interface 节点固有IP（非VIP）的网卡，用来发VRRP包。</li><li>use_vmac 是否使用VRRP的虚拟MAC地址。</li><li>dont_track_primary 忽略VRRP网卡错误。（默认未设置）</li><li>track_interface 监控以下网卡，如果任何一个不通就会切换到FALT状态。（可选项）</li><li>mcast_src_ip 修改vrrp组播包的源地址，默认源地址为master的IP。（由于是组播，因此即使修改了源地址，该master还是能收到回应的）</li><li>lvs_sync_daemon_interface 绑定lvs syncd的网卡。</li><li>garp_master_delay 当切为主状态后多久更新ARP缓存，默认5秒。</li><li>virtual_router_id 取值在0-255之间，用来区分多个instance的VRRP组播。</li></ul><p>注意： 同一网段中virtual_router_id的值不能重复，否则会出错，相关错误信息如下。</p><pre><code>Keepalived_vrrp[27120]: ip address associated with VRID not present in received packet :one or more VIP associated with VRID mismatch actual MASTER advertbogus VRRP packet received on eth1 !!!receive an invalid ip number count associated with VRID!VRRP_Instance(xxx) ignoring received advertisment...</code></pre><p>可以用这条命令来查看该网络中所存在的vrid：<code>tcpdump -nn -i any net 224.0.0.0/8</code></p><ul><li>priority 用来选举master的，要成为master，那么这个选项的值最好<a href="http://tools.ietf.org/html/rfc5798#section-8.3.2">高于其他机器50个点</a>，该项<a href="http://tools.ietf.org/html/rfc5798#section-5.2.4">取值范围</a>是1-255（在此范围之外会被识别成默认值100）。</li><li>advert_int 发VRRP包的时间间隔，即多久进行一次master选举（可以认为是健康查检时间间隔）。</li><li>authentication 认证区域，认证类型有PASS和HA（IPSEC），推荐使用PASS（密码只识别前8位）。</li><li>virtual_ipaddress vip，不解释了。</li><li>virtual_routes 虚拟路由，当IP漂过来之后需要添加的路由信息。</li><li>virtual_ipaddress_excluded 发送的VRRP包里不包含的IP地址，为减少回应VRRP包的个数。在网卡上绑定的IP地址比较多的时候用。</li><li>nopreempt 允许一个priority比较低的节点作为master，即使有priority更高的节点启动。</li></ul><p>首先nopreemt必须在state为BACKUP的节点上才生效（因为是BACKUP节点决定是否来成为MASTER的），其次要实现类似于关闭auto failback的功能需要将所有节点的state都设置为BACKUP，或者将master节点的priority设置的比BACKUP低。我个人推荐使用将所有节点的state都设置成BACKUP并且都加上nopreempt选项，这样就完成了关于autofailback功能，当想手动将某节点切换为MASTER时只需去掉该节点的nopreempt选项并且将priority改的比其他节点大，然后重新加载配置文件即可（等MASTER切过来之后再将配置文件改回去再reload一下）。</p><p>当使用track_script时可以不用加nopreempt，只需要加上preempt_delay 5，这里的间隔时间要大于vrrp_script中定义的时长。</p><ul><li>preempt_delay master启动多久之后进行接管资源（VIP/Route信息等），并提是没有nopreempt选项。</li></ul><h3 id="virtual-server-group和virtual-server区域"><a href="#virtual-server-group和virtual-server区域" class="headerlink" title="virtual_server_group和virtual_server区域"></a>virtual_server_group和virtual_server区域</h3><blockquote><p>virtual_server_group一般在超大型的LVS中用到，一般LVS用不过这东西，因此不多说。</p></blockquote><pre><code>virtual_server IP Port &#123;    delay_loop &lt;INT&gt;    lb_algo rr|wrr|lc|wlc|lblc|sh|dh    lb_kind NAT|DR|TUN    persistence_timeout &lt;INT&gt;    persistence_granularity &lt;NETMASK&gt;    protocol TCP    ha_suspend    virtualhost &lt;STRING&gt;    alpha    omega    quorum &lt;INT&gt;    hysteresis &lt;INT&gt;    quorum_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    quorum_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;    sorry_server &lt;IPADDR&gt; &lt;PORT&gt;    real_server &lt;IPADDR&gt; &lt;PORT&gt; &#123;        weight &lt;INT&gt;        inhibit_on_failure        notify_up &lt;STRING&gt;|&lt;QUOTED-STRING&gt;        notify_down &lt;STRING&gt;|&lt;QUOTED-STRING&gt;        # HTTP_GET|SSL_GET|TCP_CHECK|SMTP_CHECK|MISC_CHECK        HTTP_GET|SSL_GET &#123;            url &#123;                path &lt;STRING&gt;                # Digest computed with genhash                digest &lt;STRING&gt;                status_code &lt;INT&gt;            &#125;            connect_port &lt;PORT&gt;            connect_timeout &lt;INT&gt;            nb_get_retry &lt;INT&gt;            delay_before_retry &lt;INT&gt;        &#125;    &#125;&#125;</code></pre><ul><li>delay_loop 延迟轮询时间（单位秒）。</li><li>lb_algo 后端调试算法（load balancing algorithm）。</li><li>lb_kind LVS调度类型NAT/DR/TUN。</li><li>virtualhost 用来给HTTP_GET和SSL_GET配置请求header的。</li><li>sorry_server 当所有real server宕掉时，sorry server顶替。</li><li>real_server 真正提供服务的服务器。</li><li>weight 权重。</li><li>notify_up/down 当real server宕掉或启动时执行的脚本。</li></ul><p>健康检查的方式，N多种方式。</p><ul><li>path 请求real serserver上的路径。</li><li>digest/status_code 分别表示用genhash算出的结果和http状态码。</li><li>connect_port 健康检查，如果端口通则认为服务器正常。</li><li>connect_timeout,nb_get_retry,delay_before_retry分别表示超时时长、重试次数，下次重试的时间延迟。</li></ul><p>其他选项暂时不作说明。</p><h2 id="keepalived主从切换"><a href="#keepalived主从切换" class="headerlink" title="keepalived主从切换"></a>keepalived主从切换</h2><p>主从切换比较让人蛋疼，需要将backup配置文件的priority选项的值调整的比master高50个点，然后reload配置文件就可以切换了。当时你也可以将master的keepalived停止，这样也可以进行主从切换。</p><h2 id="keepalived仅做HA时的配置"><a href="#keepalived仅做HA时的配置" class="headerlink" title="keepalived仅做HA时的配置"></a>keepalived仅做HA时的配置</h2><p>请看该文档同级目录下的配置文件示例。</p><p>说明：</p><ul><li>10.210.214.113 为keepalived的备机，其配置文件为113.keepalived.conf</li><li>10.210.214.163 为keepalived的主机，其配置文件为163.keepalived.conf</li><li>10.210.214.253 为Virtual IP，即提供服务的内网IP地址，在网卡eth0上面</li><li>192.168.1.11 为模拟的提供服务的公网IP地址，在网卡eth1上面</li></ul><p>用tcpdump命令来捕获的结果如下：</p><pre><code>17:20:07.919419 IP 10.210.214.163 &gt; 224.0.0.18: VRRPv2, Advertisement, vrid 1, prio 200, authtype simple, intvl 1s, length 20</code></pre><h2 id="LVS-Keepalived配置"><a href="#LVS-Keepalived配置" class="headerlink" title="LVS+Keepalived配置"></a>LVS+Keepalived配置</h2><blockquote><p>注:Keepalived与LVS结合使用时一般还会用到一个工具ipvsadm，用来查看相关VS相关状态，关于ipvsadm的用法可以参考man手册。</p></blockquote><p>10.67.15.95为keepalived master，VIP为10.67.15.94，配置文件为95-lvs-keepalived.conf</p><p>10.67.15.96为keepalived master，VIP为10.67.15.94，配置文件为96-lvs-keepalived.conf</p><p>10.67.15.195为real server  </p><p><strong>注意：</strong></p><p>当使用LVS+DR+Keepalived配置时，需要在real server上添加一条iptables规则（其中dport根据情况添加或缺省）：</p><pre><code># iptables -t nat -A PREROUTING -p tcp -d 10.67.15.94 --dport 80 -j REDIRECT</code></pre><p>当使用LVS+NAT+Keepalived配置时，需要将real server的默认路由配置成Director的VIP10.67.15.94，必须确保client的请求是通过10.67.15.94到达real server的。</p><h2 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h2><p>从keepalived<a href="http://www.keepalived.org/download.html">官网</a>下载合适的版本，解压并执行如下命令完成安装。</p><pre><code># cd keepalived-xxx# ./configure --bindir=/usr/bin --sbindir=/usr/sbin --sysconfdir=/etc --mandir=/usr/share# make &amp;&amp; make install</code></pre><p>你也可以打成<a href="https://github.com/chenzhiwei/linux/tree/master/rpm-package-management">RPM</a>包，然后安装。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>我们用到的HA场景如下： 两台主机host113和host163，内网IP在eth1网卡上，分别是10.210.214.113和10.210.214.163，VIP为公网IP在eth0上，IP地址是202.102.152.253，网关为202.102.152.1。当VIP在host113上提供服务时，host113上的默认路由为202.102.152.1，提供服务的端口为202.102.152.253:443。host113发生故障需要将VIP及服务切回到host163上的时候，需要以下几步，第一将VIP接管过来，第二添加默认路由202.102.152.1，第三启动在端口202.102.152.253:443上的服务。</p><p>如此一来，keepalived需要另外的脚本来完成添加默认路由和启动服务工作，这点和heartbeat中的resources是相同的。目前我进行了测试，发现keepalived速度要比heartbeat快，也就是说效率比heartbeat高。并且，最重要的一点，keepalived支持多个backup。</p><p>不要问我为何有以上需求。要为两个不同的域名提供https服务，由于SSL证书问题，必须有两个公网IP地址分别绑定443端口。</p><p>当然，通过<a href="http://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a>也可以实现一个公网IP绑定443端口来为多个域名提供https服务，但是这需要浏览器支持（M$的IE浏览器不支持）。（<a href="http://nginx.org/en/docs/http/configuring_https_servers.html#sni">nginx</a>/<a href="http://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI">apache</a>）</p><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>keepalived的主从切换比较让人蛋疼，需要修改配置文件或停止一方的运行。但是由于keepalived是通过vrrp协议来实现failover（故障转移）的，因此也决定了手动主从切换的不便。</p><p>keepalived的文档也很旧了，一直都找不到合适的文档，之前我就一直忽略了vrrp_script这个区域，导致很多事情想不通。</p><p>另外，我发现我越来越喜欢keepalived了。。。</p><p><a href="http://outofmemory.cn/wiki/keepalived-configuration">转自：http://outofmemory.cn/wiki/keepalived-configuration</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;keepalived是什么&quot;&gt;&lt;a href=&quot;#keepalived是什么&quot; class=&quot;headerlink&quot; title=&quot;keepalived是什么&quot;&gt;&lt;/a&gt;keepalived是什么&lt;/h2&gt;&lt;p&gt;keepalived是集群管理中保证集群高可用的一个服务软件，其功能类似于&lt;a href=&quot;https://github.com/chenzhiwei/linux/tree/master/heartbeat&quot;&gt;heartbeat&lt;/a&gt;，用来防止单点故障。&lt;/p&gt;
&lt;h2 id=&quot;keepalived工作原理&quot;&gt;&lt;a href=&quot;#keepalived工作原理&quot; class=&quot;headerlink&quot; title=&quot;keepalived工作原理&quot;&gt;&lt;/a&gt;keepalived工作原理&lt;/h2&gt;&lt;p&gt;keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即&lt;a href=&quot;http://en.wikipedia.org/wiki/VRRP&quot;&gt;虚拟路由冗余协议&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据&lt;a href=&quot;http://tools.ietf.org/html/rfc5798#section-5.1&quot;&gt;VRRP的优先级&lt;/a&gt;来选举一个backup当master。这样的话就可以保证路由器的高可用了。&lt;/p&gt;
&lt;p&gt;keepalived主要有三个模块，分别是core、check和vrrp。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。&lt;/li&gt;
&lt;li&gt;check负责健康检查，包括常见的各种检查方式。&lt;/li&gt;
&lt;li&gt;vrrp模块是来实现VRRP协议的。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="负载均衡" scheme="https://weizhimiao.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Nginx服务器https配置</title>
    <link href="https://weizhimiao.github.io/2016/10/04/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8https%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/10/04/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8https%E9%85%8D%E7%BD%AE/</id>
    <published>2016-10-04T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161004/https.png" alt="Nginx服务器https配置"></p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Linux：Linux version 3.10.0-123.9.3.el7.x86_64<br>Nginx：nginx/1.6.3<br>openssl：1.0.1e</p><h2 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h2><p>目前网上有不少机构提供个人免费 ssl 证书，有效期几个月到几年不等。以 <a href="https://www.startssl.com/">StartSSL :https://www.startssl.com</a> 为例, 申请成功后有效期 3 年，到期后可免费续租。<br>具体申请过程也很简单。<br>注册登录以后选择 Certificates Wizard &gt;&gt;     DV SSL Certificate 申请一个免费的 ssl 证书。</p><p>通过邮件验证域名之后，然后在自己服务器中生成 SSL 证书的 csr ，<strong>记住生成输入的秘密</strong>，之后要用到：</p><pre><code>openssl req -newkey rsa:2048 -keyout weizhimiao.cn.key -out weizhimiao.cn.csr</code></pre><p>将生成的证书，放到指定的存放证书的目录，如 <code>/data/secret/</code> 。查看证书 <code>weizhimiao.csr</code> 内容，将内容复制到页面中的 Certificate Signing Request (CSR)部分，提交页面。</p><p>下载生成好的证书,选择对应的web服务器（Nginx，1_weizhimiao.cn_bundle.crt），这样私钥和公钥我们就都有了。</p><ul><li>1_weizhimiao.cn_bundle.crt（公钥）</li><li>weizhimiao.cn.key（私钥）</li></ul><h2 id="nginx配置（为指定域名增加https）"><a href="#nginx配置（为指定域名增加https）" class="headerlink" title="nginx配置（为指定域名增加https）"></a>nginx配置（为指定域名增加https）</h2><p>nginx.conf当前配置</p><pre><code>...http &#123;    ...    include /etc/nginx/conf.d/*.conf;    server &#123;        ...    &#125;&#125;</code></pre><p>./conf.d/weizhimiao.cn.conf中加入</p><pre><code>server&#123;    listen 443 ssl;    server_name weizhimiao.cn;    ssl_certificate /data/secret/1_weizhimiao.cn_bundle.crt;    ssl_certificate_key /data/secret/weizhimiao.cn.key;    ssl_prefer_server_ciphers on;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers &#39;kEECDH+ECDSA+AES128 kEECDH+ECDSA+AES256 kEECDH+AES128 kEECDH+AES256 kEDH+AES128 kEDH+AES256 DES-CBC3-SHA +SHA !aNULL !eNULL !LOW !MD5 !EXP !DSS !PSK !SRP !kECDH !CAMELLIA !RC4 !SEED&#39;;    add_header Strict-Transport-Security &#39;max-age=31536000; preload&#39;;    add_header X-Frame-Options DENY;    ssl_session_cache   shared:SSL:10m;    ssl_session_timeout 10m;    keepalive_timeout 70;    ssl_dhparam /data/secret/dhparam.pem;    add_header X-Content-Type-Options nosniff;    add_header X-Xss-Protection 1;    root /data/www/weizhimiao.cn;    index index.html;    location / &#123;    &#125;&#125;</code></pre><p><strong>注：</strong><br>配置中用到一个 <code>/data/secret/dhparam.pem</code> 文件，该文件是一个PEM格式的密钥文件，用于TLS会话中。用来加强ssl的安全性。生成该文件方法，</p><pre><code>cd /data/secret/openssl dhparam 2048 -out dhparam.pem</code></pre><p>将原来80端口的访问，重定向。./conf.d/weizhimiao.cn.conf中加入</p><pre><code>server&#123;    listen 80;    server_name  weizhimiao.cn;    return 301 https://weizhimiao.cn$request_uri;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>检测配置文件是否有语法错误，需要输入之前生成公钥时输入的密码。</p><pre><code>nginx -tEnter PEM pass phrase:nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>重启Nginx(切记，reload不起作用)</p><pre><code>nginx -s stopEnter PEM pass phrase:nginxEnter PEM pass phrase:</code></pre><p>浏览器访问 weizhimiao.cn ,是否生效。</p><p>另，Nginx配置了安全证书之后，nginx每次的reload、stop等操作都需要输入密码。<br>可以通过生成一个解密的key文件，替代原来key文件。</p><pre><code>cd /data/secret/openssl rsa -in weizhimiao.cn.key -out weizhimiao.cn.key.unsecure</code></pre><p>替换 <code>weizhimiao.cn.conf</code> 中的 <code>weizhimiao.cn.key</code> 文件.</p><pre><code>server &#123;  ...  ssl_certificate /data/secret/1_weizhimiao.cn_bundle.crt;  ssl_certificate_key /data/secret/weizhimiao.cn.key.unsecure;  ...&#125;</code></pre><p>之后每次在reload时，就不需要在输入密码了。</p><p>最后，用 <a href="https://www.ssllabs.com/ssltest/index.html">SSLLABS</a> 来进行一下测试。<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161004/ssllabs.png" alt="ssllabs"><br>结果<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161004/ssllabsres.png" alt="ssllabs"></p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161004/https.png&quot; alt=&quot;Nginx服务器https配置&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://weizhimiao.github.io/categories/Nginx/"/>
    
    
    <category term="https" scheme="https://weizhimiao.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Nginx虚拟主机配置</title>
    <link href="https://weizhimiao.github.io/2016/10/04/Nginx%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/10/04/Nginx%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE/</id>
    <published>2016-10-04T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20161004/VirtualHost.png" alt="virtual Host"></p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Linux：Linux version 3.10.0-123.9.3.el7.x86_64</p><p>Nginx: nginx/1.6.3</p><p>配置文件目录结构</p><pre><code>$ tree.├── conf.d├── default.d├── fastcgi.conf├── fastcgi.conf.default├── fastcgi_params├── fastcgi_params.default├── koi-utf├── koi-win├── mime.types├── mime.types.default├── nginx.conf├── nginx.conf.default├── scgi_params├── scgi_params.default├── uwsgi_params├── uwsgi_params.default└── win-utf</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>将 site1.cn 和site2.cn基于域名进行配置</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>分别创建两个域名的配置文件和web根目录。</p><p>./conf.d/下</p><pre><code>cd conf.d/touch site1.cn.conftouch site2.cn.conf</code></pre><p>分别创建web根目录</p><pre><code>mkdri -p /data/wwwcd  /data/wwwmkdir site1.cnmkdir site2.cn</code></pre><h3 id="修改主配置文件nginx-conf"><a href="#修改主配置文件nginx-conf" class="headerlink" title="修改主配置文件nginx.conf"></a>修改主配置文件nginx.conf</h3><pre><code>user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123;    worker_connections 1024;&#125;http &#123;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;    types_hash_max_size 2048;    include             /etc/nginx/mime.types;    default_type        application/octet-stream;    # Load modular configuration files from the /etc/nginx/conf.d directory.    # See http://nginx.org/en/docs/ngx_core_module.html#include    # for more information.    include /etc/nginx/conf.d/*.conf;    server &#123;        listen       80 default_server;        listen       [::]:80 default_server;        server_name  _;        root         /usr/share/nginx/html;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        location / &#123;        &#125;        error_page 404 /404.html;            location = /40x.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;            location = /50x.html &#123;        &#125;    &#125;&#125;</code></pre><p>确保在http的context中的server部分前面要有</p><pre><code>include /etc/nginx/conf.d/*.conf;</code></pre><p>通常情况下主配置文件中的server部分，将会是默认的server（通过添加default_server来声明），当一个请求过来，目录/etc/nginx/conf.d/中的所有server部分都匹配不了，那么这个请求将会被猪配置文件中的server来进行处理.</p><h3 id="site1-cn"><a href="#site1-cn" class="headerlink" title="site1.cn"></a>site1.cn</h3><p>修改配置文件</p><pre><code>vi ./conf.d/site1.cn.conf</code></pre><pre><code>server &#123;    listen        80;    server_name    site1.cn;    error_page  404  /404.html;    error_page   500 503 504  /50x.html;    error_log    /var/log/nginx/debug.log debug;    index    index.html index.htm;    root /data/www/site1.cn;    location / &#123;        index index.html;    &#125;  location = /favicon.ico &#123;      try_files $uri $uri/favicon.ico /data/www/site1.cn/favicon.ico =404;  &#125;  # Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store(Mac).  location ~ /\. &#123;      deny all;  &#125;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    location = /404.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;</code></pre><p>添加测试页面</p><pre><code>cd /data/www/site1.cnecho &quot;site1.cn index.html&quot; &gt;&gt; index.html</code></pre><h3 id="site2-cn"><a href="#site2-cn" class="headerlink" title="site2.cn"></a>site2.cn</h3><p>修改配置文件</p><pre><code>vi ./conf.d/site2.cn.conf</code></pre><pre><code>server &#123;    listen        80;    server_name    site2.cn;    error_page  404  /404.html;    error_page   500 503 504  /50x.html;    error_log    /var/log/nginx/debug.log debug;    index    index.html index.htm;    root /data/www/site2.cn;    location / &#123;        index index.html;    &#125;  location = /favicon.ico &#123;      try_files $uri $uri/favicon.ico /data/www/site2.cn/favicon.ico =404;  &#125;  # Deny all attempts to access hidden files such as .htaccess, .htpasswd, .DS_Store(Mac).  location ~ /\. &#123;      deny all;  &#125;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    location = /404.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;</code></pre><p>添加测试页面</p><pre><code>cd /data/www/site2.cnecho &quot;site2.cn index.html&quot; &gt;&gt; index.html</code></pre><h3 id="重启Nginx"><a href="#重启Nginx" class="headerlink" title="重启Nginx"></a>重启Nginx</h3><p>重启之前，需要先进行配置文件语法检测</p><pre><code>nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><p>确定语法无问题之后，重启Nginx</p><pre><code>nginx -s reload</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>vi /etc/hosts<br>添加</p><pre><code>site1.cn 127.0.0.1site2.cn 127.0.0.1</code></pre><p>分别访问 site1.cn和site2.cn ,查看是否输出对应内容</p><pre><code>wget  site1.cncat index.html#site1.cn index.htmlwget site2.cncat index.html.2#site2.cn index.html</code></pre><p>关于nginx学习的一个网站:<a href="http://nglua.com/">http://nglua.com</a></p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20161004/VirtualHost.png&quot; alt=&quot;virtual Host&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://weizhimiao.github.io/categories/Nginx/"/>
    
    
    <category term="虚拟主机" scheme="https://weizhimiao.github.io/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置整理</title>
    <link href="https://weizhimiao.github.io/2016/10/03/Nginx%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/10/03/Nginx%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/</id>
    <published>2016-10-03T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx配置主要分成四部分：main、server、upstream 和 location，每部分包含若干个指令。<br>main(全局设置)</p><blockquote><p>该部分设置的指令将影响其它所有部分的设置；</p></blockquote><p>server(主机设置)</p><blockquote><p>该部分的指令主要用于指定虚拟主机域名、IP和端口；</p></blockquote><p>upstream(上游服务器设置)</p><blockquote><p>该部分的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；</p></blockquote><p>location(URL匹配特定位置后的设置)</p><blockquote><p>该部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。</p></blockquote><p>Nginx本身是模块化设计。全局的配置区段负责全局的各个方面，对于不同的协议可以单独划分成一个部分。我们可以通过在这些单独的协议配置中（http或mail）指定server来定义每一个请求应该被如何处理，以便请求被路由到特定的IP地址或端口上。在http区段中，使用location来匹配URI请求，这些location又可以嵌套使用或者按照一定顺序使用，以确保请求被路由到正确的文件系统区域或者其他地方。</p><p><strong>他们之间的关系式：</strong> server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。</p><span id="more"></span><h2 id="基本配置格式"><a href="#基本配置格式" class="headerlink" title="基本配置格式"></a>基本配置格式</h2><p>Nginx的配置文件由若干部分组成。但每一部分都是通过下列的方法定义。</p><pre class="line-numbers language-conf"><code class="language-conf"><section> &#123;  <directive><parameters>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Tips:</strong></p><ul><li>每一个指令行都由分号结束（;），这标志着一行结束。</li><li>大括号（{}）实际上表示一个新上下文（context），常称为『节，部分（section）』</li></ul><h2 id="Nginx的全局配置"><a href="#Nginx的全局配置" class="headerlink" title="Nginx的全局配置"></a>Nginx的全局配置</h2><p>全局配置顾名思义就是对整个server都有效的参数。全局配置部分可能包含配置指令（如，user、worker_processes），也包括『节、部分（section）（如，events）』。这部分配置一般放在 nginx.conf 文件的顶部。</p><p>示例：</p><pre><code>user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123;    use epoll   #使用网络IO模型，epoll模型比select模型效率高很多    worker_connections 1024;    #每个worker能够处理的最大连接数，最大值取决于ulimit -n的值&#125;</code></pre><p>主要配置指令及含义</p><table><thead><tr><th>配置指令</th><th>说明</th></tr></thead><tbody><tr><td>user</td><td>配置worker进程运行的用户和用户组，第一个参数为user，第二个为group（如果忽略了group，那么group与user同名）</td></tr><tr><td>worker_processes</td><td>指定worker进程启动的数量。这些进程用于处理客户的连接。通常该值会设置成CPU处理器核心数相同的数量。默认值是”auto”，也是按照这样去设置数量</td></tr><tr><td>error_log</td><td>设置错误日志文件位置。如果在其他的区段中没有设置其他的error_log,那么这个日志文件将会记录所有的错误。该指令的第二个参数指定了被记录的错误信息级别（debug[注，debug级别的错误只有在nginx编译的时候配置了 –with-debug选项才可以使用]、info、notice、warn、error、crit、alert、emsg）</td></tr><tr><td>pid</td><td>设置记录主进程ID的文件地址。通常设置该值来方便我们对nginx的管理</td></tr><tr><td>use</td><td>该指令指示我们使用什么样的连接方式。该指令需要写在 events 区段里面。</td></tr><tr><td>worker_connections</td><td>配置一个工作进程能够接受并发连接的最大数。这个连接包括，客户连接和向上游服务器的连接，但也不仅限于此。通常该配置同use一样写在events里面</td></tr></tbody></table><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>在Nginx配置文件中可以使用include指令将其他位置存放的配置文件加载进来，来方便配置管理和增强配置文件的可读性。</p><p><strong>Tips：</strong><br>使用include文件，要确保被包含的文件自身符合nginx配置语法。</p><pre><code>include /etc/nginx/default.d/*.conf;</code></pre><p>路径中出现通配符表示可以匹配多个文件。<br>nginx配置文件的语法错误可以通过nginx的 -t 选项来进行测试。</p><pre><code>/path/to/nginx -t -c &lt;path-to-nginx.conf&gt;</code></pre><p><strong>注：</strong> 该命令只能检查语法错误，具体到某个功能性的测试还需要我们自己有针对性的去测。</p><h2 id="Http的server部分"><a href="#Http的server部分" class="headerlink" title="Http的server部分"></a>Http的server部分</h2><p>通常我们提到的server部分，具体指的是Http的server部分。所以，其在Http配置的context是可用的。该部分用于处理http连接，因此该模块下提供了相当数量的指令。</p><h3 id="客户端指令"><a href="#客户端指令" class="headerlink" title="客户端指令"></a>客户端指令</h3><blockquote><p>用于处理客户端连接本身的各个方面，以及不同类型的客户端</p></blockquote><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>chunked_transfer_encoding</td><td>在发给客户端的响应中允许禁用http/1.1标准的块传输编码</td></tr><tr><td>client_body_buffer_size</td><td>为了阻止临时文件写到磁盘，可以通过该指令为客户端请求体设置缓存大小，默认的缓存大小为两个内存页面</td></tr><tr><td>client_body_in_file_only</td><td>用于调试或者是进一步处理客户端请求体。该指令能够将客户端请求体强制写入到磁盘文件</td></tr><tr><td>client_body_in_single_buffer</td><td>为了减少拷贝的操作，使用该指令强制Nginx将整个客户端请求体保存到单个缓存中</td></tr><tr><td>client_body_temp_path</td><td>定义一个命令路径用于保存客户端请求体</td></tr><tr><td>clent_body_timeout</td><td>指定客户端成功读取的两个操作之间的时间间隔</td></tr><tr><td>client_header_buffer_size</td><td>为客户端请求头指定一个缓存大小，当请求头大于1kB时会用到这个设置。</td></tr><tr><td>client_header_timeout</td><td>读取整个客户端头的超时时间</td></tr><tr><td>client_max_body_size</td><td>定义允许最大的客户端请求头，如果大于该值，那么客户端将会是413（request entity too large）错误</td></tr><tr><td>keepalive_disable</td><td>对某些类型的客户端禁用keep-alive请求功能。</td></tr><tr><td>keepalive_requests</td><td>定义在一个keep-alive关闭之前可以接收多少个请求</td></tr><tr><td>keepalive_timeout</td><td>指定keep-alive连接持续多久。第二个参数用于在响应头中这只”Keep-Alive”头</td></tr><tr><td>large_client_header_buffers</td><td>定义最大数量和最大客户端请求头的大小</td></tr><tr><td>msie_padding</td><td>为了填充响应的大小至512字节，对于MSIE客户端，大于400的状态码会被添加注释以便满足512字节，通过启用该命令可以阻止这种行为</td></tr><tr><td>msie_refresh</td><td>对于MSIE客户端，可启用发送一个refresh头</td></tr></tbody></table><h3 id="文件I-O指令"><a href="#文件I-O指令" class="headerlink" title="文件I/O指令"></a>文件I/O指令</h3><blockquote><p>用于控制Nginx如何投递静态文件。</p></blockquote><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>aio</td><td>启用异步文件I/O。FreeBSD系统下，该值可能被用于sendfile预加载数据。Linux下需要directio指令，自动禁用sendfile</td></tr><tr><td>directio</td><td>用于启用操作系统特定的标识或者功能提供大于给定参数的文件。Linux下使用aio时需要使用该指令。</td></tr><tr><td>directio_alignment</td><td>设置directio算法。默认值是512，通常已经足够，但是在Linux的XFS下推荐增加至4K</td></tr><tr><td>open_file_cache</td><td>配置一个缓存用于存放打开的文件描述符、目录查询和文件查询错误</td></tr><tr><td>open_file_cache_errors</td><td>按照open_file_cache，启用文件查询错误缓存</td></tr><tr><td>open_file_cache_min_uses</td><td>open_file_cache缓存的文件描述符保留在缓存中，使用该指令配置最少使用文件描述符的次数</td></tr><tr><td>open_file_cache_valid</td><td>指定对open_file_cache缓存有效性检查的时间间隔</td></tr><tr><td>postpone_output</td><td>指定Nginx发送给客户端最小的数值，如果可能的话，没有数据会发送，直到达到此值</td></tr><tr><td>read_ahead</td><td>如果可能的话，内核将预读文件到设定的参数大小</td></tr><tr><td>sendfile</td><td>使用sendfile（2）直接复制数据从一个到另一个文件描述符</td></tr><tr><td>sendfile_max_chunk</td><td>设置在一个sendfile(2)拷贝中最大数据的大小，这是为了阻止worker”贪婪”</td></tr></tbody></table><h3 id="Hash指令"><a href="#Hash指令" class="headerlink" title="Hash指令"></a>Hash指令</h3><blockquote><p>控制Nginx 分配给某些变量多大的静态文件</p></blockquote><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>server_names_hash_bucket_size</td><td>指定用于保存server_name哈希表大小的”桶”</td></tr><tr><td>server_names_hash_max_size</td><td>指定的server_name哈希表的最大值的大小</td></tr><tr><td>types_hash_bucket_size</td><td>指定用于存放哈希表的”桶”的大小</td></tr><tr><td>types_hash_max_size</td><td>指定哈希类型表的最大值的大小</td></tr><tr><td>variables_hash_bucket_size</td><td>指定用于存放保留变量”桶”的大小</td></tr><tr><td>variables_hash_max_size</td><td>指定存放保留变量最大哈希值的大小</td></tr></tbody></table><h3 id="Socket指令"><a href="#Socket指令" class="headerlink" title="Socket指令"></a>Socket指令</h3><blockquote><p>描述Nginx如何设置创建TCP套接字的变量选项</p></blockquote><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>lingering_close</td><td>指定如何保持客户端的连接，以便用于更多数据的传输</td></tr><tr><td>lingering_time</td><td>在使用lingering_close指令的连接中，使用该指令指定客户端连接为了处理更多的数据需要保持打开连接的时间</td></tr><tr><td>lingering_timeout</td><td>结合lingering_close，该指令显示Nginx在关闭客户端连接之前，为获得更多数据会等待多久</td></tr><tr><td>reset_timeout_connection</td><td>使用这个指令之后，超时的连接会被立即关闭，释放相关的内存。默认的状态是处于FIN_WAIT1，这种状态将会一直保持连接</td></tr><tr><td>send_lowat</td><td>如果非零，Nginx将会在客户端套接字尝试减少发送操作</td></tr><tr><td>send_timeout</td><td>在两次成功的客户端接收响应的写操作之间设置一个超时时间</td></tr><tr><td>tcp_nodelay</td><td>启用或禁用TCP_NODELAY选项，用于keep-alive连接</td></tr><tr><td>tcp_nopush</td><td>仅依赖于sendfile的使用。它能够使Nginx在一个数据包中尝试发送响应头，以及在数据包中发送一个完整的文件</td></tr></tbody></table><h3 id="server部分"><a href="#server部分" class="headerlink" title="server部分"></a>server部分</h3><p>示例：</p><pre><code>http &#123;    ...    server &#123;        listen       80 default_server;        server_name  _;        root         /usr/share/nginx/html;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        location / &#123;        &#125;        error_page 404 /404.html;            location = /40x.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;            location = /50x.html &#123;        &#125;    &#125;    ...&#125;</code></pre><p>一个虚拟服务器由listen和server_name指令组合定义。</p><p><strong>listen</strong></p><blockquote><p>指令定义一个IP地址/端口组合或者UNIX套接字路径。示例</p><ul><li>listen address[:port];</li><li>listen port;</li><li>listen unix:path;</li></ul></blockquote><p>示例：</p><pre><code>listen     127.0.0.1:80;listen     localhost:80;listen     127.0.0.1:8080;listen     localhost:8080;listen     192.168.3.105:80;listen     192.168.3.105:8080;listen     80;listen     *:80;listen     8080;listen     *:8080;listen     12.34.56.77:80;listen     12.34.56.78:80;listen     12.34.56.79:80;</code></pre><p>另外，listen还有其他的一些可选参数。常用到的有<br>default_server，表示定义这样的一个组合：（address:port）默认的请求被绑定于此<br>ssl，表明该端口仅接受Https的连接</p><p><strong>server_name</strong></p><blockquote><p>用来指定域名。</p></blockquote><p>示例：</p><pre><code>server_name   nginx.cn;server_name   nginx.cn www.nginx.cn;server_name   *.nginx.cn;server_name   .nginx.cn;server_name   nginx.*;server_name   nginx.cng bucknell.net brackley.org;server_name   localhost litchfield bleddington;server_name   &quot;&quot;;</code></pre><p>除了普通字符串外，Nginx也接受通配符作为Server_name的参数。</p><ul><li>使用通配符替代部分子域名： *.example.com</li><li>代替顶级域部分： <a href="http://www.example/">www.example</a>.*</li><li>匹配子域和域本身： .example.com 能匹配 *.example.com 和example.com</li></ul><p>另外，在域名前加上（~），正则表达式也可应用于 server_name.</p><pre><code>server_name ~^www\.example\.com$server_name ~^www(\d+).example\.(com)$</code></pre><p>对于后一种方式是利用捕获，可以在以后的引用中进一步配置（用$1,$2等）指令中使用。</p><h2 id="location部分"><a href="#location部分" class="headerlink" title="location部分"></a>location部分</h2><p>location指令可以用在虚拟服务器server部分，并且意味着提供来自客户端的URI或者内部的重定向访问。</p><p>location定义：</p><pre><code>location [modifier] uri &#123;...&#125;</code></pre><p>或者是命名location</p><pre><code>location @name &#123;...&#125;</code></pre><blockquote><p>命名location仅对内部访问重定向，在进入一个location之前他会保留被请求的URI部分。且命名location只能存在与server级别的定义。</p></blockquote><p>示例</p><pre><code>location / &#123; &#125;location /images/ &#123; &#125;location /blog/ &#123; &#125;location /planet/ &#123; &#125;location /planet/blog/ &#123; &#125;location ~ IndexPage.php$ &#123; &#125;location ~ ^/BlogPlanet(/|/index.php)$ &#123; &#125;location ~* .(pl|cgi|perl|prl)$ &#123; &#125;location ~* .(md|mdwn|txt|mkdn)$ &#123; &#125;location ^~ /images/IndexPage/ &#123; &#125;location ^~ /blog/BlogPlanet/ &#123; &#125;location = / &#123; &#125;</code></pre><p>当一个请求进入时，URI将会被检测匹配一个最佳的location。</p><ul><li>没有正则表达式的location被认为是最佳的匹配，独立于含有正则表达式的location。</li><li>在配置文件中按照查找顺序进行正则匹配，在查到第一个正则表达式匹配时结束查找，将请求交由这个location处理。</li></ul><p><strong>Tips：</strong><br>这里匹配的解码URI，如在URL中的”%20”,将会匹配location中的””(空格)。</p><p>location常见的修饰符</p><table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>使用精确匹配并且终止搜索</td></tr><tr><td>~</td><td>区分大小写的正则表达式匹配</td></tr><tr><td>~*</td><td>不去分大小写的正则表达式匹配</td></tr><tr><td>^~</td><td>如果该location是最佳的匹配，那么对于匹配这个location的字符串不在进行正则表达式检测。</td></tr></tbody></table><p>仅用于location中的指令</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>alias</td><td>定义location的其他名字，在文件系统中能够找到。</td></tr><tr><td>internal</td><td>指定一个仅用于内部请求的location（其他指定定义的重定向，rewrite请求，error请求等）</td></tr><tr><td>limit_except</td><td>限定一个location可以执行的Http操作（如，GET或HEAD）</td></tr></tbody></table><p>命名location的使用（一般与try_files配合使用）<br>示例：</p><pre><code>location / &#123;  try_files $uri $uri/ $mongrel;&#125;location @mongrel &#123;  proxy_pass http://appserver;&#125;</code></pre><p>上面一段配置表示，如果给定的URI作为一个文件没有被找到，那么处理将会通过代理被传递到appserver</p><p>location的嵌套使用：</p><pre><code>root /var/wwwlocation / &#123;  location ^~ /css &#123;    location ~* /css.*\.css$ &#123;      ...    &#125;    ...  &#125;  ...&#125;</code></pre><p><strong>实践表明正则表达式location被嵌套在基于字符串的location是最佳的配置方式</strong></p><h2 id="完整的配置文件示例"><a href="#完整的配置文件示例" class="headerlink" title="完整的配置文件示例"></a>完整的配置文件示例</h2><pre><code># For more information on configuration, see:#   * Official English Documentation: http://nginx.org/en/docs/#   * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123;    worker_connections 1024;&#125;http &#123;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile            on;    tcp_nopush          on;    tcp_nodelay         on;    keepalive_timeout   65;    types_hash_max_size 2048;    include             /etc/nginx/mime.types;    default_type        application/octet-stream;    # Load modular configuration files from the /etc/nginx/conf.d directory.    # See http://nginx.org/en/docs/ngx_core_module.html#include    # for more information.    include /etc/nginx/conf.d/*.conf;    server &#123;        listen       80 default_server;        listen       [::]:80 default_server;        server_name  _;        root         /usr/share/nginx/html;        # Load configuration files for the default server block.        include /etc/nginx/default.d/*.conf;        location / &#123;        &#125;        error_page 404 /404.html;            location = /40x.html &#123;        &#125;        error_page 500 502 503 504 /50x.html;            location = /50x.html &#123;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx配置主要分成四部分：main、server、upstream 和 location，每部分包含若干个指令。&lt;br&gt;main(全局设置)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该部分设置的指令将影响其它所有部分的设置；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;server(主机设置)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该部分的指令主要用于指定虚拟主机域名、IP和端口；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;upstream(上游服务器设置)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该部分的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;location(URL匹配特定位置后的设置)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx本身是模块化设计。全局的配置区段负责全局的各个方面，对于不同的协议可以单独划分成一个部分。我们可以通过在这些单独的协议配置中（http或mail）指定server来定义每一个请求应该被如何处理，以便请求被路由到特定的IP地址或端口上。在http区段中，使用location来匹配URI请求，这些location又可以嵌套使用或者按照一定顺序使用，以确保请求被路由到正确的文件系统区域或者其他地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;他们之间的关系式：&lt;/strong&gt; server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://weizhimiao.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Memcached分布式部署算法整理</title>
    <link href="https://weizhimiao.github.io/2016/10/01/Memcached%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/10/01/Memcached%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2016-10-01T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>虽然memcached是一个高性能的缓存服务器，但是单台服务器对于目前大型的web应用来说还是满足不了需求的。那么就需要布置多台的memcached服务器进行分布式部署。那么一个数据应该存储到哪一台服务器就需要一个分布算法来确定。</p><p>常见的分布方案有两种，</p><blockquote><ul><li>普通Hash分布</li><li>一致性Hash分布</li></ul></blockquote><span id="more"></span><h2 id="普通Hash分布"><a href="#普通Hash分布" class="headerlink" title="普通Hash分布"></a>普通Hash分布</h2><blockquote><p>俗称哈希取模法，优点是实现简单，但缺点是缺乏灵活性（比如增加一台服务器，那么之前存储的数据的键值和具体的物理机之间的关系就被完全打乱了，即之前存储的数据就完全失效了）。</p></blockquote><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>H(key) = hash(key)mod K;</p><blockquote><p>假设有K台物理机，对于key为键值的记录，H(key)值即为存储数据的物理机编号。通过这种方式，就将全部数据分配到K台物理机上，而查找某条记录时，使用同样的Hash函数就可以找到对应的物理机。</p></blockquote><h3 id="实现-PHP-："><a href="#实现-PHP-：" class="headerlink" title="实现(PHP)："></a>实现(PHP)：</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$servers</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>    <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"host"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"192.168.1.1"</span><span class="token punctuation">,</span><span class="token string">"port"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"11211"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">"host"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"192.168.1.2"</span><span class="token punctuation">,</span><span class="token string">"port"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"11211"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token string">"userDatakey"</span><span class="token punctuation">;</span>  <span class="token variable">$value</span> <span class="token operator">=</span> <span class="token string">"userDataValue"</span><span class="token punctuation">;</span>  <span class="token variable">$mc_ser</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token variable">$servers</span><span class="token punctuation">[</span><span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token variable">$mc</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Memcache</span><span class="token punctuation">(</span><span class="token variable">$servers</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [mhash 首先通过md5把key处理成一个32位的字符串，取其前8个字符。在经过hash算法处理成一个整数并返回。]   * @param  &amp;#123;[type]&amp;#125; $key [description]   * @return &amp;#123;[type]&amp;#125;      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$md5</span> <span class="token operator">=</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$seed</span> <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>    <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token variable">$hash</span><span class="token operator">*</span><span class="token variable">$seed</span> <span class="token operator">+</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$md5</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;$i&amp;#125;);</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$hash</span> <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过Hash函数把key转化成整数后，利用这个整数与服务器数量取模，得到其中一台的服务器配置。然后利用这个配置完成memcached服务器的连接操作。这样就完成了对数据的分布式存储。</p><h2 id="一致性Hash分布"><a href="#一致性Hash分布" class="headerlink" title="一致性Hash分布"></a>一致性Hash分布</h2><blockquote><p>一致性hash分布是算法，是P2P网络和分布式存储中常用到一项技术。是一种当服务器有增删时，对数据影响最小的一种部署方案。</p></blockquote><p>一致性Hash算法实现：</p><h3 id="将一个32位整数（0-2-32-1）想象成一个闭环。"><a href="#将一个32位整数（0-2-32-1）想象成一个闭环。" class="headerlink" title="将一个32位整数（0~2^32-1）想象成一个闭环。"></a>将一个32位整数（0~2^32-1）想象成一个闭环。</h3><p>如图，<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_1.png" alt="将32位整数想象成一个闭环"></p><h3 id="通过Hash函数将key处理成整数"><a href="#通过Hash函数将key处理成整数" class="headerlink" title="通过Hash函数将key处理成整数"></a>通过Hash函数将key处理成整数</h3><pre><code>$key1 = mhash(&quot;key1&quot;);$key2 = mhash(&quot;key2&quot;);$key3 = mhash(&quot;key3&quot;);$key4 = mhash(&quot;key4&quot;);</code></pre><p>将key通过mhash函数处理成整数，让后就可以将之对应到闭环上。如图，<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_2.png" alt="4个key通过mhash处理成整数对应到闭环上"></p><h3 id="将memcached服务器，通过hash服务器所使用的IP地址，也对应到闭环上。"><a href="#将memcached服务器，通过hash服务器所使用的IP地址，也对应到闭环上。" class="headerlink" title="将memcached服务器，通过hash服务器所使用的IP地址，也对应到闭环上。"></a>将memcached服务器，通过hash服务器所使用的IP地址，也对应到闭环上。</h3><p>例如，有三台服务器，IP分别是192.168.1.1、192.168.1.2、192.168.1.3</p><pre><code>$server1 = mhash(&quot;192.168.1.1&quot;);$server2 = mhash(&quot;192.168.1.2&quot;);$server3 = mhash(&quot;192.168.1.3&quot;);</code></pre><p>如图，<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_server.png" alt="将服务器也映射到环上"></p><h3 id="把数据映射到服务器上"><a href="#把数据映射到服务器上" class="headerlink" title="把数据映射到服务器上"></a>把数据映射到服务器上</h3><p><strong>映射方法：</strong><br>沿着圆环的顺时针方向的key出发，直到遇上一个服务器，将key对应的数据存储到这个服务器上。</p><p>如图，<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_3.png" alt="把数据映射到服务器上"></p><h3 id="移除服务器"><a href="#移除服务器" class="headerlink" title="移除服务器"></a>移除服务器</h3><p>假设服务器 server2 崩溃了，那么受影响的仅是哪些hash映射值在server1到server2的值。</p><p>如图，受影响的只有key2，它将会重新映射到server3服务器上。<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_4.png" alt="移除服务器"></p><h3 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h3><p>如果现在需要新添加一台服务器，其IP地址为（192.168.1.4）</p><pre><code>$server4 = mhash(&quot;192.168.1.4&quot;);</code></pre><p>其在闭环上的映射位置位于如图的位置，那么受影响是hash映射值在其当前的位置和server2的位置之间的key。</p><p>如图，受影响的仅为key3，其将会重新映射到server4上。<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20161001/hash_5.png" alt="添加服务器"></p><h3 id="实现（PHP）"><a href="#实现（PHP）" class="headerlink" title="实现（PHP）"></a>实现（PHP）</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">FlexiHash</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token keyword">private</span> <span class="token variable">$serverList</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token variable">$isSorted</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * [addServer 通过hash函数计算除服务器的Hash值，通过此hash值定位服务器列表的某个位置，然后将服务器排序标识置为false]   * @param &amp;#123;[type]&amp;#125; $server [description]   */</span>  <span class="token keyword">function</span> <span class="token function">addServer</span><span class="token punctuation">(</span><span class="token variable">$server</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$server</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">[</span><span class="token variable">$hash</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">[</span><span class="token variable">$hash</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$server</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">isSorted</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * [removeServer 跟addServer实现差不多，将server删除，并将排序标识置为false]   * @param  &amp;#123;[type]&amp;#125; $server [description]   * @return &amp;#123;[type]&amp;#125;         [description]   */</span>  <span class="token keyword">function</span> <span class="token function">removeServer</span><span class="token punctuation">(</span><span class="token variable">$server</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$server</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">[</span><span class="token variable">$hash</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">[</span><span class="token variable">$hash</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">isSorted</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * [lookup 先计算除key的hash值，然后判断serverList是排序过，如果没有，就先对服务器列表进行倒序排序操作。倒序排序的作用是把服务器列表转换成一个逆时针的圆环。然后遍历服务器列表，找到一个合适的服务器返回]   * @param  &amp;#123;[type]&amp;#125; $key [description]   * @return &amp;#123;[type]&amp;#125;      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">isSorted</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token function">ksort</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">,</span> <span class="token constant">SORT_NUMERIC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">isSorted</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span> <span class="token keyword">as</span> <span class="token variable">$pos</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$server</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$hash</span> <span class="token operator">>=</span> <span class="token variable">$pos</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">return</span> <span class="token variable">$server</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">[</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">serverList</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">/**   * [mhash 首先通过md5把key处理成一个32位的字符串，取其前8个字符。在经过hash算法处理成一个整数并返回。]   * @param  &amp;#123;[type]&amp;#125; $key [description]   * @return &amp;#123;[type]&amp;#125;      [description]   */</span>  <span class="token keyword">function</span> <span class="token function">mhash</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$md5</span> <span class="token operator">=</span> <span class="token function">substr</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$seed</span> <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>    <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token variable">$hash</span> <span class="token operator">=</span> <span class="token variable">$hash</span><span class="token operator">*</span><span class="token variable">$seed</span> <span class="token operator">+</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$md5</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;$i&amp;#125;);</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">return</span> <span class="token variable">$hash</span> <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token variable">$hserver</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlexiHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key1 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key2 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> "<span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">=</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">removeServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key1 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key2 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> "<span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">=</span><span class="token punctuation">;</span>  <span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">"192.168.1.6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key1 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"save key2 in server:"</span><span class="token punctuation">.</span><span class="token variable">$hserver</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> "<span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">=</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过测试结果可以看出，在增加或者减少memcached服务器的时候，一致性hash算法只会改变很少的一部分数据的存储服务器，从而能够实现最大限度的减少数据丢失的情况。</p><h2 id="实际应用（PHP）"><a href="#实际应用（PHP）" class="headerlink" title="实际应用（PHP）"></a>实际应用（PHP）</h2><p>在实际应用当中，PHP提供了两种的关于Memcached的扩展，memcache和memcached。两种扩展中都可以设置采用哪种分布方式，我们只需要选择我们要采用的策略并修改配置即可，而不需要我们自己来实现具体的分布算法。</p><p><strong>memcache扩展配置</strong></p><p>控制key到服务器的映射（分布式）策略。 php.ini 配置</p><pre class="line-numbers language-ini"><code class="language-ini"><span class="token selector">[Memcache]</span><span class="token constant">Memcache.allow_failover</span> <span class="token attr-value"><span class="token punctuation">=</span> 1</span><span class="token constant">memcache.max_failover_attempts</span> <span class="token attr-value"><span class="token punctuation">=</span> 2</span><span class="token constant">Memcache.hash_strategy</span> <span class="token attr-value"><span class="token punctuation">=</span>consistent</span><span class="token constant">Memcache.hash_function</span> <span class="token attr-value"><span class="token punctuation">=</span>crc32</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Memcache.allow_failover</p><blockquote><p>是否在发生错误时（对用户）透明的转移到其他服务器。</p></blockquote><p>memcache.max_failover_attempts</p><blockquote><p>定义在写入和获取数据时最多尝试的服务器次数（即：故障转移最大尝试数），仅和 memcache.allow_failover结合使用。</p></blockquote><p>Memcache.hash_strategy</p><blockquote><p>控制key到服务器的映射（分布式）策略。</p></blockquote><ul><li>consistent，采用一致性hash分布策略实现映射</li><li>standard，采用普通hash分布策略实现映射</li></ul><p>memcache.hash_function</p><blockquote><p>控制在key-server映射时使用哪个hash函数crc32 标明使用标准CRC32进行hash，fnv则说明使用FNV-1a。</p></blockquote><p><strong>memcached扩展配置</strong></p><pre><code>&lt;?php  $mem = new memcached();  $mem-&gt;setOption(Memcached::OPT_DISTRIBUTION,Memcached::DISTRIBUTION_CONSISTENT);  $mem-&gt;setOption(Memcached::OPT_LIBKETAMA_COMPATIBLE,true);</code></pre><p>Memcached::OPT_DISTRIBUTION</p><blockquote><p>指定元素key分布到各个服务器的方法。当前支持的方法有余数分步法合一致性hash算法两种。一致性hash算法提供 了更好的分配策略并且在添加服务器到集群时可以最小化缓存丢失。<br>类型: integer, 默认: Memcached::DISTRIBUTION_MODULA.</p></blockquote><p>Memcached::DISTRIBUTION_MODULA</p><blockquote><p>余数分布算法。</p></blockquote><p>Memcached::DISTRIBUTION_CONSISTENT</p><blockquote><p>一致性分布算法(基于libketama).</p></blockquote><p>Memcached::OPT_LIBKETAMA_COMPATIBLE</p><blockquote><p>开启或关闭兼容的libketama类行为。当开启此选项后，元素key的hash算法将会被设置为md5并且分布算法将会 采用带有权重的一致性hash分布。这一点非常有用因为其他基于libketama的客户端（比如python，urby）在同样 的服务端配置下可以透明的访问key。</p><p><strong>Note:</strong><br>如果你要使用一致性hash算法强烈建议开启此选项，并且这个选项可能在未来的发布版中被设置为默认开启。<br>类型: boolean, 默认: FALSE.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然memcached是一个高性能的缓存服务器，但是单台服务器对于目前大型的web应用来说还是满足不了需求的。那么就需要布置多台的memcached服务器进行分布式部署。那么一个数据应该存储到哪一台服务器就需要一个分布算法来确定。&lt;/p&gt;
&lt;p&gt;常见的分布方案有两种，&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;普通Hash分布&lt;/li&gt;
&lt;li&gt;一致性Hash分布&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="分布式部署算法" scheme="https://weizhimiao.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP异常和错误处理</title>
    <link href="https://weizhimiao.github.io/2016/09/30/PHP%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/30/PHP%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2016-09-30T15:10:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>首先，需要明确以下这两个概念</p><ul><li><p>异常(exception)</p><blockquote><p>PHP中的异常，是程序运行中不符合预期的情况及与正常流程不同的状况。<br>是属于逻辑和业务流程的一种中断，而不是语法错误。</p></blockquote></li><li><p>错误(error)</p><blockquote><p>PHP中的错误则属于自身的问题，是一种非法的语法或者环境问题导致的、让编译器无法通过检查甚至无法运行的情况。</p></blockquote></li></ul><span id="more"></span><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>PHP中玉带任何自身问题都会触发一个错误，而不是抛出异常。所以，如果想使用异常处理来处理不可预知的问题，这是PHP办不到的。但在处理一些可以预知的错误，PHP的异常处理机制还是能够帮我们解决一些问题的。例如：</p><ul><li>代码冗余复杂，到处充斥着if…else</li><li>代码可读性差</li></ul><p>而异常处理，其主要作用是将『正常执行过程的代码』和『处理问题怎么处理的代码』进行分离。</p><h3 id="PHP常见的异常类"><a href="#PHP常见的异常类" class="headerlink" title="PHP常见的异常类"></a>PHP常见的异常类</h3><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><blockquote><p>所有异常的基类。</p></blockquote><p>类摘要</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  Exception <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">/* 属性 */</span>    <span class="token keyword">protected</span> string <span class="token variable">$message</span> <span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//异常消息内容</span>    <span class="token keyword">protected</span> int <span class="token variable">$code</span> <span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//异常代码</span>    <span class="token keyword">protected</span> string <span class="token variable">$file</span> <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//抛出异常的文件名</span>    <span class="token keyword">protected</span> int <span class="token variable">$line</span> <span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//抛出异常在该文件中的行号</span>    <span class="token comment" spellcheck="true">/* 方法 */</span>    <span class="token keyword">public</span> <span class="token function">__construct</span> <span class="token punctuation">(</span><span class="token punctuation">[</span> string <span class="token variable">$message</span> <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> int <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> Exception <span class="token variable">$previous</span> <span class="token operator">=</span> <span class="token keyword">NULL</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//异常构造函数</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> string <span class="token function">getMessage</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//获取异常消息内容</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> Exception <span class="token function">getPrevious</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回异常链中的前一个异常</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> int <span class="token function">getCode</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//获取异常代码</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> string <span class="token function">getFile</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//获取发生异常的程序文件名称</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> int <span class="token function">getLine</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//获取发生异常的代码在文件中的行号</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">array</span> <span class="token function">getTrace</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//获取异常追踪信息</span>    <span class="token keyword">final</span> <span class="token keyword">public</span> string <span class="token function">getTraceAsString</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取字符串类型的异常追踪信息</span>    <span class="token keyword">public</span> string <span class="token function">__toString</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//将异常对象转换为字符串</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> void <span class="token function">__clone</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//异常克隆</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="错误异常类"><a href="#错误异常类" class="headerlink" title="错误异常类"></a>错误异常类</h4><p>类摘要</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  ErrorException <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">/* 属性 */</span>      <span class="token keyword">protected</span> int <span class="token variable">$severity</span> <span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//异常级别</span>      <span class="token comment" spellcheck="true">/* 方法 */</span>      <span class="token keyword">public</span> <span class="token function">__construct</span> <span class="token punctuation">(</span><span class="token punctuation">[</span> string <span class="token variable">$message</span> <span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> int <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> int <span class="token variable">$severity</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> string <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token constant">__FILE__</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> int <span class="token variable">$lineno</span> <span class="token operator">=</span> <span class="token constant">__LINE__</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> Exception <span class="token variable">$previous</span> <span class="token operator">=</span> <span class="token keyword">NULL</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//异常构造函数</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> int <span class="token function">getSeverity</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">// 获取异常的严重程度</span>      <span class="token comment" spellcheck="true">/* 继承的方法 */</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> string Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getMessage</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> Exception Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getPrevious</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> int Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getCode</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> string Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFile</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> int Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getLine</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> <span class="token keyword">array</span> Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getTrace</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">public</span> string Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getTraceAsString</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">public</span> string Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">__toString</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>      <span class="token keyword">final</span> <span class="token keyword">private</span> void Exception<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">__clone</span> <span class="token punctuation">(</span> void <span class="token punctuation">)</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常见使用方式（使用set_error_handle()函数讲错误信息托管至ErrorException）</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">exception_error_handler</span><span class="token punctuation">(</span><span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token variable">$errfile</span><span class="token punctuation">,</span> <span class="token variable">$errline</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ErrorException</span><span class="token punctuation">(</span><span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errfile</span><span class="token punctuation">,</span> <span class="token variable">$errline</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token function">set_error_handler</span><span class="token punctuation">(</span><span class="token string">"exception_error_handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* Trigger exception 抛出异常 */</span><span class="token function">strpos</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">/** * 自定义一个异常处理类 */</span><span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">// 重定义构造器使 message 变为必须被指定的属性</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$message</span><span class="token punctuation">,</span> <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> Exception <span class="token variable">$previous</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">// 自定义的代码</span>        <span class="token comment" spellcheck="true">// 确保所有变量都被正确赋值</span>        <span class="token keyword">parent</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token variable">$message</span><span class="token punctuation">,</span> <span class="token variable">$code</span><span class="token punctuation">,</span> <span class="token variable">$previous</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token comment" spellcheck="true">// 自定义字符串输出的样式</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">return</span> <span class="token constant">__CLASS__</span> <span class="token punctuation">.</span> <span class="token string">": [&amp;#123;$this->code&amp;#125;]: &amp;#123;$this->message&amp;#125;\n"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">customFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token keyword">echo</span> <span class="token string">"A custom function for this type of exception\n"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PHP中异常用法"><a href="#PHP中异常用法" class="headerlink" title="PHP中异常用法"></a>PHP中异常用法</h3><blockquote></blockquote><p>首先我们需要知道，<em><strong>在PHP中只有手动抛出异常后才能捕获异常，对于抛出的异常只有进行捕获并作出相应的操作抛出异常才有意义，否则没有任何意义。</strong></em></p><p>抛出异常</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token variable">$n</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$n</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"参数错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><p>示例：关于上传操作的异常处理</p><p>方式一：异常发生时立即捕获</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">try</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//可能出现错误的代码</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>文件上传不成功<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token punctuation">(</span>上传异常<span class="token punctuation">)</span>；    <span class="token keyword">if</span><span class="token punctuation">(</span>更新数据库不成功<span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token punctuation">(</span>数据库异常操作<span class="token punctuation">)</span>；  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch(异常)&amp;#123;</span>    <span class="token comment" spellcheck="true">//必须的补救措施，例如删除文件、删除数据库记录</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：分散抛出，集中捕获</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  上传<span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>文件上传不成功<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token punctuation">(</span>上传异常<span class="token punctuation">)</span>；    <span class="token keyword">if</span><span class="token punctuation">(</span>更新数据库不成功<span class="token punctuation">)</span>  <span class="token keyword">throw</span> <span class="token punctuation">(</span>数据库异常<span class="token punctuation">)</span>；  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  其他<span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>其他操作失败<span class="token punctuation">)</span> <span class="token keyword">throw</span> （其他操作异常）；  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">//其他代码...</span>  <span class="token keyword">try</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      上传；      其他；  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch(上传异常)&amp;#123;</span>      <span class="token comment" spellcheck="true">//上传异常处理、例如删除文件</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch(数据库异常)&amp;#123;</span>      <span class="token comment" spellcheck="true">//数据库异常处理、比如删除数据库记录等</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch(其他异常)&amp;#123;</span>      <span class="token comment" spellcheck="true">//其他异常处理，比如记录异常日志等</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需要注意，exception作为超类应该放在最后捕获</strong></p><h4 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h4><p>示例：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">function</span> <span class="token function">inverse</span><span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$x</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">'Division by zero.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>      <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">/</span><span class="token variable">$x</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">try</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">echo</span> <span class="token function">inverse</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch (Exception $e) &amp;#123;</span>      <span class="token keyword">echo</span> <span class="token string">'Caught exception: '</span><span class="token punctuation">,</span>  <span class="token variable">$e</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; finally &amp;#123;</span>      <span class="token keyword">echo</span> <span class="token string">"First finally.\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">try</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token keyword">echo</span> <span class="token function">inverse</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch (Exception $e) &amp;#123;</span>      <span class="token keyword">echo</span> <span class="token string">'Caught exception: '</span><span class="token punctuation">,</span>  <span class="token variable">$e</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; finally &amp;#123;</span>      <span class="token keyword">echo</span> <span class="token string">"Second finally.\n"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token comment" spellcheck="true">//</span>  <span class="token comment" spellcheck="true">// Continue execution</span>  <span class="token keyword">echo</span> <span class="token string">"Hello World\n"</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PHP异常处理使用场景"><a href="#PHP异常处理使用场景" class="headerlink" title="PHP异常处理使用场景"></a>PHP异常处理使用场景</h3><h4 id="对程序的悲观预测"><a href="#对程序的悲观预测" class="headerlink" title="对程序的悲观预测"></a>对程序的悲观预测</h4><p>即当一个操作可能会由于一些不可控的因素（比如网络问题等），可能会出现执行不成功的情况。那么在种情况下就可以抛出异常，然后进行捕获，对异常情况进行细致的处理。</p><h4 id="程序的需要和对业务的需要"><a href="#程序的需要和对业务的需要" class="headerlink" title="程序的需要和对业务的需要"></a>程序的需要和对业务的需要</h4><p>需要强调的是，异常是业务处理中必不可少的环节，我们不能对异常视而不见。<br>需要用到异常处理的情况</p><ul><li>不希望业务代码中充斥着大量的打印、调试等处理；</li><li>业务中自定义的异常，对现实生活中各种业务进行补充；</li><li>对数据一致性有要求的业务操作中；</li></ul><p>异常处理机制可以把每一件事当做事务来考虑，还可以把异常处理当做成一种内建的恢复系统。</p><h4 id="语言级别的健壮性要求"><a href="#语言级别的健壮性要求" class="headerlink" title="语言级别的健壮性要求"></a>语言级别的健壮性要求</h4><p>我们都知道PHP在健壮性这一点是不足的。对很多异常是没有强制性限制的。所以很多异常需要我们自己来做。</p><p>通过try…catch处理，我们可以把异常造成的逻辑中断破坏降低到最小的范围，并且经过补救处理后不影响业务逻辑的完整性；乱抛异常和只抛不捕获，或者捕获而不补救，都会导致数据混乱。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="PHP中的错误级别"><a href="#PHP中的错误级别" class="headerlink" title="PHP中的错误级别"></a>PHP中的错误级别</h3><p>PHP的错误有很多类，包括warning、notice、deprecated、fatal error等。</p><p>常用到的错误级别</p><ul><li>deprecated，是最低级别的错误，表示不推荐、不建议。其虽不影响PHP正常的业务流程，但一般情况下建议修正；</li><li>notice，通知级别错误。表示你语法中存在不恰当的地方。常见的是 使用未定义的变量就会报此错误。这种错误也影响PHP正常流程；</li><li>warning，警告级别错误，是比较高级别的错误，表示在语法中出现很不恰当的地方，比如函数参数不匹配。这种级别的错误可能会导致出现不可预期的结果，所以建议修正；</li><li>fetal error，致命错误。直接导致PHP流程终结，后面代码不在执行。</li><li>prase error，语法解析错误。导致PHP代码无法通过语法检查。</li></ul><p>错误信息显示控制<br>方式一：<br>php.ini</p><pre><code>error_reporting = E_ALL | E_STRICT  #指定显示错误级别display_errors = On                 #错误信息显示控制</code></pre><p>方式二：PHP代码中</p><ol><li>error_reporting(0),表示屏蔽所有错误信息。正式部署时采用这样的策略，来防止错误信息泄露敏感信息。</li><li>@mysql_connect(),抑制错误信息输出。</li></ol><h3 id="PHP错误处理机制"><a href="#PHP错误处理机制" class="headerlink" title="PHP错误处理机制"></a>PHP错误处理机制</h3><h4 id="trigger-error"><a href="#trigger-error" class="headerlink" title="trigger_error"></a>trigger_error</h4><p>该方法用于主动抛出一个错误。示例</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token function">triggererror</span><span class="token punctuation">(</span><span class="token string">"random no eq 0"</span><span class="token punctuation">,</span><span class="token constant">E_USER_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="set-error-handler"><a href="#set-error-handler" class="headerlink" title="set_error_handler"></a>set_error_handler</h4><p>PHP中提供了set_error_handler（）函数可以用来接管PHP错误处理。</p><p><strong>set_error_handler(error_function, error_type);</strong></p><ul><li>error_function,规定发生错误时运行的函数。（必须）</li><li>error_types,规定在哪个错误级别报告级别会显示用户定义的错误，（可选，默认『E_ALL』）</li></ul><p>示例：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">function</span> <span class="token function">customError</span><span class="token punctuation">(</span><span class="token variable">$errNo</span><span class="token punctuation">,</span> <span class="token variable">$errStr</span><span class="token punctuation">,</span> <span class="token variable">$errFile</span><span class="token punctuation">,</span> <span class="token variable">$errLine</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;b>错误代码：&lt;/b>[$errNo]&amp;#123;$errStr&amp;#125;\r\n"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"错误所在的代码行：&amp;#123;$errLine&amp;#125;,文件:&amp;#123;$errFile&amp;#125;\r\n"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"PHP 版本 ，"</span><span class="token punctuation">.</span><span class="token constant">PHP_VERSION</span><span class="token punctuation">.</span><span class="token string">"("</span><span class="token punctuation">.</span><span class="token constant">PHP_OS</span><span class="token punctuation">.</span><span class="token string">")\r\n"</span><span class="token punctuation">;</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果有必要，用户自定义的错误处理程序必须终止（die（）；）当前脚本。</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">set_error_handler</span><span class="token punctuation">(</span><span class="token string">"custonError"</span><span class="token punctuation">,</span> <span class="token constant">E_ALL</span> <span class="token operator">|</span> <span class="token constant">E_STRICT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'o'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token variable">$a</span><span class="token punctuation">[</span>o<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义的错误处理函数一定要有这四个输入变量$errno, $errstr, $errfile, $errline.</p><ul><li>errno,代表错误等级的一组常量。比如 E_WARNING 其二进制掩码为4，表示告警信息。</li></ul><p><strong>注意：</strong> 自定义的错误处理函数并不能托管所有种类的错误，比如E_ERROR, E_PARSE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING,以及E_STRICT中的部分。</p><p><strong>注意：</strong> 如果使用自定义的 set_error_handler 接管PHP的错误处理，先前代码里的错误抑制 @ 也将会失效，这是这种错误也会被显示。</p><h4 id="restore-error-handler"><a href="#restore-error-handler" class="headerlink" title="restore_error_handler"></a>restore_error_handler</h4><p>该函数可以取消 set_error_handler 的错误接管.</p><h2 id="结合PHP错误处理主动抛出异常"><a href="#结合PHP错误处理主动抛出异常" class="headerlink" title="结合PHP错误处理主动抛出异常"></a>结合PHP错误处理主动抛出异常</h2><p>结合PHP的错误处理机制和异常处理机制，通过组合也可以实现同时捕获异常和非致命错误。<br>示例</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">function</span> <span class="token function">customError</span><span class="token punctuation">(</span><span class="token variable">$errNo</span><span class="token punctuation">,</span> <span class="token variable">$errStr</span><span class="token punctuation">,</span> <span class="token variable">$errFile</span><span class="token punctuation">,</span> <span class="token variable">$errLine</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token comment" spellcheck="true">//自定义错误处理时，可以手动抛出异常</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token variable">$level</span><span class="token punctuation">.</span><span class="token string">"|"</span><span class="token punctuation">.</span><span class="token variable">$errStr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">set_error_handler</span><span class="token punctuation">(</span><span class="token string">"custonError"</span><span class="token punctuation">,</span> <span class="token constant">E_ALL</span> <span class="token operator">|</span> <span class="token constant">E_STRICT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125; catch(Exception $e)&amp;#123;</span>      <span class="token keyword">echo</span> <span class="token string">"错误信息"</span><span class="token punctuation">.</span><span class="token variable">$e</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面示例可以捕获到异常和非致命错误，但对于 fetal error 这样的错误却捕获不到。但是通过其他的一些方法，我们还是可以做一些处理。 register_shutdown_function 该函数会在程序终止或die时触发一个函数，我们可以利用该触发函数做一些最后的收尾操作。</p><p>调用时机</p><ul><li>当页面被用户强制停止时</li><li>当程序代码运行超时时</li><li>当ＰＨＰ代码执行完成时，代码执行存在异常和错误、警告</li></ul><p>void register_shutdown_function ( callable $callback [, mixed $parameter [, mixed $… ]] )</p><p>示例</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token keyword">function</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>      <span class="token comment" spellcheck="true">// This is our shutdown function, in</span>      <span class="token comment" spellcheck="true">// here we can do any last operations</span>      <span class="token comment" spellcheck="true">// before the script is complete.</span>      <span class="token keyword">echo</span> <span class="token string">'Script executed with success'</span><span class="token punctuation">,</span> <span class="token constant">PHP_EOL</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>  <span class="token function">register_shutdown_function</span><span class="token punctuation">(</span><span class="token string">'shutdown'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 prase error 级别的错误，PHP层面就没有办法做什么了。我们只能通过开启错误日志，来记录这些错误。</p><p>php.ini设置</p><pre><code>log_errors = Onerror_log = /usr/log/log.log</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先，需要明确以下这两个概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;异常(exception)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP中的异常，是程序运行中不符合预期的情况及与正常流程不同的状况。&lt;br&gt;是属于逻辑和业务流程的一种中断，而不是语法错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误(error)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PHP中的错误则属于自身的问题，是一种非法的语法或者环境问题导致的、让编译器无法通过检查甚至无法运行的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="异常处理" scheme="https://weizhimiao.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
    <category term="错误处理" scheme="https://weizhimiao.github.io/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>memcache高速缓存工作原理及应用</title>
    <link href="https://weizhimiao.github.io/2016/09/29/memcache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/09/29/memcache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2016-09-29T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Memcached,是高性能的分布式内存缓存服务器，主要功能就是通过缓存数据库的查询，减少对数据库的访问次数，来提高动态web应用的速度和可扩展性。</p><p>memcached 是以守护程序方法运行于一个或多个服务器中，随时接受客户端的连接操作，客户端可以由各种语言编写，目前一致的客户端api包括 Perl / PHP / Python / Java / C# / C 等等。客户端在与 memcached 服务建立连接之后，接下来的事情就是存取对象了， 每个被存取的对象都有一个唯一的标识符 key，存取操作均通过这个 key进行，保存到 memcached 中的对象实际上是放置内存中的，并不是保存在平时的 cache 文件中的，这也是为什么 memcached 能够如此高效快速的原因。</p><p>注意，这些对象并不是持久的， 服务停止之后， 里边的数据就会丢失。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160929/MemcacheYingYongMoXing.png?1" alt="Memcached应用模型"></p><span id="more"></span><h2 id="Memcached的安装"><a href="#Memcached的安装" class="headerlink" title="Memcached的安装"></a>Memcached的安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>libevent</p><blockquote><p>Libevent 是一个用C语言编写的、轻量级的开源高性能网络库。<br>主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 BSD 和 Mac Os；支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。<br>Libevent 已经被广泛的应用，作为底层的网络库；比如 memcached、 Vomit、 Nylon、 Netchat等等。</p></blockquote><pre><code>wget http://n.sinaimg.cn/games/3ece443e/20160929/libevent-2.0.22-stable.tartar -vxf libevent-2.0.22-stable.tarcd libevent-2.0.22-stable./configure --prefix=/usr/local/libeventmake &amp;&amp; make install</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>wget http://n.sinaimg.cn/games/3ece443e/20160930/memcached-1.4.31.tar.gzcd memcached-1.4.31 ./configure --prefix=/usr/local/memcached --with-libevent=/usr/local/libeventmake &amp;&amp; make install</code></pre><p>查看是否已经安装成功</p><pre><code>cd /usr/local/memcached/lldrwxr-xr-x 2 root root 4096 9月  28 10:56 bindrwxr-xr-x 3 root root 4096 9月  28 10:56 includedrwxr-xr-x 3 root root 4096 9月  28 10:56 share</code></pre><h2 id="Memcached管理"><a href="#Memcached管理" class="headerlink" title="Memcached管理"></a>Memcached管理</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动Memcached服务器</p><pre><code>/usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211</code></pre><p>查看是否启动成功</p><pre><code>ps aux | grep memcacheroot     24428  0.0  0.0 323120   864 ?        Ssl  11:00   0:00 /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211root     24436  0.0  0.0 112664   984 pts/0    D+   11:00   0:00 grep --color=auto memcache</code></pre><p>或</p><pre><code>netstat -tlun | grep 11211tcp        0      0 0.0.0.0:11211           0.0.0.0:*               LISTENtcp6       0      0 :::11211                :::*                    LISTENudp        0      0 0.0.0.0:11211           0.0.0.0:*udp6       0      0 :::11211                :::*</code></pre><p>设置开机自启动</p><pre><code>echo &quot;/usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211&quot; &gt;&gt; /etc/rc.d/rc.local</code></pre><p>Memcached启动选项及说明</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p <num></num></td><td>Memcached监听的TCP端口，要保证该端口号未被占用</td></tr><tr><td>-U <num></num></td><td>指定监听UDP的端口，默认11211，0表示关闭</td></tr><tr><td>-s <file></file></td><td>指定Memcached用于监听的UNIX socket文件</td></tr><tr><td>-A</td><td>enable ascii “shutdown” command</td></tr><tr><td>-a <mask></mask></td><td>设置-s选项指定的UNIX socket文件的权限(默认权限: 0700)</td></tr><tr><td>-l <addr></addr></td><td>监听的服务器IP地址，如果有多个地址的话，使用逗号分隔，格式可以为“IP地址:端口号”，例如：-l 指定192.168.0.184:19830,192.168.0.195:13542；端口号也可以通过-p选项指定</td></tr><tr><td>-d</td><td>指定memcached进程作为一个守护进程启动</td></tr><tr><td>-r</td><td>设置产生core文件大小</td></tr><tr><td>-u <username></username></td><td>运行memcached的用户 (only when run as root)</td></tr><tr><td>-m <num></num></td><td>指定分配给memcached使用的内存，单位是MB(默认: 64 MB)</td></tr><tr><td>-M</td><td>当内存使用超出配置值时，禁止自动清除缓存中的数据项，此时Memcached不可用，直到内存被释放</td></tr><tr><td>-c <num></num></td><td>设置最大运行的并发连接数，默认是1024</td></tr><tr><td>-k</td><td>设置锁定所有分页的内存，对于大缓存应用场景，谨慎使用该选项</td></tr><tr><td>-v</td><td>输出警告和错误信息</td></tr><tr><td>-vv</td><td>打印信息比-v更详细：不仅输出警告和错误信息，也输出客户端请求和响应信息</td></tr><tr><td>-vvv</td><td>extremely verbose (also print internal state transitions)</td></tr><tr><td>-h</td><td>显示Memcached版本和摘要信息</td></tr><tr><td>-i</td><td>打印libevent和Memcached的licenses信息</td></tr><tr><td>-V</td><td>输出Memcached版本号</td></tr><tr><td>-P <file></file></td><td>保存memcached进程的pid文件，（与 -d 一起搭配使用）</td></tr><tr><td>-f <factor></factor></td><td>用于计算缓存数据项的内存块大小的乘数因子，默认是1.25</td></tr><tr><td>-n <bytes></bytes></td><td>为缓存数据项的key、value、flag设置最小分配字节数，默认是48</td></tr><tr><td>-L</td><td>尝试使用大内存分页（pages）</td></tr><tr><td>-D <char></char></td><td>用于统计报告中Key前缀和ID之间的分隔符，默认是冒号“:”</td></tr><tr><td>-t <num></num></td><td>指定用来处理请求的线程数，默认为4</td></tr><tr><td>-R</td><td>为避免客户端饿死（starvation），对连续达到的客户端请求数设置一个限额，如果超过该设置，会选择另一个连接来处理请求，默认为20</td></tr><tr><td>-C</td><td>禁用CAS</td></tr><tr><td>-b <num></num></td><td>Set the backlog queue limit (default: 1024)</td></tr><tr><td>-B</td><td>指定使用的协议，默认行为是自动协商（autonegotiate），可能使用的选项有auto、ascii、binary。</td></tr><tr><td>-I</td><td>Override the size of each slab page. Adjusts max item size(default: 1mb, min: 1k, max: 128m)</td></tr><tr><td>-F</td><td>禁用flush_all命令</td></tr><tr><td>-o</td><td>指定逗号分隔的选项，一般用于用于扩展或实验性质的选项</td></tr></tbody></table><h3 id="通过telnet连接使用Memcache"><a href="#通过telnet连接使用Memcache" class="headerlink" title="通过telnet连接使用Memcache"></a>通过telnet连接使用Memcache</h3><p>连接</p><pre><code>telnet 127.0.0.1 11211</code></pre><p>命令格式：<command name> <key> <flags> <exptime> <bytes>\r\n <data block>\r\n</data></bytes></exptime></flags></key></p><blockquote><p><command name> 可以是”set”, “add”, “replace”<br><key> 客户端需要保存数据的key。<br><flags> 是一个16位的无符号的整数(以十进制的方式表示)。<br><exptime> 过期的时间。<br>最后客户端需要加上”\r\n”作为”命令头”的结束标志。即回车</exptime></flags></key></p></blockquote><p>示例：</p><p>保存一个数据（保存一个『cache_key1=&gt;12345』的键值对到memcached 60s）</p><pre><code>set cache_key1 0 60 512345STORED</code></pre><p>获取刚保存的值</p><pre><code>get cache_key1VALUE cache_key1 0 512345END</code></pre><p>其他命令：</p><table><thead><tr><th>Command</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>get</td><td>获取值</td><td>get mykey</td></tr><tr><td>set</td><td>设置值（可以存在可以不存在）</td><td>set mykey 0 60 5</td></tr><tr><td>add</td><td>添加新值</td><td>add newkey 0 60 5</td></tr><tr><td>replace</td><td>替换值（必须已存在）</td><td>replace key 0 60 5</td></tr><tr><td>append</td><td>在原有值之后添加数据</td><td>append key 0 60 15</td></tr><tr><td>prepend</td><td>在原有值之前添加数据</td><td>prepend key 0 60 15</td></tr><tr><td>incr</td><td>Increments numerical key value by given number</td><td>incr mykey 2</td></tr><tr><td>decr</td><td>Decrements numerical key value by given number</td><td>decr mykey 5</td></tr><tr><td>delete</td><td>删除一条数据</td><td>delete mykey</td></tr><tr><td>flush_all</td><td>清除所有数据</td><td>flush_all</td></tr></tbody></table><pre><code>    |清除900秒之内的数据 | flush_all 900</code></pre><p>stats   | 查看所有状态| stats<br>        | Prints memory statistics | stats slabs<br>        | Prints memory statistics | stats malloc<br>        | Print higher level allocation statistics | stats items<br>        | | stats detail<br>        | 已使用大小 | stats sizes<br>        | 重置状态 | stats reset<br>version | 查看版本 | version<br>verbosity | Increases log level | verbosity<br>quit    | 退出telnet连接 | quit</p><h3 id="通过客户端（PHP）连接和使用Memcached"><a href="#通过客户端（PHP）连接和使用Memcached" class="headerlink" title="通过客户端（PHP）连接和使用Memcached"></a>通过客户端（PHP）连接和使用Memcached</h3><p>php扩展Memcached安装</p><p>依赖</p><blockquote><p>libmemcached, 是一个 memcached 的库，客户端库，C 和 C++ 语言实现的客户端库，具有低内存占用率、线程安全、并提供对memcached功能的全面支持。它还采用 多种命令行工具： memcat ， memflush ， memrm ， memstat ，并memslap （负载代）。程序库一直在设计，让不同的散列方法对密钥，分割的钥匙，并使用统一的散列分配。</p></blockquote><pre><code>wget https://launchpadlibrarian.net/165454254/libmemcached-1.0.18.tar.gztar -zxvf libmemcached-1.0.18.tar.gzcd libmemcached-1.0.18./configure --prefix=/usr/local/libmemcachedmake &amp;&amp; make install</code></pre><p>安装扩展</p><pre><code>wget http://n.sinaimg.cn/games/3ece443e/20160929/memcached-2.2.0.tartar -xvf memcached-2.2.0.tarcd memcached-2.2.0/usr/local/php56/bin/phpize./configure --with-php-config=/usr/local/php56/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached  --enable-memcached --disable-memcached-saslmake &amp;&amp; make installInstalling shared extensions:     /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/</code></pre><p>查看是否安装成功</p><pre><code>cd /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/ll-rwxr-xr-x 1 root root  380475 9月  28 22:25 memcached.so-rwxr-xr-x 1 root root  756714 9月  26 17:32 mysqli.so-rwxr-xr-x 1 root root 1333912 9月  24 23:31 opcache.a-rwxr-xr-x 1 root root  618435 9月  24 23:31 opcache.so</code></pre><p>修改配置</p><pre><code>vi /usr/local/php56/lib/php.iniextension=/usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/memcached.so</code></pre><p>重启php-fpm</p><pre><code>kill -USR2 `cat /usr/local/php56/var/run/php-fpm.pid`</code></pre><p>查看是否已经加载成功</p><pre><code>/usr/local/php56/bin/php -m或通过phpinfo();查看</code></pre><p>测试</p><pre><code>vi memcache_test.php</code></pre><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>        <span class="token variable">$mc</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Memcached</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$mc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addServer</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">11211</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'cache_key'</span><span class="token punctuation">,</span><span class="token string">'mem_value'</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$val</span> <span class="token operator">=</span> <span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'cache_key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$val</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">'cache_key'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$mc</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问结果：</p><pre><code>object(Memcached)#1 (0) &#123; &#125; string(9) &quot;mem_value&quot; bool(true)</code></pre><p>php关于memcached 的两种扩展memcache 和 memcached 介绍</p><ol><li><p>目前大多数php环境里使用的都是不带d的memcache版本，这个版本出的比较早，是一个原生版本，完全在php框架内开发的。与之对应的带d的memcached是建立在libmemcached的基础上，所以相对来说，memcached版本的功能更全一些。</p><blockquote><p><a href="http://cn2.php.net/manual/en/book.memcache.php">memcache:</a></p><p><a href="http://cn2.php.net/manual/en/book.memcached.php">memcached:</a></p></blockquote></li><li><p>Memcache是原生实现的，支持OO和非OO两套接口并存。而memcached是使用libmemcached，只支持OO接口。</p></li><li><p>memcached有了一个统一的setOption()来设置设置，而不用在操作的时候设置了。Memcached实现了更多的memcached协议。</p></li><li><p>memcached支持Binary Protocol，而memcache不支持。这意味着memcached会有更高的性能。不过memcached目前还不支持长连接。</p></li><li><p>另外一点也是大家比较关心的，就是所使用的算法。“一致性hash算法”是当添加或删除存储节点时，对存储在memcached上的数据影响较小的一种算法。在php的两个扩展库中，都可以使用该算法，只是设置方法有所不同。</p></li></ol><ul><li>Memcache</li></ul><p>修改php.ini添加：</p><pre><code>[Memcache]Memcache.allow_failover = 1Memcache.hash_strategy =consistentMemcache.hash_function =crc32</code></pre><p>或在php中使用ini_set方法：</p><pre><code>ini_set(‘memcache.hash_strategy&#39;,&#39;standard&#39;);ini_set(‘memcache.hash_function&#39;,&#39;crc32&#39;);</code></pre><ul><li>Memcached</li></ul><pre><code>$mem = new memcached();$mem-&gt;setOption(Memcached::OPT_DISTRIBUTION,Memcached::DISTRIBUTION_CONSISTENT);$mem-&gt;setOption(Memcached::OPT_LIBKETAMA_COMPATIBLE,true);</code></pre><h2 id="Memcached监控"><a href="#Memcached监控" class="headerlink" title="Memcached监控"></a>Memcached监控</h2><h3 id="利用phpmemcache-php图形监控工具"><a href="#利用phpmemcache-php图形监控工具" class="headerlink" title="利用phpmemcache.php图形监控工具"></a>利用phpmemcache.php图形监控工具</h3><p>下载 phpmemcache.php</p><pre><code>wget http://n.sinaimg.cn/games/3ece443e/20160929/phpmemcache.php</code></pre><p>将phpmemcache.php放入web目录</p><pre><code>mv phpmemcache.php /usr/local/nginx/html</code></pre><p>修改phpmemcache.php中配置</p><pre><code>define(&#39;ADMIN_USERNAME&#39;,&#39;xxxx&#39;);    // 用户名修改，在访问 phpmemcache.php 需要进行认证define(&#39;ADMIN_PASSWORD&#39;,&#39;xxxx&#39;);    // 密码define(&#39;DATE_FORMAT&#39;,&#39;Y/m/d H:i:s&#39;);define(&#39;GRAPH_SIZE&#39;,200);define(&#39;MAX_ITEM_DUMP&#39;,50);$MEMCACHE_SERVERS[] = &#39;127.0.0.1:11211&#39;; // 加入需要监控的memcached服务器//$MEMCACHE_SERVERS[] = &#39;192.168.200.104:11212&#39;; // add more as an array</code></pre><p>浏览器访问<br><img data-src="http://n.sinaimg.cn/games/3ece443e/20160929/phpmemcache.png?1" alt="phpmemcache浏览器访问效果"></p><h3 id="利用Stats命令查看"><a href="#利用Stats命令查看" class="headerlink" title="利用Stats命令查看"></a>利用Stats命令查看</h3><p>利用stats命令可以查看当前memcached的各种状态</p><pre><code>telnet 127.0.0.1 11211Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &#39;^]&#39;.statsSTAT pid 24732STAT uptime 66597STAT time 1475115983STAT version 1.4.31STAT libevent 2.0.22-stableSTAT pointer_size 64STAT rusage_user 6.194421STAT rusage_system 2.419890STAT curr_connections 10STAT total_connections 16STAT connection_structures 11STAT reserved_fds 20STAT cmd_get 5STAT cmd_set 8STAT cmd_flush 0STAT cmd_touch 0STAT get_hits 4STAT get_misses 1STAT get_expired 0STAT get_flushed 0STAT delete_misses 0STAT delete_hits 2STAT incr_misses 0STAT incr_hits 0STAT decr_misses 0STAT decr_hits 0STAT cas_misses 0STAT cas_hits 0STAT cas_badval 0STAT touch_hits 0STAT touch_misses 0STAT auth_cmds 0STAT auth_errors 0STAT bytes_read 3850STAT bytes_written 293STAT limit_maxbytes 134217728STAT accepting_conns 1STAT listen_disabled_num 0STAT time_in_listen_disabled_us 0STAT threads 4STAT conn_yields 0STAT hash_power_level 16STAT hash_bytes 524288STAT hash_is_expanding 0STAT malloc_fails 0STAT log_worker_dropped 0STAT log_worker_written 0STAT log_watcher_skipped 0STAT log_watcher_sent 0STAT bytes 0STAT curr_items 0STAT total_items 6STAT expired_unfetched 0STAT evicted_unfetched 0STAT evictions 0STAT reclaimed 2STAT crawler_reclaimed 0STAT crawler_items_checked 0STAT lrutail_reflocked 0END</code></pre><p>Stats详解</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>pid</td><td>memcache服务器的进程ID</td></tr><tr><td>uptime</td><td>服务器已经运行的秒数</td></tr><tr><td>time</td><td>服务器当前的unix时间戳</td></tr><tr><td>version</td><td>memcache版本</td></tr><tr><td>pointer_size</td><td>当前操作系统的指针大小（32位系统一般是32bit）</td></tr><tr><td>rusage_user</td><td>进程的累计用户时间</td></tr><tr><td>rusage_system</td><td>进程的累计系统时间</td></tr><tr><td>curr_items</td><td>服务器当前存储的items数量</td></tr><tr><td>total_items</td><td>从服务器启动以后存储的items总数量</td></tr><tr><td>bytes</td><td>当前服务器存储items占用的字节数</td></tr><tr><td>curr_connections</td><td>当前打开着的连接数</td></tr><tr><td>total_connections</td><td>从服务器启动以后曾经打开过的连接数</td></tr><tr><td>connection_structures</td><td>服务器分配的连接构造数</td></tr><tr><td>cmd_get</td><td>get命令（获取）总请求次数</td></tr><tr><td>cmd_set</td><td>set命令（保存）总请求次数</td></tr><tr><td>get_hits</td><td>总命中次数</td></tr><tr><td>get_misses</td><td>总未命中次数</td></tr><tr><td>evictions</td><td>为获取空闲内存而删除的items数（分配给memcache的空间用满后需要删除旧的items来得到空间分配给新的items）</td></tr><tr><td>bytes_read</td><td>总读取字节数（请求字节数）</td></tr><tr><td>bytes_written</td><td>总发送字节数（结果字节数）</td></tr><tr><td>limit_maxbytes</td><td>分配给memcache的内存大小（字节）</td></tr><tr><td>threads</td><td>当前线程数</td></tr></tbody></table><h3 id="利用各种监控软件查看（例如：nagios监控memcache的插件）"><a href="#利用各种监控软件查看（例如：nagios监控memcache的插件）" class="headerlink" title="利用各种监控软件查看（例如：nagios监控memcache的插件）"></a>利用各种监控软件查看（例如：nagios监控memcache的插件）</h3><blockquote><p>只以命中率大于和小于为例两种状态。</p></blockquote><pre><code>vim check_memcache</code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -ne 1 ]</span><span class="token keyword">then</span><span class="token keyword">echo</span> <span class="token string">"Usage:<span class="token variable">$0</span> -c num2"</span><span class="token keyword">exit</span> 0<span class="token keyword">fi</span>cmd_get<span class="token operator">=</span>`/usr/local/nagios/libexec/check_tcp -H localhost -p 11211 -E -s <span class="token string">'stats\r\nquit\r\n'</span> -e <span class="token string">'uptime'</span> <span class="token operator">|</span><span class="token function">grep</span> cmd_get <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&amp;#123;print <span class="token variable">$3</span>+0&amp;#125;'</span>`get_hits<span class="token operator">=</span>`/usr/local/nagios/libexec/check_tcp -H localhost -p 11211 -E -s <span class="token string">'stats\r\nquit\r\n'</span> -e <span class="token string">'uptime'</span> <span class="token operator">|</span><span class="token function">grep</span> get_hits <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&amp;#123;print <span class="token variable">$3</span>+0&amp;#125;'</span>`hit_rate<span class="token operator">=</span>`echo <span class="token string">"<span class="token variable">$get_hits*100</span>/<span class="token variable">$cmd_get</span>"</span><span class="token operator">|</span>bc`<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$hit_rate</span> -gt <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span><span class="token keyword">echo</span> <span class="token string">"OK - hit rate is <span class="token variable">$hit_rate</span> | hit_rate=<span class="token variable">$hit_rate</span>; cmd_get=<span class="token variable">$cmd_get</span>; get_hits=<span class="token variable">$get_hits</span>"</span><span class="token keyword">exit</span> 0<span class="token keyword">else</span><span class="token keyword">echo</span> <span class="token string">"CRITICAL - hit rate is <span class="token variable">$hit_rate</span> | hit_rate=<span class="token variable">$hit_rate</span>; cmd_get=<span class="token variable">$cmd_get</span>; get_hits=<span class="token variable">$get_hits</span>"</span><span class="token keyword">exit</span> 2<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试命中率大于80%为正常为例;</p><pre><code>eg：sh check_memcache 80root@ip-10-250-114-95:/liang# sh check_memcache 80OK - hit rate is 99 | hit_rate=99; cmd_get=142547; get_hits=141880</code></pre><p>以上证明命中率99%，即状态为OK.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Memcached,是高性能的分布式内存缓存服务器，主要功能就是通过缓存数据库的查询，减少对数据库的访问次数，来提高动态web应用的速度和可扩展性。&lt;/p&gt;
&lt;p&gt;memcached 是以守护程序方法运行于一个或多个服务器中，随时接受客户端的连接操作，客户端可以由各种语言编写，目前一致的客户端api包括 Perl / PHP / Python / Java / C# / C 等等。客户端在与 memcached 服务建立连接之后，接下来的事情就是存取对象了， 每个被存取的对象都有一个唯一的标识符 key，存取操作均通过这个 key进行，保存到 memcached 中的对象实际上是放置内存中的，并不是保存在平时的 cache 文件中的，这也是为什么 memcached 能够如此高效快速的原因。&lt;/p&gt;
&lt;p&gt;注意，这些对象并不是持久的， 服务停止之后， 里边的数据就会丢失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160929/MemcacheYingYongMoXing.png?1&quot; alt=&quot;Memcached应用模型&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="缓存" scheme="https://weizhimiao.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="memcache" scheme="https://weizhimiao.github.io/tags/memcache/"/>
    
    <category term="memcached" scheme="https://weizhimiao.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>linux服务和进程管理</title>
    <link href="https://weizhimiao.github.io/2016/09/28/Linux%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/28/Linux%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2016-09-28T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160929/LinuxFuWuHeJinChengGuanLi.png?1" alt="Linux服务和进程管理"></p><span id="more"></span><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程管理的三个主要任务</p><ul><li>判断服务器的健康状态</li><li>查看所有正在运行的进程</li><li>强制终止进程</li></ul><h3 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h3><h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h4><blockquote><p>查看当前系统所有运行的进程（可以不加-）</p><ul><li>-a 显示前台所有进程</li><li>-u 显示用户名</li><li>-x 显示后台进程</li></ul></blockquote><p>命令执行结果示例：</p><pre><code>ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.3  41280  3732 ?        Ss   9月26   0:02 /usr/lib/systemd/systemd --switched-root --systemroot         2  0.0  0.0      0     0 ?        S    9月26   0:00 [kthreadd]root         3  0.0  0.0      0     0 ?        S    9月26   0:00 [ksoftirqd/0]root         5  0.0  0.0      0     0 ?        S&lt;   9月26   0:00 [kworker/0:0H]root         6  0.0  0.0      0     0 ?        S    9月26   0:00 [kworker/u2:0]root         7  0.0  0.0      0     0 ?        S    9月26   0:00 [migration/0]root         8  0.0  0.0      0     0 ?        S    9月26   0:00 [rcu_bh]root         9  0.0  0.0      0     0 ?        S    9月26   0:00 [rcuob/0]root        10  0.0  0.0      0     0 ?        S    9月26   0:36 [rcu_sched]root        11  0.0  0.0      0     0 ?        S    9月26   0:32 [rcuos/0]···</code></pre><p>参数说明:</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>用户名</td></tr><tr><td>PID</td><td>进程PID 1  init  系统启动的第一个进程</td></tr><tr><td>%CPU</td><td>cpu占用百分比</td></tr><tr><td>%MEM</td><td>内存占用百分比</td></tr><tr><td>VSZ</td><td>虚拟内存占用量（KB）</td></tr><tr><td>RSS</td><td>固定内存占有量</td></tr><tr><td>TTY</td><td>登录终端  tty1-7 本地终端1-6 字符、 7图形） pts/0-255</td></tr><tr><td>STAT</td><td>状态 （S：睡眠 D：不可唤醒 R：运行 T：停止 Z：僵死 W：进入内存交换 X：死掉的进程 &lt;:高优先级 N：低优先级 L：被锁进内存 s：含子进程 +：位于后台 l：多线程）</td></tr><tr><td>START</td><td>进程触发时间</td></tr><tr><td>TIME</td><td>占用cpu时间</td></tr><tr><td>COMMAND</td><td>进程本身</td></tr></tbody></table><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><blockquote><ul><li>-a 查看进程树</li></ul></blockquote><p>命令执行结果示例：</p><pre><code>pstree -asystemd --switched-root --system --deserialize 21  ├─AliHids  │   └─4*[&#123;AliHids&#125;]  ├─AliYunDun  │   └─8*[&#123;AliYunDun&#125;]  ├─AliYunDunUpdate  │   └─3*[&#123;AliYunDunUpdate&#125;]  ├─agetty --noclear tty1 linux  ├─aliyun-service -d  ├─crond -n  ├─dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation  ├─memcached -d -m 128 -u root -p 11211  │   └─6*[&#123;memcached&#125;]  ├─nginx  │   └─nginx  ├─ntpd -u ntp:ntp -g  ├─php-fpm  │   ├─php-fpm  │   └─php-fpm  ├─rsyslogd -n  │   └─2*[&#123;rsyslogd&#125;]  ├─sshd -D  │   └─sshd  │       └─bash  │           └─pstree -a  ├─systemd-journal  ├─systemd-logind  └─systemd-udevd</code></pre><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><blockquote><p>实时显示进程状态</p></blockquote><p>命令执行结果示例：</p><pre><code>top - 15:04:52 up 2 days,  5:25,  1 user,  load average: 0.00, 0.01, 0.05Tasks:  70 total,   2 running,  68 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1016796 total,   599400 free,    41948 used,   375448 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   838500 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND  917 root      20   0   82696   9152   5456 S  0.3  0.9   5:50.76 AliHids    1 root      20   0   41280   3732   2388 S  0.0  0.4   0:02.36 systemd    2 root      20   0       0      0      0 S  0.0  0.0   0:00.01 kthreadd    3 root      20   0       0      0      0 S  0.0  0.0   0:00.00 ksoftirqd/0    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H    6 root      20   0       0      0      0 S  0.0  0.0   0:00.26 kworker/u2:0    7 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0    ···</code></pre><p>参数说明</p><ul><li>第一行：系统当前时间，系统持续时间， 登录用户，1,5,15分钟之前的平均负载</li><li>第二行：进程总数</li><li>第三行：CPU占用率</li><li>第四行：内存使用：总共，空闲，已使用，缓存</li><li>第五行：swap使用情况</li></ul><p>操作命令：</p><ul><li>M,按内存占用排序</li><li>P,安CPU占用排序</li><li>q,退出</li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><h4 id="kill-结束单个进程"><a href="#kill-结束单个进程" class="headerlink" title="kill 结束单个进程"></a>kill 结束单个进程</h4><blockquote><p>kill命令是通过向进程发送指定的信号来结束相应进程的。在默认情况下，采用编号为15的TERM信号。TERM信号将终止所有不能捕获该信号的进程。对于那些可以捕获该信号的进程就要用编号为9的kill信号，强行“杀掉”该进程。</p><p>命令格式：kill 信号  PID</p></blockquote><p>信号，进程间的通信方式</p><p>我们常用的信号有</p><table><thead><tr><th>信号名称</th><th>信号</th><th>意义</th></tr></thead><tbody><tr><td>HUP</td><td>1</td><td>终端断线</td></tr><tr><td>INT</td><td>2</td><td>中断（同 Ctrl + C）</td></tr><tr><td>QUIT</td><td>3</td><td>退出（同 Ctrl + \）</td></tr><tr><td>TERM</td><td>15</td><td>终止</td></tr><tr><td>KILL</td><td>9</td><td>强制终止</td></tr><tr><td>CONT</td><td>18</td><td>继续（与STOP相反， fg/bg命令）</td></tr><tr><td>STOP</td><td>19</td><td>暂停（同 Ctrl + Z）</td></tr></tbody></table><p>示例：结束 memcached 进程</p><p>获取memcached进程pid（24428，即为memcached进程PID）</p><pre><code>ps -aux | grep memcacheroot     24428  0.0  0.0 323120   864 ?        Ssl  11:00   0:02 /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211root     24727  0.0  0.0 112664   984 pts/0    S+   15:54   0:00 grep --color=auto memcache#ps -ef | grep memcacheroot     24428     1  0 11:00 ?        00:00:02 /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211root     24708 24568  0 15:49 pts/0    00:00:00 grep --color=auto memcache</code></pre><p>或者使用pidof查看 （ pid + of ）</p><pre><code>[root@...]# pidof memcached24428</code></pre><p>终止 memcached</p><pre><code>kill -9 24428ps -aux | grep memcacheroot     24729  0.0  0.0 112664   984 pts/0    S+   15:55   0:00 grep --color=auto memcache</code></pre><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><blockquote><p>杀死指定名字的进程</p><p>命令格式：killall 信号  进程名</p></blockquote><p>示例：</p><pre><code>killall -9 memcached</code></pre><h4 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h4><blockquote><p>支持按照一定规则匹配来杀死进程</p><p>命令格式：pkill [options] <pattern></pattern></p></blockquote><p>示例：杀死用户 wahaha 下的所有进程</p><pre><code>pkill -u wahaha</code></pre><p>把某个终端登陆的用户踢出</p><pre><code>pkill -9 -t 终端号</code></pre><p>把本地登陆终端1登陆用户踢出</p><pre><code>pkill -9 -t tty1                              </code></pre><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><h3 id="Linux中服务的分类"><a href="#Linux中服务的分类" class="headerlink" title="Linux中服务的分类"></a>Linux中服务的分类</h3><h4 id="系统默认安装的服务-RPM"><a href="#系统默认安装的服务-RPM" class="headerlink" title="系统默认安装的服务(RPM)"></a>系统默认安装的服务(RPM)</h4><ul><li>独立的服务</li><li>基于xinetd的服务，xinetd是系统超级守护进程<blockquote><p>xinetd服务其本身就是一个独立的服务。</p><p>当程序调用xinetd服务时，它先调用的事xinetd服务，让后xinetd服务在调用索要调用的服务进行相应。</p><p>Linux系统默认是没有安装xinetd服务的，需要进行安装后才能使用。</p></blockquote></li></ul><h4 id="源码包安装的服务"><a href="#源码包安装的服务" class="headerlink" title="源码包安装的服务"></a>源码包安装的服务</h4><h3 id="系统默认安装的服务"><a href="#系统默认安装的服务" class="headerlink" title="系统默认安装的服务"></a>系统默认安装的服务</h3><h4 id="如何区分服务的分类"><a href="#如何区分服务的分类" class="headerlink" title="如何区分服务的分类"></a>如何区分服务的分类</h4><p>查看服务的自启动状态</p><pre><code>chkconfig  --list                      </code></pre><p>运行结果：</p><pre><code>chkconfig  --list注意：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。      如果您想列出 systemd 服务,请执行 &#39;systemctl list-unit-files&#39;。      欲查看对特定 target 启用的服务请执行      &#39;systemctl list-dependencies [target]&#39;。aegis              0:关    1:关    2:开    3:开    4:开    5:开    6:关agentwatch         0:关    1:关    2:开    3:开    4:开    5:开    6:关netconsole         0:关    1:关    2:关    3:关    4:关    5:关    6:关network            0:关    1:关    2:开    3:开    4:开    5:开    6:关</code></pre><p>Linux的运行级别：0-6</p><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1</td><td>单用户模式</td></tr><tr><td>2</td><td>不完全多用户，不包含NFS服务</td></tr><tr><td>3</td><td>完全多用户,字符界面</td></tr><tr><td>4</td><td>未分配</td></tr><tr><td>5</td><td>图形界面</td></tr><tr><td>6</td><td>重启</td></tr></tbody></table><p>查看当前系统的运行级别：</p><pre><code>runlevelN 3</code></pre><p>切换系统当前的运行级别：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>init  0</td><td>关机</td></tr><tr><td>init  5</td><td>切换到图形界面（前提图形界面已经安装）</td></tr><tr><td>init  3</td><td>切换到字符界面</td></tr><tr><td>init  6</td><td>重启</td></tr></tbody></table><h4 id="独立的服务管理"><a href="#独立的服务管理" class="headerlink" title="独立的服务管理"></a>独立的服务管理</h4><ul><li>启动</li></ul><p>第一种方式：</p><pre><code>/etc/rc.d/init.d/服务名 start| stop | restart | status# 例：/etc/rc.d/init.d/httpd start</code></pre><p>第二种方式：（只支持RedHat系列的Linux）</p><pre><code>service 服务名 tart| stop | restart | status</code></pre><p><em><strong>service命令其本质是当命令运行时直接在/etc/rc.d/init.d目录下查找相应的服务，并进行相应的操作。）</strong></em></p><ul><li>自启动</li><li>第一种方式：<pre><code>chkconfig --level 2345 服务名 on|off</code></pre>第二种方式：（推荐）<pre><code>vi  /etc/rc.local (系统启动时会运行该文件)</code></pre>修改文件内容：<pre><code>touch /var/lock/subsys/local （更新系统的开机时间）# 在下一行，写入自己要启动的服务名，比如我要开机自启动httpd服务：# 就加入/etc/rc.d/init.d/httpd start# 更改后文件就是：touch /var/lock/subsys/local/etc/rc.d/init.d/httpd start</code></pre></li></ul><h4 id="ntsysv自启动管理工具"><a href="#ntsysv自启动管理工具" class="headerlink" title="ntsysv自启动管理工具"></a>ntsysv自启动管理工具</h4><p>所有系统默认安装服务都可以使用ntsysv命令进行自启动管理。rpm包安装服务，自启动管理工具（只要rpm安装的，都可进行管理）</p><h3 id="源码包安装的服务-1"><a href="#源码包安装的服务-1" class="headerlink" title="源码包安装的服务"></a>源码包安装的服务</h3><p>启动</p><pre><code>/usr/local/apache2/bin/apachectl  start</code></pre><p>自启动</p><pre><code>vi /etc/rc.local         加入/usr/local/apache2/bin/apachectl  start</code></pre><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><blockquote><p>首先保证crond服务时启动的（crond默认是自启动的）</p></blockquote><p>命令：crontab</p><p>编辑格式： * * * * *  命令</p><p>说明：</p><ul><li>第一个*：一小时中第几分钟  0-59</li><li>第二个*：一天中第几个小时  0-23</li><li>第三个*：一个月中第几天    1-31</li><li>第四个*：一年第几个月      1-12</li><li>第五个*：一周中星期几       0-6             </li></ul><p>例</p><pre><code>10  *  31  *  *  命令10  *  *  *  *  命令5  4  *  5-10  *  命令*/10  *  *  *  *  命令5 4  1,15  *  *  命令  #日期和星期不要同时指定，会超出预期5 4 10 * 5 命令*/20 4 * 5 2   命令    #每隔二十分钟</code></pre><p>查看系统定时任务</p><pre><code>crontab  -l</code></pre><p>删除定时任务(慎用，删除之前记得备份数据)</p><pre><code>crontab  -r</code></pre><p><strong>注意事项：</strong></p><ul><li>选项都不能为空，必须填入，不知道的值使用通配符*表示任何时间</li><li>每个时间字段都可以指定多个值，不连续的值用,间隔，连续的值用-间隔</li><li>间隔固定时间执行书写为*/n格式</li><li>命令应该给出绝对路径</li><li>星期几何第几天不能同时出现</li><li>最小时间范围是分钟，最大时间范围是月</li></ul><h2 id="查看系统启动信息"><a href="#查看系统启动信息" class="headerlink" title="查看系统启动信息"></a>查看系统启动信息</h2><p>查看系统启动信息</p><pre><code>dmesg</code></pre><p>系统启动信息日志</p><pre><code>cat  /var/log/dmesg</code></pre><p>查看eth0信息</p><pre><code>dmesg | grep eth0                   </code></pre><p>查看cpu信息</p><pre><code>dmesg | grep CPU                   </code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160929/LinuxFuWuHeJinChengGuanLi.png?1&quot; alt=&quot;Linux服务和进程管理&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="进程管理" scheme="https://weizhimiao.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    <category term="服务管理" scheme="https://weizhimiao.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx运行状态监控</title>
    <link href="https://weizhimiao.github.io/2016/09/27/Nginx%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/"/>
    <id>https://weizhimiao.github.io/2016/09/27/Nginx%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/</id>
    <published>2016-09-27T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx可以通过stub_status模块来查看服务器的状态信息。</p><span id="more"></span><h2 id="安装stub-status模块"><a href="#安装stub-status模块" class="headerlink" title="安装stub_status模块"></a>安装stub_status模块</h2><p>查看服务器当前是否已经编译安装过stub_status模块</p><pre><code>/usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.11.4built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC)configure arguments: --prefix=/usr/local/nginx</code></pre><p>安装 stub_status 模块</p><p>解压相应版本的nginx源码包，</p><pre><code>cd nginx-1.11.4</code></pre><p>配置</p><pre><code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module</code></pre><p>编译（不执行make install操作）</p><pre><code>make</code></pre><p>手动替换 nginx 执行文件</p><pre><code>mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bakcp ./objs/nginx /usr/local/nginx/sbin/</code></pre><p>查看是否安装成功</p><pre><code>/usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.11.4built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC)configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module</code></pre><h2 id="启用nginx-status配置"><a href="#启用nginx-status配置" class="headerlink" title="启用nginx status配置"></a>启用nginx status配置</h2><p>修改配置</p><pre><code>vi /usr/local/nginx/conf/nginx.conf</code></pre><p>加入配置</p><pre><code>location /ngx_status&#123;    stub_status on;    access_log off;    allow all;    #deny all;&#125;</code></pre><p>重启nginx</p><pre><code># /usr/local/nginx/sbin/nginx -s reload 可能或有问题，所以先停止当前nginx进程，然后在重启。/usr/local/nginx/sbin/nginx -s stop/usr/local/nginx/sbin/nginx</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器或者curl访问</p><p><a href="http://120.76.250.101/ngx_status">http://120.76.250.101/ngx_status</a><br>或</p><pre><code>curl 127.0.0.1/ngx_statusActive connections: 1server accepts handled requests 2 2 2Reading: 0 Writing: 1 Waiting: 0</code></pre><p>参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Active connections</td><td>活跃的连接数量</td></tr><tr><td>server accepts handled requests</td><td>2 2 2 表示总共处理了2个连接 , 成功创建2次握手, 总共处理了2个请求</td></tr><tr><td>reading</td><td>读取客户端的连接数.</td></tr><tr><td>writing</td><td>响应数据到客户端的数量</td></tr><tr><td>waiting</td><td>开启 keep-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.</td></tr></tbody></table><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nginx可以通过stub_status模块来查看服务器的状态信息。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://weizhimiao.github.io/categories/Nginx/"/>
    
    
    <category term="监控" scheme="https://weizhimiao.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM运行状态监控</title>
    <link href="https://weizhimiao.github.io/2016/09/27/PHP-FPM%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/"/>
    <id>https://weizhimiao.github.io/2016/09/27/PHP-FPM%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7/</id>
    <published>2016-09-27T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>PHP-FPM内置了一个运行状态页，开启后便可查看PHP-FPM的详细运行状态，可以给我们在优化PHP-FPM时带来帮助。</p><span id="more"></span><h2 id="php-fpm配置"><a href="#php-fpm配置" class="headerlink" title="php-fpm配置"></a>php-fpm配置</h2><p>查看php-fpm配置文件</p><pre><code>$ /usr/local/php56/sbin/php-fpm -t[27-Sep-2016 14:59:06] NOTICE: configuration file /usr/local/php56/etc/php-fpm.conf test is successful</code></pre><p>开启php-fpm的status配置</p><pre><code>vi /usr/local/php56/etc/php-fpm.conf</code></pre><p>修改加入：</p><pre><code>pm.status_path = /phpfpm_status</code></pre><p>配置文件中相关的说明</p><pre><code>; The URI to view the FPM status page. If this value is not set, no URI will be; recognized as a status page. It shows the following informations:;   pool                 - the name of the pool;;   process manager      - static, dynamic or ondemand;;   start time           - the date and time FPM has started;;   start since          - number of seconds since FPM has started;;   accepted conn        - the number of request accepted by the pool;;   listen queue         - the number of request in the queue of pending;                          connections (see backlog in listen(2));;   max listen queue     - the maximum number of requests in the queue;                          of pending connections since FPM has started;;   listen queue len     - the size of the socket queue of pending connections;;   idle processes       - the number of idle processes;;   active processes     - the number of active processes;;   total processes      - the number of idle + active processes;;   max active processes - the maximum number of active processes since FPM;                          has started;;   max children reached - number of times, the process limit has been reached,;                          when pm tries to start more children (works only for;                          pm &#39;dynamic&#39; and &#39;ondemand&#39;);; Value are updated in real time.; Value are updated in real time.; Example output:;   pool:                 www;   process manager:      static;   start time:           01/Jul/2011:17:53:49 +0200;   start since:          62636;   accepted conn:        190460;   listen queue:         0;   max listen queue:     1;   listen queue len:     42;   idle processes:       4;   active processes:     11;   total processes:      15;   max active processes: 12;   max children reached: 0;; By default the status page output is formatted as text/plain. Passing either; &#39;html&#39;, &#39;xml&#39; or &#39;json&#39; in the query string will return the corresponding; output syntax. Example:;   http://www.foo.bar/status;   http://www.foo.bar/status?json;   http://www.foo.bar/status?html;   http://www.foo.bar/status?xml;; By default the status page only outputs short status. Passing &#39;full&#39; in the; query string will also return status for each pool process.; Example:;   http://www.foo.bar/status?full;   http://www.foo.bar/status?json&amp;full;   http://www.foo.bar/status?html&amp;full;   http://www.foo.bar/status?xml&amp;full; The Full status returns for each process:; The Full status returns for each process:;   pid                  - the PID of the process;;   state                - the state of the process (Idle, Running, ...);;   start time           - the date and time the process has started;;   start since          - the number of seconds since the process has started;;   requests             - the number of requests the process has served;;   request duration     - the duration in µs of the requests;;   request method       - the request method (GET, POST, ...);;   request URI          - the request URI with the query string;;   content length       - the content length of the request (only with POST);;   user                 - the user (PHP_AUTH_USER) (or &#39;-&#39; if not set);;   script               - the main script called (or &#39;-&#39; if not set);;   last request cpu     - the %cpu the last request consumed;                          it&#39;s always 0 if the process is not in Idle state;                          because CPU calculation is done when the request;                          processing has terminated;;   last request memory  - the max amount of memory the last request consumed;                          it&#39;s always 0 if the process is not in Idle state;                          because memory calculation is done when the request;                          processing has terminated;; If the process is in Idle state, then informations are related to the; last request the process has served. Otherwise informations are related to; the current request being served.; Example output:;   ************************;   pid:                  31330;   state:                Running;   start time:           01/Jul/2011:17:53:49 +0200;   start since:          63087;   requests:             12808;   request duration:     1250261;   request method:       GET;   request URI:          /test_mem.php?N=10000;   content length:       0;   user:                 -;   script:               /home/fat/web/docs/php/test_mem.php;   last request cpu:     0.00;   last request memory:  0;; Note: There is a real-time FPM status monitoring sample web page available;       It&#39;s available in: /usr/local/php56/share/php/fpm/status.html;; Note: The value must start with a leading slash (/). The value can be;       anything, but it may not be a good idea to use the .php extension or it;       may conflict with a real PHP file.; Default Value: not setpm.status_path = /phpfpm_status</code></pre><h2 id="重启PHP-FPM"><a href="#重启PHP-FPM" class="headerlink" title="重启PHP-FPM"></a>重启PHP-FPM</h2><pre><code>kill -USR2 `cat /usr/local/php56/var/run/php-fpm.pid`</code></pre><h2 id="配置nginx代理"><a href="#配置nginx代理" class="headerlink" title="配置nginx代理"></a>配置nginx代理</h2><p>查看nginx配置文件</p><pre><code>/usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</code></pre><p>修改配置</p><pre><code>vi /usr/local/nginx/conf/nginx.conf</code></pre><p>加入：</p><pre><code>location /phpfpm_status &#123;        fastcgi_pass  127.0.0.1:9000;        include fastcgi_params;        fastcgi_param SCRIPT_FILENAME $fastcgi_script_name;&#125;</code></pre><p>重启nginx</p><pre><code>/usr/local/nginx/sbin/nginx -s reload</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器或者通过curl访问</p><p><a href="http://127.0.0.1/phpfpm_status">http://you-server-ip/phpfpm_status</a></p><pre><code>[root@iZwz9g8nzni5lj69dhlesoZ ~]# curl 127.0.0.1/phpfpm_statuspool:                 wwwprocess manager:      dynamicstart time:           27/Sep/2016:15:08:57 +0800start since:          385accepted conn:        3listen queue:         0max listen queue:     0listen queue len:     128idle processes:       1active processes:     1total processes:      2max active processes: 1max children reached: 0slow requests:        0</code></pre><ul><li>参数说明：</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pool</td><td>fpm池子名称，大多数为www</td></tr><tr><td>process manager</td><td>进程管理方式,值：static, dynamic or ondemand. dynamic</td></tr><tr><td>start time</td><td>启动日期,如果reload了php-fpm，时间会更新</td></tr><tr><td>start since</td><td>运行时长</td></tr><tr><td>accepted conn</td><td>当前池子接受的请求数</td></tr><tr><td>listen queue</td><td>请求等待队列，如果这个值不为0，那么要增加FPM的进程数量</td></tr><tr><td>max listen queue</td><td>请求等待队列最高的数量</td></tr><tr><td>listen queue len</td><td>socket等待队列长度</td></tr><tr><td>idle processes</td><td>空闲进程数量</td></tr><tr><td>active processes</td><td>活跃进程数量</td></tr><tr><td>total processes</td><td>总进程数量</td></tr><tr><td>max active processes</td><td>最大的活跃进程数量（FPM启动开始算）</td></tr><tr><td>max children reached</td><td>大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。</td></tr><tr><td>slow requests</td><td>启用了php-fpm slow-log，缓慢请求的数量</td></tr></tbody></table><ul><li>php-fpm还提供不同格式的输入，方便我们查看和与其他监控系统对接。</li></ul><pre><code>http://www.foo.bar/status       #默认纯文本http://www.foo.bar/status?json  #json格式http://www.foo.bar/status?html  #htmlhttp://www.foo.bar/status?xml   #xml</code></pre><ul><li>通过增加full参数，php-fpm还提供查看所有进程的运行状况</li></ul><pre><code>http://www.foo.bar/status?full        #默认纯文本http://www.foo.bar/status?json&amp;full   #json格式http://www.foo.bar/status?html&amp;full   #htmlhttp://www.foo.bar/status?xml&amp;full    #xml</code></pre><p>示例：</p><pre><code>curl &#39;http://127.0.0.1/phpfpm_status?full&#39;pool:                 wwwprocess manager:      dynamicstart time:           27/Sep/2016:15:08:57 +0800start since:          1546accepted conn:        14listen queue:         0max listen queue:     0listen queue len:     128idle processes:       1active processes:     1total processes:      2max active processes: 1max children reached: 0slow requests:        0************************pid:                  12132state:                Runningstart time:           27/Sep/2016:15:08:57 +0800start since:          1546requests:             7request duration:     117request method:       GETrequest URI:          /phpfpm_status?fullcontent length:       0user:                 -script:               /phpfpm_statuslast request cpu:     0.00last request memory:  0************************pid:                  12133state:                Idlestart time:           27/Sep/2016:15:08:57 +0800start since:          1546requests:             7request duration:     132request method:       GETrequest URI:          /phpfpm_status?html&amp;fullcontent length:       0user:                 -script:               /phpfpm_statuslast request cpu:     0.00last request memory:  262144</code></pre><p>具体进程参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>pid</td><td>进程号</td></tr><tr><td>state</td><td>状态（Idle - 闲置， Running - 运行， …）</td></tr><tr><td>start time</td><td>进程开始运行时间</td></tr><tr><td>start since</td><td>进程开始持续时间（单位：秒）</td></tr><tr><td>requests</td><td>进程已经处理的请求数</td></tr><tr><td>request duration</td><td>µs的请求数量</td></tr><tr><td>request method</td><td>请求方式（GET, POST, …）</td></tr><tr><td>request URI</td><td>请求URI</td></tr><tr><td>content length</td><td>请求内容长度（仅限POST请求）</td></tr><tr><td>user</td><td>PHP_AUTH_USER （’-‘， 表示没有限制）</td></tr><tr><td>script</td><td>请求文件</td></tr><tr><td>last request cpu</td><td>最后一次请求占用CPU百分比（如果进程不是处于 <code>Idle - 闲置</code> 状态，该值总是0，因为当请求处理终止时，CPU计算已经完成）</td></tr><tr><td>last request memory</td><td>最后一次请求占用内存（如果进程不是处于 <code>Idle - 闲置</code> 状态，该值总是0，因为当请求处理终止时，memory计算已经完成）</td></tr></tbody></table><p><strong>Tips:</strong><br>如果进程处于 idle 状态，所显示的信息就是基于最后一次请求给出的状态，否则就是基于本次请求的状态。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PHP-FPM内置了一个运行状态页，开启后便可查看PHP-FPM的详细运行状态，可以给我们在优化PHP-FPM时带来帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="PHP-FPM" scheme="https://weizhimiao.github.io/tags/PHP-FPM/"/>
    
    <category term="监控" scheme="https://weizhimiao.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装与管理</title>
    <link href="https://weizhimiao.github.io/2016/09/27/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/27/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2016-09-27T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>redis是一个key-value存储系统。<br>和Memcached类似，它支持存储的value类型相对更多，<br>包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。<br>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p>在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。<br>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。<br> redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。<br>它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p><ul><li><p>Memcache</p><blockquote><p>内存缓存服务，缓存数据保存在内存中，一旦断电重启，数据将丢失</p></blockquote></li><li><p>mangoDB</p><blockquote><p>开源免费的NOSQL 数据库，提供数据持久化服务，以文档的形式提供数据组织方式，而不是表</p></blockquote></li><li><p>Redis</p><blockquote><p>开源免费的 NOSQL数据库，提供数据持久化服务，即能实现内存缓存服务，也能提供数据结构服务取代MySQL 自建索引用来弥补关系型数据的不足</p></blockquote></li></ul><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="默认安装位置"><a href="#默认安装位置" class="headerlink" title="默认安装位置"></a>默认安装位置</h3><pre><code>[root@localhost ~]# wget http://download.redis.io/releases/redis-2.8.6.tar.gz[root@localhost ~]# tar xzf redis-2.8.6.tar.gz[root@localhost ~]# cd redis-2.8.6[root@localhost ~]# make#不指定安装位置，则会把redis的可执行文件安装到  redis-2.8.6/src/目录下</code></pre><h3 id="指定安装位置"><a href="#指定安装位置" class="headerlink" title="指定安装位置"></a>指定安装位置</h3><pre><code>[root@localhost ~]# tar xzf redis-2.8.6.tar.gz[root@localhost ~]# cd redis-2.8.6[root@localhost ~]# make[root@localhost ~]# make PREFIX=/usr/local/redis install#指定安装位置，如果没有指定安装位置PREFIX=/usr/local/redis，则make install会把redis安装到/usr/local/bin/目录下[root@localhost ~]# mkdir /usr/local/redis/etc[root@localhost ~]# cp /root/redis-2.8.6/redis.conf /usr/local/redis/etc/</code></pre><h3 id="安装的可执行文件的作用"><a href="#安装的可执行文件的作用" class="headerlink" title="安装的可执行文件的作用"></a>安装的可执行文件的作用</h3><pre><code>redis-server               服务器端redis-cli                  客户端redis-benchmark           调试redis-check-dump          数据导出redis-check-aof            数据导入</code></pre><h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>路径</p><pre><code>/redis-server</code></pre><p>配置文件</p><pre><code>/usr/local/redis/bin/redis-server  /usr/local/redis/etc/redis.conf</code></pre><p>注意：需要修改配置文件</p><pre><code>[root@localhost redis]# vi /usr/local/redis/etc/redis.confdaemonize no        改为daemonize yes        #后台启动</code></pre><p>端口 6379</p><pre><code>[root@localhost redis]# /usr/local/redis/bin/redis-cli#客户端连接    -h  IP    ：        连接指定的redis服务器    -p  6379：        指定redis服务器的端口    -a  密码：        使用密码登录    -n 数据库号：    指定连接哪个数据库</code></pre><h3 id="关闭redis"><a href="#关闭redis" class="headerlink" title="关闭redis"></a>关闭redis</h3><pre><code>[root@localhost ~]# /usr/local/redis/bin/redis-cli shutdown</code></pre><p>或</p><pre><code>[root@localhost ~]# pkill  -9 redis</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>[root@localhost redis]# vi /usr/local/redis/etc/redis.conf#是否以后台进程运行，默认为no，如果需要以后台进程运行则改为yesdaemonize no#如果以后台进程运行的话，就需要指定pid，你可以在此自定义redis.pid文件的位置。pidfile /var/run/redis.pid#接受连接的端口号，如果端口是0则redis将不会监听TCP socket连接port 6379# If you want you can bind a single interface, if the bind option is not# specified all the interfaces will listen for incoming connections.## bind 127.0.0.1# Specify the path for the unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 755#连接超时时间，单位秒。(0 to disable)？timeout 300000000#日志级别，默认是verbose（详细），各种日志级别：#debug:很详细的信息，适合开发和测试#verbose:包含许多不太有用的信息，但比debug要清爽一些（many rarely useful info, but not a mess like #the debug level）#notice:比较适合生产环境#warning:警告信息loglevel verbose#指定log文件的名字，默认是空。stdout会让redis把日志输出到标准输出。但是如果使用stdout而又以后台进#程的方式运行redis，则日志会输出到/dev/null。请改为需要的日志名logfile  &quot;&quot;#&#39;syslog-enabled&#39;设置为yes会把日志输出到系统日志，默认是no# syslog-enabled no#指定syslog的标示符，如果&#39;syslog-enabled&#39;是no，则这个选项无效。# syslog-ident redis#指定syslog 设备（facility), 必须是USER或者LOCAL0到LOCAL7.# syslog-facility local0#设置数据库数目。默认的数据库是DB 0。可以通过SELECT &lt;dbid&gt;来选择一个数据库，dbid是[0,&#39;databases&#39;-1]的数字databases 16################## 快照################################### 硬盘上保存数据:##   save &lt;seconds&gt; &lt;changes&gt;##   &lt;seconds&gt;和&lt;changes&gt;都满足时就会触发数据保存动作。#   ##   以下面的例子来说明：#   过了900秒并且有1个key发生了改变 就会触发save动作#   过了300秒并且有10个key发生了改变 就会触发save动作#   过了60秒并且至少有10000个key发生了改变 也会触发save动作##   注意：如果你不想让redis自动保存数据，那就把下面的配置注释掉！save 900 1save 300 10save 60 10000#存储数据时是否压缩数据。默认是yes。rdbcompression yes# 保存dump数据的文件名dbfilename dump.rdb# 工作目录.## 数据会被持久化到这个目录下的‘dbfilename’指定的文件中。### 注意，这里指定的必须是目录而不能是文件。dir ./######## REPLICATION（复制，冗余）################################## Master-Slave replication. 使用slaveof把一个 Redis 实例设置成为另一个Redis server的从库（热备）. 注意： #配置只对当前slave有效。# 因此可以把某个slave配置成使用不同的时间间隔来保存数据或者监听其他端口等等。#命令格式：# slaveof &lt;masterip&gt; &lt;masterport&gt;#如果master有密码保护，则在slave与master进行数据同步之前需要进行密码校验，否则master会拒绝slave的请#求。## masterauth &lt;master-password&gt;#当slave丢失与master的连接时，或者slave仍然在于master进行数据同步时（还没有与master保持一致），#slave可以有两种方式来响应客户端请求：## 1) 如果 slave-serve-stale-data 设置成 &#39;yes&#39; (the default) slave会仍然响应客户端请求,此时可能会有问题。## 2) 如果 slave-serve-stale data设置成  &#39;no&#39;  slave会返回&quot;SYNC with master in progress&quot;这样的错误信息。 但 INFO 和SLAVEOF命令除外。#slave-serve-stale-data yes############### 安全 #################################### 需要客户端在执行任何命令之前指定 AUTH &lt;PASSWORD&gt;## requirepass foobared# 命令重命名.### 例如:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## 同样可以通过把一个命令重命名为空串来彻底kill掉这个命令，比如：## rename-command CONFIG &quot;&quot;#################### 限制 ##################################### 设置最大连接数. 默认没有限制,  &#39;0&#39; 意味着不限制.## maxclients 128#最大可使用内存。如果超过，Redis会试图删除EXPIRE集合中的keys，具体做法是：Redis会试图释放即将过期的#keys，而保护还有很长生命周期的keys。##如果这样还不行，Redis就会报错，但像GET之类的查询请求还是会得到响应。##警告：如果你想把Redis视为一个真正的DB的话，那不要设置&lt;maxmemory&gt;,只有你只想把Redis作为cache或者#有状态的server（&#39;state&#39; server)时才需要设置。## maxmemory &lt;bytes&gt;#内存清理策略：如果达到了maxmemory，你可以采取如下动作：## volatile-lru -&gt; 使用LRU算法来删除过期的set# allkeys-lru -&gt; 删除任何遵循LRU算法的key# volatile-random -&gt;随机地删除过期set中的key# allkeys-&gt;random -&gt; 随机地删除一个key# volatile-ttl -&gt; 删除最近即将过期的key（the nearest expire time (minor TTL)）# noeviction -&gt; 根本不过期，写操作直接报错### 默认策略:## maxmemory-policy volatile-lru# 对于处理redis内存来说，LRU和minor TTL算法不是精确的，而是近似的（估计的）算法。所以我们会检查某些样本#来达到内存检查的目的。默认的样本数是3，你可以修改它。## maxmemory-samples 3################# APPEND ONLY MODE ################################默认情况下，Redis会异步的把数据保存到硬盘。如果你的应用场景允许因为系统崩溃等极端情况而导致最新数据丢失#的话，那这种做法已经很ok了。否则你应该打开‘append only’模式，开启这种模式后，Redis会在#appendonly.aof文件中添加每一个写操作，这个文件会在Redis启动时被读取来在内存中重新构建数据集。##注意：如果你需要，你可以同时开启‘append only’模式和异步dumps模式（你需要注释掉上面的‘save’表达式来禁#止dumps），这种情况下，Redis重建数据集时会优先使用appendonly.aof而忽略dump.rdb#appendonly no#  append only 文件名 (默认: &quot;appendonly.aof&quot;)# appendfilename appendonly.aof# 调用fsync()函数通知操作系统立刻向硬盘写数据## Redis支持3中模式:## no:不fsync, 只是通知OS可以flush数据了，具体是否flush取决于OS.性能更好.# always: 每次写入append only 日志文件后都会fsync . 性能差，但很安全.# everysec: 没间隔1秒进行一次fsync. 折中.## 默认是 &quot;everysec&quot;# appendfsync alwaysappendfsync everysec# appendfsync no# 当AOF fsync策略被设置为always或者everysec并且后台保存进程（saving process)正在执行大量I/O操作时# Redis可能会在fsync()调用上阻塞过长时间#no-appendfsync-on-rewrite no# append only 文件的自动重写# 当AOF 日志文件即将增长到指定百分比时，Redis可以通过调用BGREWRITEAOF 来自动重写append only文件。## 它是这么干的：Redis会记住最近一次重写后的AOF 文件size。然后它会把这个size与当前size进行比较，如果当前# size比指定的百分比大，就会触发重写。同样，你需要指定AOF文件被重写的最小size，这对避免虽然百分比达到了# 但是实际上文件size还是很小（这种情况没有必要重写）却导致AOF文件重写的情况很有用。### auto-aof-rewrite-percentage 设置为 0 可以关闭AOF重写功能auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################## SLOW LOG #################################### Redis slow log用来记录超过指定执行时间的查询。## 你可以指定两个参数：一个是慢查询的阀值，单位是毫秒；另外一个是slow log的长度，相当于一个队列。# 负数则关闭slow log，0则会导致每个命令都被记录slowlog-log-slower-than 10000# 不设置会消耗过多内存，所以还是要设置一下。可以使用SLOWLOG RESET命令来回收slow log使用的内存slowlog-max-len 1024################ 虚拟内存 ################################使用redis 就别用虚拟内存了，绝对不是一个好主意，加个机器吧，所以这里不翻译啦！！### WARNING! Virtual Memory is deprecated in Redis 2.4### The use of Virtual Memory is strongly discouraged.# Virtual Memory allows Redis to work with datasets bigger than the actual# amount of RAM needed to hold the whole dataset in memory.# In order to do so very used keys are taken in memory while the other keys# are swapped into a swap file, similarly to what operating systems do# with memory pages.## To enable VM just set &#39;vm-enabled&#39; to yes, and set the following three# VM parameters accordingly to your needs.vm-enabled no# vm-enabled yes# This is the path of the Redis swap file. As you can guess, swap files# can&#39;t be shared by different Redis instances, so make sure to use a swap# file for every redis process you are running. Redis will complain if the# swap file is already in use.## The best kind of storage for the Redis swap file (that&#39;s accessed at random)# is a Solid State Disk (SSD).## *** WARNING *** if you are using a shared hosting the default of putting# the swap file under /tmp is not secure. Create a dir with access granted# only to Redis user and configure Redis to create the swap file there.vm-swap-file /tmp/redis.swap# vm-max-memory configures the VM to use at max the specified amount of# RAM. Everything that deos not fit will be swapped on disk *if* possible, that# is, if there is still enough contiguous space in the swap file.## With vm-max-memory 0 the system will swap everything it can. Not a good# default, just specify the max amount of RAM you can in bytes, but it&#39;s# better to leave some margin. For instance specify an amount of RAM# that&#39;s more or less between 60 and 80% of your free RAM.vm-max-memory 0# Redis swap files is split into pages. An object can be saved using multiple# contiguous pages, but pages can&#39;t be shared between different objects.# So if your page is too big, small objects swapped out on disk will waste# a lot of space. If you page is too small, there is less space in the swap# file (assuming you configured the same number of total swap file pages).## If you use a lot of small objects, use a page size of 64 or 32 bytes.# If you use a lot of big objects, use a bigger page size.# If unsure, use the default :)vm-page-size 32# Number of total memory pages in the swap file.# Given that the page table (a bitmap of free/used pages) is taken in memory,# every 8 pages on disk will consume 1 byte of RAM.## The total swap size is vm-page-size * vm-pages## With the default of 32-bytes memory pages and 134217728 pages Redis will# use a 4 GB swap file, that will use 16 MB of RAM for the page table.## It&#39;s better to use the smallest acceptable value for your application,# but the default is large in order to work in most conditions.vm-pages 134217728# Max number of VM I/O threads running at the same time.# This threads are used to read/write data from/to swap file, since they# also encode and decode objects from disk to memory or the reverse, a bigger# number of threads can help with big objects even if they can&#39;t help with# I/O itself as the physical device may not be able to couple with many# reads/writes operations at the same time.## The special value of 0 turn off threaded I/O and enables the blocking# Virtual Memory implementation.vm-max-threads 4################高级配置################################ Hashes are encoded in a special way (much more memory efficient) when they# have at max a given numer of elements, and the biggest element does not# exceed a given threshold. You can configure this limits with the following# configuration directives.hash-max-zipmap-entries 512hash-max-zipmap-value 64# Similarly to hashes, small lists are also encoded in a special way in order# to save a lot of space. The special representation is only used when# you are under the following limits:list-max-ziplist-entries 512list-max-ziplist-value 64# Sets have a special encoding in just one case: when a set is composed# of just strings that happens to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into an hash table# that is rhashing, the more rehashing &quot;steps&quot; are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.## The default is to use this millisecond 10 times every second in order to# active rehashing the main dictionaries, freeing memory when possible.## If unsure:# use &quot;activerehashing no&quot; if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply form time to time# to queries with 2 milliseconds delay.## use &quot;activerehashing yes&quot; if you don&#39;t have such hard requirements but# want to free memory asap when possible.activerehashing yes################## INCLUDES #################################### Include one or more other config files here.  This is useful if you# have a standard template that goes to all redis server but also need# to customize a few per-server settings.  Include files can include# other files, so use this wisely.## include /path/to/local.conf# include /path/to/other.conf</code></pre><h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><h3 id="键值相关命令"><a href="#键值相关命令" class="headerlink" title="键值相关命令"></a>键值相关命令</h3><p>1、 keys  键名</p><blockquote><p>按照键名查找指定的键。支持通配符</p></blockquote><pre><code>127.0.0.1:6379&gt; set hello 1OK127.0.0.1:6379&gt; set hallo 1OK127.0.0.1:6379&gt; set heeeello 1OK127.0.0.1:6379&gt; keys h?llo1) &quot;hallo&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; keys h*llo1) &quot;hallo&quot;2) &quot;heeeello&quot;3) &quot;hello&quot;</code></pre><p>2、    exists  键名</p><blockquote><p>   确认一个键是否存在</p></blockquote><pre><code>127.0.0.1:6379&gt; EXISTS name(integer) 1                        //name键存在127.0.0.1:6379&gt; EXISTS age(integer) 0                        //age键不存在</code></pre><p>3、    del  键名</p><blockquote><p>   删除一个键</p></blockquote><pre><code>127.0.0.1:6379&gt; del hello(integer) 1127.0.0.1:6379&gt; EXISTS hello(integer) 0</code></pre><p>4、    expire  键  秒</p><blockquote><p>   设置一个键的过期时间，如果键已经过期，将会被自动删除</p></blockquote><pre><code>127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; EXPIRE age 20(integer) 1127.0.0.1:6379&gt; ttl age(integer) 18127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; EXISTS age(integer) 0</code></pre><p>5、    ttl  键</p><blockquote><p>   以秒为单位，返回键的剩余生存时间。</p><p>   当键不存在时，返回值为-2</p><p>   当键存在，但没有设置剩余生存时间时，返回-1</p></blockquote><pre><code>127.0.0.1:6379&gt; ttl name(integer) -1</code></pre><p>6、    select  数据库号</p><blockquote><p>   选择一个数据库。<br>   默认连接的数据库是0，可以支持共16个数据库。<br>   在配置文件中，通过databases 16 关键字定义</p></blockquote><pre><code>127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt;</code></pre><p>7、    move  键  数据库号</p><blockquote><p>   将当前数据库的键移动到指定的数据空中</p></blockquote><pre><code>127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; move age 1(integer) 1127.0.0.1:6379&gt; get age(nil)127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get age&quot;18&quot;</code></pre><p>8、    randomkey  </p><blockquote><p>   从当前数据库返回一个随机的键。如果当前库没有任何键，则返回nil</p></blockquote><p>9、    rename  旧名  新名</p><blockquote><p>   重命名键</p></blockquote><pre><code>127.0.0.1:6379&gt; rename name name_newOK127.0.0.1:6379&gt; get name_new&quot;sc&quot;</code></pre><p>10、 type  键</p><blockquote><pre><code>返回键类型。</code></pre></blockquote><p>返回值</p><ul><li>none (key不存在)</li><li>string (字符串)</li><li>list (列表)</li><li>set (集合)</li><li>zset (有序集)</li><li>hash (哈希表)</li></ul><h3 id="服务器相关命令"><a href="#服务器相关命令" class="headerlink" title="服务器相关命令"></a>服务器相关命令</h3><p>1、    ping</p><blockquote><p>   测试服务器是否可以连接</p></blockquote><pre><code>127.0.0.1:6379&gt; pingPONG                    //连接正常127.0.0.1:6379&gt; pingCould not connect to Redis at 127.0.0.1:6379: Connection refused//redis被停止，连接拒绝</code></pre><p>2、    echo  字符串</p><blockquote><p>   在命令行输出字符串</p></blockquote><pre><code>127.0.0.1:6379&gt; echo &quot;test message&quot;&quot;test message&quot;</code></pre><p>3、    quit</p><blockquote><p>   退出redis数据库</p></blockquote><p>4、    save</p><blockquote><p>   保存所有的数据。很少在生产环境直接使用SAVE 命令，因为它会阻塞所有的客户端的请求，可以使用BGSAVE 命令代替. 如果在BGSAVE命令的保存数据的子进程发生错误的时,用 SAVE命令保存最新的数据是最后的手段</p></blockquote><p>5、    dbsize</p><blockquote><p>   返回当前库中键的数量</p></blockquote><pre><code>127.0.0.1:6379&gt; dbsize(integer) 6</code></pre><p>6、    info</p><blockquote><p>   获取服务器的详细信息</p></blockquote><p>7、    config get 参数</p><blockquote><p>   获取redis服务器配置文件中的参数。支持通配符</p></blockquote><pre><code>127.0.0.1:6379&gt; config get *            //查询配置文件中所有的参数  1) &quot;dbfilename&quot;  2) &quot;dump.rdb&quot; 45) &quot;port&quot; 46) &quot;6379&quot; 99) &quot;save&quot; 100) &quot;900 1 300 10 60 10000&quot;</code></pre><p>8、 flushdb</p><blockquote><p>   删除当前数据库中所有的数据</p></blockquote><pre><code>127.0.0.1:6379&gt; dbsize(integer) 6127.0.0.1:6379&gt; flushdbOK127.0.0.1:6379&gt; dbsize(integer) 0</code></pre><p>9、    flushall</p><blockquote><pre><code>删除所有数据库中所有的数据</code></pre></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;redis是一个key-value存储系统。&lt;br&gt;和Memcached类似，它支持存储的value类型相对更多，&lt;br&gt;包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。&lt;br&gt;这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。&lt;/p&gt;
&lt;p&gt;在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。&lt;br&gt;区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/p&gt;
&lt;p&gt;Redis 是一个高性能的key-value数据库。&lt;br&gt; redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。&lt;br&gt;它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memcache&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存缓存服务，缓存数据保存在内存中，一旦断电重启，数据将丢失&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mangoDB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开源免费的NOSQL 数据库，提供数据持久化服务，以文档的形式提供数据组织方式，而不是表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开源免费的 NOSQL数据库，提供数据持久化服务，即能实现内存缓存服务，也能提供数据结构服务取代MySQL 自建索引用来弥补关系型数据的不足&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型与操作</title>
    <link href="https://weizhimiao.github.io/2016/09/27/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    <id>https://weizhimiao.github.io/2016/09/27/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%93%8D%E4%BD%9C/</id>
    <published>2016-09-27T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>Redis共有5种数据类型</p><ul><li>string(字符串)</li><li>hash(哈希表)</li><li>list(双向队列)</li><li>set(集合)</li><li>zset(有序集合)</li></ul><span id="more"></span><h2 id="String（子串类型）"><a href="#String（子串类型）" class="headerlink" title="String（子串类型）"></a>String（子串类型）</h2><p>String是最简单的类型，一个Key对应一个Value，string类型是二进制安全的。Redis的string可以包含任何数据，比如jpg图片或者序列化的对象。</p><ol><li>set 键  “值”<blockquote><p>设置一个键和值，键存在则覆盖，返回ok</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; set name limingOK</code></pre><ol start="2"><li>get 键<blockquote><p>获取一个键的值，返回值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; get name&quot;liming&quot;</code></pre><ol start="3"><li>setnx 键 值<blockquote><p>只有当该键不存在时设置一个键的值，若键已存在则返回0表示失败（防止覆盖），</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; setnx age 18(integer) 1127.0.0.1:6379&gt; setnx age 18(integer) 0</code></pre><ol start="4"><li> setex 键 [有效时间] 值<blockquote><p>设置一个指定有效期的键和值（单位秒）。不写有效时间则表示永久有效，等价于set</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; setex movie 30 canglaoshiOK127.0.0.1:6379&gt; ttl movie                //获取键的有效时间(integer) 26127.0.0.1:6379&gt; ttl movie(integer) 20127.0.0.1:6379&gt; get movie&quot;canglaoshi&quot;127.0.0.1:6379&gt; ttl movie(integer) -2127.0.0.1:6379&gt; get movie(nil)</code></pre><ol start="4"><li>ttl 键<blockquote><p>以秒为单位，返回给定 key 的剩余生存时间</p><ul><li>当 key 不存在时，返回 -2 。<ul><li>   当 key 存在但没有设置剩余生存时间时，返回 -1 。</li><li>   否则，以秒为单位，返回 key 的剩余生存时间。</li></ul></li></ul></blockquote></li></ol><ol start="5"><li>setrange 键 位置 子字串<blockquote><p>替换子字符串 (替换长度由子子串长度决定)</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; set key1 &quot;hello world&quot;OK127.0.0.1:6379&gt; get key1&quot;hello world&quot;127.0.0.1:6379&gt; setrange key1 6 liming(integer) 12127.0.0.1:6379&gt; get key1&quot;hello liming&quot;    #将key1键对应值的第6个位置开始替换（字符串位置从0开始计算）</code></pre><ol start="6"><li>mset 键1 值1 键2 值2 键3 值3 ….<blockquote><p>批量设置键和值,成功则返回ok</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; mset name1 lm name2 sc name3 zjjOK</code></pre><ol start="7"><li>mget 键1 键2 键3….<blockquote><p>批量获取值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; mget name1 name2 name31) &quot;lm&quot;2) &quot;sc&quot;3) &quot;zjj&quot;</code></pre><ol start="8"><li>msetnx 键1 值1 键2 值2 键3 值3 ….<blockquote><p>批量设置不存在的键和值,成功则返回ok</p></blockquote></li></ol><ol start="9"><li>getset 键 新值<blockquote><p>获取原值，并设置新值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; set name &quot;shen chao&quot;OK127.0.0.1:6379&gt; get name&quot;shen chao&quot;127.0.0.1:6379&gt; getset name &quot;liming&quot;&quot;shen chao&quot;127.0.0.1:6379&gt; get name&quot;liming&quot;</code></pre><ol start="10"><li>getrange 键 0 4  <blockquote><p>获取指定范围的值（获取指定0到4位置上的值，字符串位置从0开始计算）</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; getrange key1 0 4&quot;hello&quot;</code></pre><ol start="11"><li>incr 键  <blockquote><p>指定键的值做加1操作，返回加后的结果（只能加数字）。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; set age 18OK127.0.0.1:6379&gt; incr age(integer) 19127.0.0.1:6379&gt; get age&quot;19&quot;</code></pre><ol start="12"><li>incrby 键 m    <blockquote><p>其中m可以是正整数或负整数.加指定值，键不存在时候会设置键</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; incrby age 10(integer) 29127.0.0.1:6379&gt; get age&quot;29&quot;127.0.0.1:6379&gt; incrby age -5(integer) 24</code></pre><ol start="13"><li>decr 键<blockquote><p>指定键的值做减1操作，返回减后的结果。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; decr age(integer) 23127.0.0.1:6379&gt; get age&quot;23&quot;</code></pre><ol start="14"><li>decrby 键 n<blockquote><p>其中n可以是正整数或负整数.设置某个键减上指定值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; decrby age 5(integer) 18127.0.0.1:6379&gt; decrby age -10(integer) 28127.0.0.1:6379&gt; get age&quot;28&quot;</code></pre><ol start="15"><li>append  键 追加字串<blockquote><p>给指定key的字符串追加value，返回新字符串值的长度</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; append name1 &quot; have a hot body!&quot;(integer) 19127.0.0.1:6379&gt; get name1&quot;lm have a hot body!&quot;</code></pre><ol start="16"><li>strlen 键名<blockquote><p>strlen求一个键长度</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; strlen name1(integer) 19</code></pre><ol start="17"><li>del命令：<blockquote><p>删除一个键</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; del name3(integer) 1127.0.0.1:6379&gt; get name3(nil)</code></pre><h2 id="hashs类型"><a href="#hashs类型" class="headerlink" title="hashs类型"></a>hashs类型</h2><blockquote><p>注意：redis中没有表概念，所有的数据都存入键中。</p><ul><li>string键类型：所有的值（可以是任何数据类型）都保存在一个键当中，放在一个内存块中<ul><li>hashs键类型：所有的值也都保存在一个键当中，只是放在不同的内存块中，每个块称作字段</li></ul></li></ul></blockquote><ol><li>hset key field value<blockquote><p>设置一个键，在键中保存字段和值<br>格式： hset 哈希集（键） 字段 值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hset user1 name4 ysm(integer) 1127.0.0.1:6379&gt; keys *                    //查看库中所有的键1) &quot;aa&quot;2) &quot;name&quot;3) &quot;name1&quot;4) &quot;user1&quot;5) &quot;name2&quot;6) &quot;age&quot;7) &quot;key1&quot;</code></pre><ol start="2"><li>hsetnx  键  字段  值<blockquote><p>   设置一个键中，不存在的字段和值。如果字段存在则报错（成功返回1，失败返回0）</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hsetnx user1 name1 lm(integer) 1127.0.0.1:6379&gt; hsetnx user1 name1 sc(integer) 0                    //报错127.0.0.1:6379&gt; hget user1 name1&quot;lm&quot;                        //内容没有更新</code></pre><ol start="3"><li>hmset  键  字段1  值1  字段2  值2 …<blockquote><p>   在一个键中，批量设置字段</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hmset user2 name liming age 36 interest AV-GirlOK</code></pre><ol start="4"><li>hget 键 字段<blockquote><p>   获取键中的一个指定字段的值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hget user1 name1&quot;lm&quot;127.0.0.1:6379&gt; hget user2 interest&quot;AV-Girl&quot;</code></pre><ol start="5"><li>hmget 键 字段1 [字段2…]<blockquote><p>   获取键中一个或多个字段的值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hmget user2 name age interest1) &quot;liming&quot;2) &quot;36&quot;3) &quot;AV-Girl&quot;</code></pre><ol start="6"><li>hexists ：<blockquote><p>判断指定的字段是否存在于键中</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; HEXISTS user2 age(integer) 1                            //存在127.0.0.1:6379&gt; HEXISTS user1 age(integer) 0                            //不存在</code></pre><ol start="7"><li>hlen ：获取键中的字段数量</li></ol><pre><code>127.0.0.1:6379&gt; hlen user2(integer) 3                            //user2键中有3个字段</code></pre><ol start="8"><li>hkeys ：获取键中的所有字段名</li></ol><pre><code>127.0.0.1:6379&gt; hkeys user21) &quot;name&quot;2) &quot;age&quot;3) &quot;interest&quot;</code></pre><ol start="9"><li>hvals：获取键中所有字段的值</li></ol><pre><code>127.0.0.1:6379&gt; hvals user21) &quot;liming&quot;2) &quot;36&quot;3) &quot;AV-Girl&quot;</code></pre><ol start="10"><li>hgetall ：获取键中的所有字段和值</li></ol><pre><code>127.0.0.1:6379&gt; hgetall user21) &quot;name&quot;2) &quot;liming&quot;3) &quot;age&quot;4) &quot;36&quot;5) &quot;interest&quot;6) &quot;AV-Girl&quot;</code></pre><ol start="11"><li>hincrby：将键中指定字段的值，增加指定的数字</li></ol><pre><code>127.0.0.1:6379&gt; hincrby user2 age 5(integer) 41127.0.0.1:6379&gt; HINCRBY user2 name 5(error) ERR hash value is not an integer    //值不是数字的字段，不能加数字</code></pre><ol start="12"><li>hdel 键 字段1 字段2<blockquote><p>   删除键中的一个或多个字段</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; hdel user2 age interest(integer) 2127.0.0.1:6379&gt; hkeys user21) &quot;name&quot;    //删除一个键，还是要使用del命令</code></pre><h2 id="list类型（双向链表结构）"><a href="#list类型（双向链表结构）" class="headerlink" title="list类型（双向链表结构）"></a>list类型（双向链表结构）</h2><p>List是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。列表允许有重复值</p><ol><li>lpush 键 值1 [值2…]<blockquote><p>从队列左边向队列写入一个或多个值（认为队列的左面为队列头，右边为队列尾）</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lpush list1 1(integer) 1127.0.0.1:6379&gt; lpush list1 2(integer) 2127.0.0.1:6379&gt; lpush list1 3(integer) 3127.0.0.1:6379&gt; lpush list1 4(integer) 4127.0.0.1:6379&gt; lpush list2 one two three four(integer) 4</code></pre><ol start="2"><li>lrange 键 起始下标 终止下标<blockquote><p>   从队列中获取指定的返回值（从队列左边向右获取）<br>下标：</p><ul><li>0代表队列中第一个元素，1代表第二个元素，依次类推</li><li>-1代表队列中最后一个元素，-2代表倒数第二个元素</li></ul></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; LRANGE list1 0 -11) &quot;4&quot;        //4是从左面写入队列的最后一个值，所以在队列的开头2) &quot;3&quot;3) &quot;2&quot;4) &quot;1&quot;        //1是从左面写入队列的第一个值，所以直接放到了队列尾。127.0.0.1:6379&gt; LRANGE list2 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; LRANGE list1 0 11) &quot;4&quot;2) &quot;3&quot;127.0.0.1:6379&gt; LRANGE list2 -4 31) &quot;four&quot;        //-4代表从队列右边数第四个元素2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;        //3代表从队列左边数第四个元素</code></pre><ol start="3"><li>rpush 键 值1 [值2…]<blockquote><p>   从队列右边向队列写入一个或多个值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; RPUSH list3 1 2 3 4(integer) 4127.0.0.1:6379&gt; LRANGE list3 0 -11) &quot;1&quot;        //从队列右边向队列写入值，第一个值就会写到队列的开头2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><ol start="4"><li>linsert  键  before|after  原值  新值<blockquote><p>   在队列中指定元素之前或之后插入新值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; LINSERT list3 before 3 hello(integer) 5127.0.0.1:6379&gt; LRANGE list3 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;hello&quot;4) &quot;3&quot;5) &quot;4&quot;</code></pre><ol start="5"><li>lset  键  下标  新值<blockquote><p>   给队列中指定元素设定新值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lset list3 2 &quot;5&quot;OK127.0.0.1:6379&gt; LRANGE list3 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;5&quot;4) &quot;3&quot;5) &quot;4&quot;</code></pre><ol start="6"><li>lerm  键  n  指定值<blockquote><p>从队列中删除n个值为“指定值”的元素</p><ul><li>n &gt; 0     从队列头向尾删除n个元素</li><li>n &lt; 0     从队列尾向头删除n个元素</li><li>n = 0    删除所有值为“指定值”的元素</li></ul></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; rpush list4 hello 1 hello 2 hello 3 hello(integer) 7127.0.0.1:6379&gt; lrange list4 0 -11) &quot;hello&quot;2) &quot;1&quot;3) &quot;hello&quot;4) &quot;2&quot;5) &quot;hello&quot;6) &quot;3&quot;7) &quot;hello&quot;127.0.0.1:6379&gt; lrem list4 -2 hello            //删除后两个hello(integer) 2127.0.0.1:6379&gt; lrange list4 0 -11) &quot;hello&quot;2) &quot;1&quot;3) &quot;hello&quot;4) &quot;2&quot;5) &quot;3&quot;127.0.0.1:6379&gt; lrem list4 0 hello            //删除所有hello(integer) 2127.0.0.1:6379&gt; lrange list4 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;</code></pre><ol start="7"><li>ltrim  键  起始下标  结束下标<blockquote><p>   修剪队列，让队列只保留指定指定范围内的元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; RPUSH list5 1 2 3 4(integer) 4127.0.0.1:6379&gt; ltrim list5 1 2OK127.0.0.1:6379&gt; lrange list5 0 -11) &quot;2&quot;2) &quot;3&quot;</code></pre><ol start="8"><li>lpop  键<blockquote><p>   从指定的队列左面移除一个值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lrange list1 0 -11) &quot;4&quot;2) &quot;3&quot;3) &quot;2&quot;4) &quot;1&quot;127.0.0.1:6379&gt; lpop list1&quot;4&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;</code></pre><ol start="9"><li>rpop  键<blockquote><p>   从指定队列的右边移除一个值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lrange list1 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; rpop list1&quot;1&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;3&quot;2) &quot;2&quot;</code></pre><ol start="10"><li>rpoplpush  源队列  目标队列<blockquote><p>   移除源队列的最后一个元素，并把该元素写入目标队列</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lrange list1 0 -11) &quot;3&quot;2) &quot;2&quot;127.0.0.1:6379&gt; lrange list5 0 -11) &quot;2&quot;2) &quot;3&quot;127.0.0.1:6379&gt; RPOPLPUSH list1 list5&quot;2&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;3&quot;127.0.0.1:6379&gt; lrange list5 0 -11) &quot;2&quot;2) &quot;2&quot;3) &quot;3&quot;</code></pre><ol start="11"><li>lindex  键  下标<blockquote><p>   获取队列中指定下标元素的值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; lrange list2 0 -11) &quot;four&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lindex list2 1&quot;three&quot;127.0.0.1:6379&gt; lindex list2 3&quot;one&quot;</code></pre><ol start="12"><li>llen  键<blockquote><p>   获得队列的长度</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; llen list2(integer) 4</code></pre><h2 id="sets类型和操作"><a href="#sets类型和操作" class="headerlink" title="sets类型和操作"></a>sets类型和操作</h2><p>Set是集合，它是string类型的无序集合。对集合我们可以取并集、交集、差集。通过这些操作我们可以实现社交网站中的好友推荐和blog的tag功能。集合不允许有重复值。</p><ol><li>sadd  键  值1[值2…]<blockquote><p>   添加一个或多个元素到集合中</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sadd mset1 1(integer) 1127.0.0.1:6379&gt; sadd mset1 2 3 4(integer) 3</code></pre><ol start="2"><li>smembers  键<blockquote><p>   获取集合里面所有的元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; smembers mset11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><ol start="3"><li>srem  键  值1[值2…]<blockquote><p>   从集合中删除指定的一个或多个元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; srem mset1 3 4(integer) 2127.0.0.1:6379&gt; smembers mset11) &quot;1&quot;2) &quot;2&quot;（删除键，依然使用“del 键” 命令）</code></pre><ol start="4"><li>spop  键  <blockquote><p>   随机从集合中删除一个元素，并返回</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sadd mset2 4 5 6 7 8(integer) 5127.0.0.1:6379&gt; spop mset2&quot;4&quot;127.0.0.1:6379&gt; spop mset2&quot;5&quot;127.0.0.1:6379&gt; spop mset2&quot;8&quot;127.0.0.1:6379&gt; smembers mset21) &quot;6&quot;2) &quot;7&quot;</code></pre><ol start="5"><li>srandmember  键  值<blockquote><p>   随机返回集合中一个元素，但不删除</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sadd mset3 4 5 6 7 8(integer) 5127.0.0.1:6379&gt; srandmember mset3&quot;5&quot;127.0.0.1:6379&gt; srandmember mset3&quot;5&quot;127.0.0.1:6379&gt; srandmember mset3&quot;4&quot;</code></pre><ol start="6"><li>scard  键<blockquote><p>   获取集合里面元素个数</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; scard mset1(integer) 2</code></pre><ol start="7"><li>sismember  键  值<blockquote><p>   确定一个指定的值是否是集合中的元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; smembers mset11) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; sismember mset1 3(integer) 0127.0.0.1:6379&gt; sismember mset1 1(integer) 1</code></pre><ol start="8"><li>sdiff  集合1  集合2<blockquote><p>   返回集合1与集合2的差集。以集合1为主</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sadd mset4 1 2 3(integer) 3127.0.0.1:6379&gt; sadd mset5 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff mset4 mset51) &quot;1&quot;</code></pre><ol start="9"><li>sdiffstore  新集合  集合1  集合2<blockquote><p>   返回集合1和集合2的差集，并把结果存入新集合</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sadd mset4 1 2 3(integer) 3127.0.0.1:6379&gt; sadd mset5 2 3 4(integer) 3127.0.0.1:6379&gt; sdiffstore mset6 mset5 mset4(integer) 1                //返回值为1 ，证明成功127.0.0.1:6379&gt; smembers mset61) &quot;4&quot;                    //结果存入了mset6，值为4</code></pre><ol start="10"><li>sinter  集合1  集合2<blockquote><p>   获得两个集合的交集</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; smembers mset41) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; smembers mset51) &quot;2&quot;2) &quot;3&quot;3) &quot;4&quot;127.0.0.1:6379&gt; sinter mset4 mset51) &quot;2&quot;2) &quot;3&quot;</code></pre><ol start="11"><li>sinterstore  新集合  集合1  集合2<blockquote><p>   获得集合1和集合2的交集，并把结果存入新集合</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sinterstore mset7 mset4 mset5(integer) 2127.0.0.1:6379&gt; smembers mset71) &quot;2&quot;2) &quot;3&quot;</code></pre><ol start="12"><li>sunion  集合1  集合2<blockquote><p>   获得指定集合的并集</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sunion mset4 mset51) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><ol start="13"><li>sunionstore  新集合  集合1  集合2<blockquote><p>   获得指定集合的并集，并把结果保存如新集合</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; sunionstore mset8 mset4 mset5(integer) 4127.0.0.1:6379&gt; smembers mset81) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><ol start="14"><li>smove  源集合  目标集合  值<blockquote><p>   将指定的值从源集合移动到目标集合</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; smembers mset11) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; smembers mset21) &quot;6&quot;2) &quot;7&quot;127.0.0.1:6379&gt; smove mset1 mset2 1(integer) 1127.0.0.1:6379&gt; smembers mset11) &quot;2&quot;127.0.0.1:6379&gt; smembers mset21) &quot;1&quot;2) &quot;6&quot;3) &quot;7&quot;</code></pre><h2 id="sorted-sets类型和操作"><a href="#sorted-sets类型和操作" class="headerlink" title="sorted sets类型和操作"></a>sorted sets类型和操作</h2><p>sorted set是set的一个升级版本，它给集合中每个元素都定义一个分数，集合中的元素按照其分数排序。也不允许有重复值</p><ol><li>zadd  键  分数1  值1  [分数2  值2…]<blockquote><p>该命令添加指定的成员到key对应的有序集合中，每个成员都有一个分数。你可以指定多个分数/成员组合。如果一个指定的成员已经在对应的有序集合中了，那么其分数就会被更新成最新的，并且该成员会重新调整到正确的位置，以确保集合有序。分数的值必须是一个表示数字的字符串，并且可以是double类型的浮点数。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zadd zset1 1 lm 2 sc 3 glf(integer) 3127.0.0.1:6379&gt; zadd zset1 1 ymj(integer) 1</code></pre><ol start="2"><li>zrange  集合  起始下标  截止下标  [withscores]<blockquote><p>   返回有序集合中，指定区间内的成员。其中成员按照score（分数）值从小到大排序。具有相同score值的成员按照字典顺序来排列。</p><p>   起始下标与截止下标和list类型一致：</p><ul><li>   0代表队列中第一个元素，1代表第二个元素，依次类推</li><li>   -1代表队列中最后一个元素，-2代表倒数第二个元素</li></ul><p>   withscores：返回集合中元素的同时，返回其分数（score）</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;lm&quot;2) &quot;1&quot;3) &quot;ymj&quot;4) &quot;1&quot;5) &quot;sc&quot;6) &quot;2&quot;7) &quot;glf&quot;8) &quot;3&quot;</code></pre><ol start="3"><li>zrevrange  集合  起始下标  截止下标  [withscores]<blockquote><p>   返回有序集合中，指定区间的成员。其成员按照score从大到小来排列。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrevrange zset1 0 -1 withscores1) &quot;glf&quot;        //下标为02) &quot;3&quot;3) &quot;sc&quot;            //下标为14) &quot;2&quot;5) &quot;ymj&quot;        //下标为26) &quot;1&quot;7) &quot;lm&quot;            //下标为38) &quot;1&quot;127.0.0.1:6379&gt; zrevrange zset1 1 2 withscores        //查看集合中下标是1-2的值1) &quot;sc&quot;2) &quot;2&quot;3) &quot;ymj&quot;4) &quot;1&quot;</code></pre><ol start="4"><li>zrangebyscore  集合  起始分数  截止分数  withscores<blockquote><p>   返回有序集合中score（分数）在指定区间的值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zadd zset2 1 one 2 two 3 three 4 four(integer) 4127.0.0.1:6379&gt; zrange zset2 0 -1 withscores        //按照下标区间返回值1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;7) &quot;four&quot;8) &quot;4&quot;127.0.0.1:6379&gt; zrangebyscore zset2 2 3 withscores    //按照分数区间返回值1) &quot;two&quot;2) &quot;2&quot;3) &quot;three&quot;4) &quot;3&quot;</code></pre><ol start="5"><li>zrem  集合  值1  [值2…]<blockquote><p>   删除有序集合中指定的值</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrem zset1 lm(integer) 1127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;ymj&quot;2) &quot;1&quot;3) &quot;sc&quot;4) &quot;2&quot;5) &quot;glf&quot;6) &quot;3&quot;</code></pre><ol start="6"><li>zincrby  集合  增量  值<blockquote><p>   给有序集合中指定值的成员的分数（score）值加上增量（increment）。如果集合中没有这个值，则给添加一个分数是increment的值。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zincrby zset1 2 ymj        //如果值存在，则在其分数上加增量&quot;3&quot;127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;sc&quot;2) &quot;2&quot;3) &quot;glf&quot;4) &quot;3&quot;5) &quot;ymj&quot;6) &quot;3&quot;127.0.0.1:6379&gt; zincrby zset1 4 bro        //如果值不存在，则加入值。并指定分数为增&quot;4&quot;                                        量127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;sc&quot;2) &quot;2&quot;3) &quot;glf&quot;4) &quot;3&quot;5) &quot;ymj&quot;6) &quot;3&quot;7) &quot;bro&quot;8) &quot;4&quot;</code></pre><ol start="7"><li>zrank  集合  值<blockquote><p>   返回有序集合中指定值的下标。值按照score从小到大排序</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrank zset1 sc(integer) 0127.0.0.1:6379&gt; zrank zset1 ymj(integer) 2</code></pre><ol start="8"><li>zrevrank  集合  值<blockquote><p>   返回有序集合中指定值的下标，值按照score从大到小排序</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;sc&quot;2) &quot;2&quot;3) &quot;glf&quot;4) &quot;3&quot;5) &quot;ymj&quot;6) &quot;3&quot;7) &quot;bro&quot;8) &quot;4&quot;127.0.0.1:6379&gt; zrevrank zset1 ymj(integer) 1127.0.0.1:6379&gt; zrevrank zset1 sc(integer) 3</code></pre><ol start="9"><li>zcount  集合  起始分数  截止分数<blockquote><p>   返回有序集合中，score值在起始分数与截止分数之间的个数</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrange zset2 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;7) &quot;four&quot;8) &quot;4&quot;127.0.0.1:6379&gt; zcount zset2 2 4(integer) 3</code></pre><ol start="10"><li>zcard  集合<blockquote><p>   返回有序集合元素的个数</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zcard zset2(integer) 4</code></pre><ol start="11"><li>zremrangebyrank  集合  起始下标  结束下标<blockquote><p>   删除有序集合中，下标在指定区间的元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrange zset2 0 -1 withscores1) &quot;one&quot;2) &quot;1&quot;3) &quot;two&quot;4) &quot;2&quot;5) &quot;three&quot;6) &quot;3&quot;7) &quot;four&quot;8) &quot;4&quot;127.0.0.1:6379&gt; ZREMRANGEBYRANK zset2 0 1(integer) 2127.0.0.1:6379&gt; zrange zset2 0 -1 withscores1) &quot;three&quot;2) &quot;3&quot;3) &quot;four&quot;4) &quot;4&quot;</code></pre><ol start="12"><li>zremrangebyscore  集合  起始分数  截止分数<blockquote><p>删除有序集合中，分数在指定区间的元素</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;sc&quot;2) &quot;2&quot;3) &quot;glf&quot;4) &quot;3&quot;5) &quot;ymj&quot;6) &quot;3&quot;7) &quot;bro&quot;8) &quot;4&quot;127.0.0.1:6379&gt; ZREMRANGEBYSCORE zset1 2 3(integer) 3127.0.0.1:6379&gt; zrange zset1 0 -1 withscores1) &quot;bro&quot;2) &quot;4&quot;</code></pre><ol start="13"><li>zinterstore  新集合  取交集的集合个数  集合1 集合2<blockquote><p>   取集合1和集合2的交集，并把结果保存到新集合中。在计算交集之前，需要指定计算交集的集合的个数。交集中，值的分数是多个集合中分数的和。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zadd zset1 1 one 2 two 3 three 4 four(integer) 4127.0.0.1:6379&gt; zadd zset2  2 two 3 three 4 four 5 five(integer) 4127.0.0.1:6379&gt; ZINTERSTORE zset3 2 zset1 zset2     //有两个集合计算交集，所以集合个数是2(integer) 3127.0.0.1:6379&gt; ZRANGE zset3 0 -1 withscores1) &quot;two&quot;2) &quot;4&quot;                //分数是两个集合中two值的分数和3) &quot;three&quot;4) &quot;6&quot;5) &quot;four&quot;6) &quot;8&quot;</code></pre><ol start="14"><li>zunionstore  新集合  取并集的集合个数  集合1 集合2<blockquote><p>   取集合1和集合2的并集，并把结果保存到新集合中。在计算并集之前，需要指定计算并集的集合的个数。并集中，值的分数是多个集合中分数的和。</p></blockquote></li></ol><pre><code>127.0.0.1:6379&gt; zadd zset1 1 one 2 two 3 three 4 four(integer) 4127.0.0.1:6379&gt; zadd zset2  2 two 3 three 4 four 5 five(integer) 4127.0.0.1:6379&gt; ZUNIONSTORE zset4 2 zset1 zset2(integer) 5127.0.0.1:6379&gt; ZRANGE zset4 0 -1 withscores 1) &quot;one&quot; 2) &quot;1&quot; 3) &quot;two&quot; 4) &quot;4&quot; 5) &quot;five&quot; 6) &quot;5&quot; 7) &quot;three&quot; 8) &quot;6&quot; 9) &quot;four&quot;10) &quot;8&quot;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis共有5种数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string(字符串)&lt;/li&gt;
&lt;li&gt;hash(哈希表)&lt;/li&gt;
&lt;li&gt;list(双向队列)&lt;/li&gt;
&lt;li&gt;set(集合)&lt;/li&gt;
&lt;li&gt;zset(有序集合)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级应用</title>
    <link href="https://weizhimiao.github.io/2016/09/27/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <id>https://weizhimiao.github.io/2016/09/27/Redis%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</id>
    <published>2016-09-27T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<ul><li>给redis服务器设置密码</li><li>持久化</li><li>主从备份</li></ul><span id="more"></span><h2 id="给redis服务器设置密码"><a href="#给redis服务器设置密码" class="headerlink" title="给redis服务器设置密码"></a>给redis服务器设置密码</h2><p>1、 修改redis服务器的配置文件</p><pre><code>[root@localhost redis]# vi /usr/local/redis/etc/redis.conf# requirepass foobared                    （340行）#找到这句话，requirepass后面就是登录redis的密码，改为requirepass flzx_3QC</code></pre><p>2、 重启redis</p><pre><code>[root@localhost redis]# pkill  redis[root@localhost redis]# bin/redis-server  /usr/local/redis/etc/redis.conf</code></pre><p>3、 连接redis</p><pre><code>[root@localhost redis]# /usr/local/redis/bin/redis-cli127.0.0.1:6379&gt; keys *                        //可以正常连接redis(error) NOAUTH Authentication required.        //但因为没有密码，提示操作拒绝127.0.0.1:6379&gt; auth flzx_3QC                //利用auth命令输入密码OK127.0.0.1:6379&gt; keys *                        //才可以正常使用1) &quot;name&quot;</code></pre><p>或</p><pre><code>[root@localhost redis]# /usr/local/redis/bin/redis-cli -a flzx_3QC</code></pre><p>在登录的同时指定密码</p><p><strong>注意历史命令中会明文保存此密码</strong></p><pre><code>127.0.0.1:6379&gt; keys *1) &quot;name&quot;</code></pre><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 提供了不同级别的持久化方式:</p><h3 id="RDB持久化方式"><a href="#RDB持久化方式" class="headerlink" title="RDB持久化方式"></a>RDB持久化方式</h3><blockquote><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。是默认的持久化方式。这种方式是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。这种持久化方式被称为快照 snapshotting（快照）。</p></blockquote><pre><code>save 900 1        #900秒内，最少有1个键被改动。则自动保存一次数据集save 300 10#300秒内，最少有10个键被改动。则自动保存一次数据集save 60 10000#60秒内，最少有10000个键被改动。则自动保存一次数据集</code></pre><p>实验：验证dump.rdb数据保存文件</p><pre><code>[root@localhost ~]# lsanaconda-ks.cfg  dump.rdb  install.log  install.log.syslog</code></pre><p>root目录下有dump.rdb文件</p><pre><code>[root@localhost ~]# /usr/local/redis/bin/redis-server  \/usr/local/redis/etc/redis.conf</code></pre><p>在root目录中启动redis</p><pre><code>[root@localhost ~]# /usr/local/redis/bin/redis-cli127.0.0.1:6379&gt; auth 123OK127.0.0.1:6379&gt; keys *1) &quot;name2&quot;2) &quot;name&quot;3) &quot;name1&quot;</code></pre><p>0库中有键</p><pre><code>[root@localhost ~]# cd /usr/local/redis/[root@localhost redis]# pkill -9 redis[root@localhost redis]# /usr/local/redis/bin/redis-server  \/usr/local/redis/etc/redis.conf</code></pre><p>在/usr/local/redis/库中重启redis，</p><pre><code>[root@localhost redis]# ls[root@localhost redis]# /usr/local/redis/bin/redis-cli127.0.0.1:6379&gt; keys *(empty list or set)</code></pre><p>0库中没有键</p><pre><code>127.0.0.1:6379&gt; saveOK</code></pre><p>保存</p><pre><code>127.0.0.1:6379&gt; quit[root@localhost redis]# lsbin  dump.rdb  etc</code></pre><p>在redis目录中也生成dump.rdb文件</p><p><strong>结论：</strong></p><pre><code>[root@localhost redis]# vi /usr/local/redis/etc/redis.confdir ./</code></pre><p>定义了dump.rdb数据库文件保存在当前位置。所以每次重启redis服务的所在位置不同，导致生成新的dump.rdb文件</p><pre><code>dir /usr/local/redis/</code></pre><p>将数据库保存目录写为绝对路径（注意只能是目录）</p><h3 id="使用AOF"><a href="#使用AOF" class="headerlink" title="使用AOF"></a>使用AOF</h3><blockquote><p>使用AOF会让你的Redis更加耐久: 你可以使用不同的持久化策略：无备份,每秒备份,每次写的时候备份。使用默认的每秒备份策略,Redis的性能依然很好(备份是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据。</p></blockquote><pre><code>appendonly no#默认不使用AOF持久化（450行）appendonly yes#开启AOF持久化# appendfsync always        #有写操作，就马上写入磁盘。效率最慢，到那时最按appendfsync everysec        #默认，每秒钟写入磁盘一次。# appendfsync no            #不进行AOF备份，将数据交给操作系统处理。最快，最不安全</code></pre><h2 id="主从备份"><a href="#主从备份" class="headerlink" title="主从备份"></a>主从备份</h2><p>Redis主从复制特点：</p><ul><li>a.Master可以拥有多个slave</li><li>b.多个slave可以连接同一个master外，还可以连接到其它slave</li><li>c.主从复制不会阻塞master，在同步数据时，master可以继续处理client请求</li><li>d.提高系统的伸缩性</li></ul><p>Redis主从复制过程：</p><ul><li>a.Slave与master建立连接，发送sync同步命令</li><li>b.Master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存。</li><li>c.后台完成保存后，就将此文件发送给slave</li><li>d.Slave将此文件保存到硬盘上</li></ul><h3 id="不同服务器配置主从"><a href="#不同服务器配置主从" class="headerlink" title="不同服务器配置主从"></a>不同服务器配置主从</h3><ol><li>克隆一台linux作为从服务器<br>克隆机需要进行如下操作：</li></ol><pre><code>            ①    vi /etc/sysconfig/network-scripts/ifcfg-eth0                删除MAC地址行            ②    rm  -rf  /etc/udev/rules.d/70-persistent-net.rules                删除网卡和MAC地址绑定文件            ③    注意关闭防火墙和SELinux            ④    重启动系统</code></pre><ol start="2"><li>在从服务器上配置</li></ol><pre><code>[root@localhost ~]# vi /usr/local/redis/etc/redis.conf# slaveof &lt;masterip&gt; &lt;masterport&gt;#把此句开启，并指定主服务器ip和端口    （196行）masterauth flzx_3QC#设定主服务器密码</code></pre><ol start="3"><li>重启从服务器上redis</li></ol><h3 id="同一台服务器实现主从配置"><a href="#同一台服务器实现主从配置" class="headerlink" title="同一台服务器实现主从配置"></a>同一台服务器实现主从配置</h3><p>这里我们以本机配置 1台Master + 1台Slave 为例子,其中:</p><blockquote><ul><li>Master IP:127.0.0.1  PORT:6379</li><li>Slave1 IP:127.0.0.1  PORT:63791</li></ul></blockquote><ol><li> 复制出从服务器目录</li></ol><pre><code>[root@localhost ~]# cp -r /usr/local/redis/ /usr/local/redis-slave1</code></pre><ol start="2"><li> 修改redis-slave1配置文件</li></ol><pre><code>[root@localhost ~]# vi /usr/local/redis-slave1/etc/redis.confpidfile /usr/local/redis-slave1/redis.pid#指定pid文件port 63791#指定端口号dir /usr/local/redis-slave1/#指定服务器目录slaveof 127.0.0.1 6379#指定主服务器IP和端口masterauth flzx_3QC#指定主服务器密码</code></pre><ol start="3"><li>启动服务</li></ol><pre><code>/usr/local/redis-slave1/bin/redis-server /usr/local/redis-slave1/etc/redis.conf#启动从服务器，并调用从服务器配置文件[root@localhost ~]# netstat -tluntcp     0      0 :::6379                     :::*                        LISTEN      tcp     0      0 :::63791                    :::*                        LISTEN#验证两个端口是否都启动</code></pre><ol start="4"><li>验证</li></ol><pre><code>[root@localhost ~]# /usr/local/redis/bin/redis-cli -a flzx_3QC   #启动主服务器，并建立一个键127.0.0.1:6379&gt; set bb 234OK127.0.0.1:6379&gt; keys *1) &quot;sex&quot;2) &quot;aa&quot;3) &quot;name&quot;4) &quot;age&quot;5) &quot;bb&quot;[root@localhost ~]# /usr/local/redis-slave1/bin/redis-cli -a flzx_3QC -p 63791#启动从服务器，发现键已经同步127.0.0.1:63791&gt; keys *1) &quot;aa&quot;2) &quot;sex&quot;3) &quot;age&quot;4) &quot;name&quot;5) &quot;bb&quot;</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;给redis服务器设置密码&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;li&gt;主从备份&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://weizhimiao.github.io/categories/Linux/"/>
    
    
    <category term="Redis" scheme="https://weizhimiao.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PHP扩展模块安装</title>
    <link href="https://weizhimiao.github.io/2016/09/26/PHP%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85/"/>
    <id>https://weizhimiao.github.io/2016/09/26/PHP%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85/</id>
    <published>2016-09-26T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>PHP编译安装之后，通常我们还需要根据我们的业务需求去安装各种扩展。通常我们可以通过php提供的phpize这个工具来为PHP动态地添加我们需要的模块。</p><span id="more"></span><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><ul><li><p>phpize，是用来扩展php扩展模块的，通过phpize可以建立php的外挂模块。一般在我们安装PHP时已经一起安装了。位置一般在/path/to/php/bin/phpize。</p></li><li><p>autoconf，是用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的干预.</p></li><li><p>m4，是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.</p></li></ul><h2 id="示例（为PHP添加mysqli扩展）"><a href="#示例（为PHP添加mysqli扩展）" class="headerlink" title="示例（为PHP添加mysqli扩展）"></a>示例（为PHP添加mysqli扩展）</h2><p>进入PHP源码包的ext/mysqli扩展目录</p><pre><code>cd  ext/mysqli./configure --with-php-config=/usr/local/php56/bin/php-config --with-mysqli=/usr/local/mysql/bin/mysql_configmake &amp;&amp; make install##Installing shared extensions:     /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/#Installing header files:           /usr/local/php56/include/php/</code></pre><p>查看模块是否编译成功</p><pre><code>cd /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/ll#-rwxr-xr-x 1 root root  756714 Sep 26 17:32 mysqli.so#-rwxr-xr-x 1 root root 1333912 Sep 24 23:31 opcache.a#-rwxr-xr-x 1 root root  618435 Sep 24 23:31 opcache.so</code></pre><p>将模块加载到php</p><pre><code>vi /usr/local/php56/lib/php.ini#将下面这行写入到php.ini中extension=/usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/mysqli.so</code></pre><p>重启php-fpm</p><pre><code>kill -USR2 `cat /usr/local/php56/var/run/php-fpm.pid`</code></pre><p>查看是否加载成功</p><pre><code>php -m</code></pre><p>或浏览器访问index.php (包含phpinfo()函数)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PHP编译安装之后，通常我们还需要根据我们的业务需求去安装各种扩展。通常我们可以通过php提供的phpize这个工具来为PHP动态地添加我们需要的模块。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="PHP扩展" scheme="https://weizhimiao.github.io/tags/PHP%E6%89%A9%E5%B1%95/"/>
    
    <category term="phpize" scheme="https://weizhimiao.github.io/tags/phpize/"/>
    
  </entry>
  
  <entry>
    <title>LNMP环境安装与配置</title>
    <link href="https://weizhimiao.github.io/2016/09/25/LNMP%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/09/25/LNMP%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</id>
    <published>2016-09-25T15:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160925/lnmp_log.png" alt="LNMP"></p><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>OS：CentOS 7.2 64</p><p>MySQL：<a href="http://dev.mysql.com/downloads/mysql/">mysql-5.7.15</a></p><p>Nginx：<a href="http://n.sinaimg.cn/games/3ece443e/20160925/nginx-1.11.4.tar.gz">nginx-1.11.4</a></p><p>PHP：<a href="http://n.sinaimg.cn/games/3ece443e/20160925/php-5.6.25.tar.gz">php-5.6.25</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考MySQL、Nginx、PHP的编译安装，分别安装 MySQL、Nginx、PHP到Linux。</p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><h3 id="启动-php-fpm"><a href="#启动-php-fpm" class="headerlink" title="启动 php-fpm"></a>启动 php-fpm</h3><p>新建用户和用户组，</p><pre><code># groupadd www-data# useradd -g www-data www-data</code></pre><p>需要修改 php-fpm.conf 配置文件，确保 php-fpm 模块使用 www-data 用户和 www-data 用户组的身份运行。</p><pre><code>vi /usr/local/php56/etc/php-fpm.conf#找到以下内容并修改：; Unix user/group of processes; Note: The user is mandatory. If the group is not set, the default user&#39;s group;       will be used.user = www-datagroup = www-data</code></pre><p>修改 pid 配置，以方便我们后面根据pid管理php-fpm</p><pre><code>[global]; Pid file; Note: the default prefix is /usr/local/php56/var; Default Value: nonepid = run/php-fpm.pid</code></pre><p>PHP-FPM运行时，将会在/usr/local/php56/var/run/下生成 php-fpm.pid 文件。</p><p>然后启动 php-fpm 服务：</p><pre><code>/usr/local/php56/sbin/php-fpm</code></pre><p>查看是否启动成功</p><pre><code>ps aux | grep phproot     18858  0.0  0.1 148164  3208 ?        Ss   12:38   0:00 php-fpm: master process (/usr/local/php56/etc/php-fpm.conf)www-data 18859  0.0  0.1 148164  2856 ?        S    12:38   0:00 php-fpm: pool wwwwww-data 18860  0.0  0.1 148164  2856 ?        S    12:38   0:00 php-fpm: pool wwwroot     18862  0.0  0.0 112664   972 pts/1    S+   12:38   0:00 grep --color=auto php</code></pre><p><strong>注</strong> 需要着重提醒的是，如果文件不存在，则阻止 Nginx 将请求发送到后端的 PHP-FPM 模块， 以避免遭受恶意脚本注入的攻击。<br>将 php.ini 文件中的配置项 cgi.fix_pathinfo 设置为 0 。</p><pre><code>vi /usr/local/php56/lib/php.inicgi.fix_pathinfo=0</code></pre><h3 id="PHP-FPM-重要配置"><a href="#PHP-FPM-重要配置" class="headerlink" title="PHP-FPM 重要配置"></a>PHP-FPM 重要配置</h3><p>php-fpm.conf重要参数详解</p><ul><li><p>pid = run/php-fpm.pid</p><blockquote><p>pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启</p></blockquote></li><li><p>error_log = log/php-fpm.log</p><blockquote><p>错误日志，默认在安装目录中的var/log/php-fpm.log</p></blockquote></li><li><p>log_level = notice</p><blockquote><p>错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.</p></blockquote></li><li><p>emergency_restart_threshold = 60</p></li><li><p>emergency_restart_interval = 60s</p><blockquote><p>表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。</p></blockquote></li><li><p>process_control_timeout = 0</p><blockquote><p>设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.</p></blockquote></li><li><p>daemonize = yes</p><blockquote><p>后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。</p></blockquote></li><li><p>listen = 127.0.0.1:9000</p><blockquote><p>fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置.</p></blockquote></li><li><p>listen.backlog = -1</p><blockquote><p>backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。</p></blockquote></li><li><p>listen.allowed_clients = 127.0.0.1</p><blockquote><p>允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接</p></blockquote></li><li><p>listen.owner = www</p></li><li><p>listen.group = www</p></li><li><p>listen.mode = 0666</p><blockquote><p>unix socket设置选项，如果使用tcp方式访问，这里注释即可。</p></blockquote></li><li><p>user = www</p></li><li><p>group = www</p><blockquote><p>启动进程的帐户和组</p></blockquote></li><li><p>pm = dynamic #对于专用服务器，pm可以设置为static。</p><blockquote><p>如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：</p></blockquote></li><li><p>pm.max_children #</p><blockquote><p>子进程最大数</p></blockquote></li><li><p>pm.start_servers #</p><blockquote><p>启动时的进程数</p></blockquote></li><li><p>pm.min_spare_servers #</p><blockquote><p>保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程</p></blockquote></li><li><p>pm.max_spare_servers #</p><blockquote><p>保证空闲进程数最大值，如果空闲进程大于此值，此进行清理</p></blockquote></li><li><p>pm.max_requests = 1000</p><blockquote><p>设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0’ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</p></blockquote></li><li><p>pm.status_path = /status</p><blockquote><p>FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到</p></blockquote></li><li><p>ping.path = /ping</p><blockquote><p>FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。</p></blockquote></li><li><p>ping.response = pong</p><blockquote><p>用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong.</p></blockquote></li><li><p>request_terminate_timeout = 0</p><blockquote><p>设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0’ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。</p></blockquote></li><li><p>request_slowlog_timeout = 10s</p><blockquote><p>当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ‘0’ 表示 ‘Off’</p></blockquote></li><li><p>slowlog = log/$pool.log.slow</p><blockquote><p>慢请求的记录日志,配合request_slowlog_timeout使用</p></blockquote></li><li><p>rlimit_files = 1024</p><blockquote><p>设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。</p></blockquote></li><li><p>rlimit_core = 0</p><blockquote><p>设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值.</p></blockquote></li><li><p>chroot =</p><blockquote><p>启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用.</p></blockquote></li><li><p>chdir =</p><blockquote><p>设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时）</p></blockquote></li><li><p>catch_workers_output = yes</p><blockquote><p>重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.</p></blockquote></li></ul><p><strong>Tips</strong> 配置完成之后可以通过 php-fpm -t 来检测配置是否基本正确。</p><pre><code># /usr/local/php56/sbin/php-fpm -t[25-Sep-2016 12:58:14] NOTICE: configuration file /usr/local/php56/etc/php-fpm.conf test is successful</code></pre><h3 id="php-fpm管理"><a href="#php-fpm管理" class="headerlink" title="php-fpm管理"></a>php-fpm管理</h3><p>测试php-fpm配置</p><pre><code>/usr/local/php/sbin/php-fpm -t/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf -t</code></pre><p>启动php-fpm</p><pre><code>/usr/local/php/sbin/php-fpm/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf</code></pre><p>关闭php-fpm</p><pre><code>kill -INT `cat /usr/local/php/var/run/php-fpm.pid`</code></pre><p>重启php-fpm</p><pre><code>kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid`</code></pre><h2 id="配置-Nginx-使其支持-PHP-应用："><a href="#配置-Nginx-使其支持-PHP-应用：" class="headerlink" title="配置 Nginx 使其支持 PHP 应用："></a>配置 Nginx 使其支持 PHP 应用：</h2><pre><code>vim /usr/local/nginx/conf/nginx.conf</code></pre><p>修改默认的 location 块，使其支持 .php 文件：</p><pre><code>location / &#123;    root   html;    index  index.php index.html index.htm;&#125;</code></pre><p>下一步配置来保证对于 .php 文件的请求将被传送到后端的 PHP-FPM 模块， 取消默认的 PHP 配置块的注释，并修改为下面的内容：</p><pre><code>location ~* \.php$ &#123;    fastcgi_index   index.php;    fastcgi_pass    127.0.0.1:9000;    include         fastcgi_params;    fastcgi_param   SCRIPT_FILENAME    $document_root$fastcgi_script_name;    fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;&#125;</code></pre><p>重启 Nginx。</p><pre><code># /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful/usr/local/nginx/sbin/nginx -s reload</code></pre><p>创建测试文件。</p><pre><code>echo &quot;&lt;?php  phpinfo();?&gt;&quot; &gt; /usr/local/nginx/html/index.php</code></pre><p>打开浏览器，访问 <a href="http://ip,将会显示/">http://ip，将会显示</a> phpinfo() 。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建测试文件</p><pre><code>vi mysql_conn_test.php</code></pre><p>输入</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"connect failed"</span> <span class="token punctuation">.</span> <span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string">"SHOW DATABASES;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysql_query</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">,</span> <span class="token variable">$conn</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token variable">$row</span><span class="token operator">=</span><span class="token function">mysql_fetch_array</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">,</span> <span class="token constant">MYSQL_ASSOC</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>  <span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$row</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下，则说明，连接测试成功。</p><pre><code>Array ( [Database] =&gt; information_schema ) Array ( [Database] =&gt; mysql ) Array ( [Database] =&gt; performance_schema ) Array ( [Database] =&gt; sys )</code></pre><p>至此，LNMP环境算是基本配置成功。</p><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160925/lnmp_log.png&quot; alt=&quot;LNMP&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="LNMP" scheme="https://weizhimiao.github.io/tags/LNMP/"/>
    
  </entry>
  
  <entry>
    <title>PHP安装</title>
    <link href="https://weizhimiao.github.io/2016/09/25/PHP%E5%AE%89%E8%A3%85/"/>
    <id>https://weizhimiao.github.io/2016/09/25/PHP%E5%AE%89%E8%A3%85/</id>
    <published>2016-09-25T14:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160925/php_log.png" alt="php"></p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>OS：CentOS 7.2 64</p><p>PHP：<a href="http://n.sinaimg.cn/games/3ece443e/20160925/php-5.6.25.tar.gz">php-5.6.25</a></p><h2 id="编译前准备"><a href="#编译前准备" class="headerlink" title="编译前准备"></a>编译前准备</h2><pre><code>yum -y install libxml2 libxml2-devel</code></pre><p>libxml2,是个C语言的XML程式库，能简单方便的提供对XML文件的各种操作，并且支持XPATH查询，及部分的支持XSLT转换等功能。</p><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>解压源码包</p><pre><code>tar zxvf php-5.6.25.tar.gz</code></pre><p>进入源码包目录</p><pre><code>cd php-5.6.25</code></pre><p>编译、安装</p><pre><code>./configure --prefix=/usr/local/php56 --enable-fpm --with-mysqlmake &amp;&amp; make installInstalling shared extensions:     /usr/local/php56/lib/php/extensions/no-debug-non-zts-20131226/Installing PHP CLI binary:        /usr/local/php56/bin/Installing PHP CLI man page:      /usr/local/php56/php/man/man1/Installing PHP FPM binary:        /usr/local/php56/sbin/Installing PHP FPM config:        /usr/local/php56/etc/Installing PHP FPM man page:      /usr/local/php56/php/man/man8/Installing PHP FPM status page:   /usr/local/php56/php/php/fpm/Installing PHP CGI binary:        /usr/local/php56/bin/Installing PHP CGI man page:      /usr/local/php56/php/man/man1/Installing build environment:     /usr/local/php56/lib/php/build/Installing header files:           /usr/local/php56/include/php/Installing helper programs:       /usr/local/php56/bin/  program: phpize  program: php-configInstalling man pages:             /usr/local/php56/php/man/man1/  page: phpize.1  page: php-config.1Installing PEAR environment:      /usr/local/php56/lib/php/[PEAR] Archive_Tar    - installed: 1.4.0[PEAR] Console_Getopt - installed: 1.4.1[PEAR] Structures_Graph- installed: 1.1.1[PEAR] XML_Util       - installed: 1.3.0[PEAR] PEAR           - installed: 1.10.1Wrote PEAR system config file at: /usr/local/php56/etc/pear.confYou may want to add: /usr/local/php56/lib/php to your php.ini include_path/root/php-5.6.25/build/shtool install -c ext/phar/phar.phar /usr/local/php56/binln -s -f phar.phar /usr/local/php56/bin/pharInstalling PDO headers:           /usr/local/php56/include/php/ext/pdo/</code></pre><p>生成配置文件</p><pre><code>cp php.ini-development /usr/local/php56/lib/php.inicp /usr/local/php56/etc/php-fpm.conf.default /usr/local/php56/etc/php-fpm.conf</code></pre><p>查看配置文件是否已生效。</p><pre><code>$ /usr/local/php56/bin/php -r &quot;phpinfo();&quot;如果看到以下输出，则表示配置文件加载成功。Configuration File (php.ini) Path =&gt; /usr/local/php56/libLoaded Configuration File =&gt; /usr/local/php56/lib/php.ini</code></pre><p>将php加入到PATH中</p><pre><code>vi ~/.bash_profile#在export PATH前一行插入PATH=$PATH:/usr/local/php56/bin:/usr/local/php56/lib</code></pre><p>重新加载环境变量</p><pre><code>source /root/.bash_profile</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>[root@iZwz97v8o84q253plfkxvfZ php56]# php -versionPHP 5.6.25 (cli) (built: Sep 24 2016 23:30:43)Copyright (c) 1997-2016 The PHP GroupZend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies</code></pre><p><strong>Tips:</strong><br>如何确定PHP当前使用的配置文件的位置？</p><p>php：</p><pre><code>$ /usr/local/php56/bin/php -r &quot;phpinfo();&quot;如果看到以下输出，则表示配置文件加载成功。Configuration File (php.ini) Path =&gt; /usr/local/php56/libLoaded Configuration File =&gt; /usr/local/php56/lib/php.ini</code></pre><p>php-fpm:</p><pre><code>/usr/local/php56/sbin/php-fpm -t[25-Sep-2016 18:01:40] NOTICE: configuration file /usr/local/php56/etc/php-fpm.conf test is successful</code></pre><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160925/php_log.png&quot; alt=&quot;php&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
    <category term="PHP-FPM" scheme="https://weizhimiao.github.io/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装</title>
    <link href="https://weizhimiao.github.io/2016/09/25/nginx%E5%AE%89%E8%A3%85/"/>
    <id>https://weizhimiao.github.io/2016/09/25/nginx%E5%AE%89%E8%A3%85/</id>
    <published>2016-09-25T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160925/nginx_log.png" alt="nginx"></p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>OS：CentOS 7.2 64</p><p>Nginx：<a href="http://n.sinaimg.cn/games/3ece443e/20160925/nginx-1.11.4.tar.gz">nginx-1.11.4</a></p><h2 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h2><pre><code>yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code></pre><blockquote><p>依赖工具说明:<br>gcc 编译器<br>pcre 正则表达式工具<br>zlib 传输内容压缩<br>openssl Https支持</p></blockquote><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>解压源码包</p><pre><code>tar -zxvf nginx-1.11.4.tar.gz</code></pre><p>进入源码包目录</p><pre><code>cd nginx-1.11.4</code></pre><p>执行配置命令</p><pre><code>./configure --prefix=/usr/localConfiguration summary  + using PCRE library: /usr/local/pcre  + OpenSSL library is not used  + using system zlib library  nginx path prefix: &quot;/usr/local/nginx&quot;  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;  nginx modules path: &quot;/usr/local/nginx/modules&quot;  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;  nginx http client request body temporary files: &quot;client_body_temp&quot;  nginx http proxy temporary files: &quot;proxy_temp&quot;  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;  nginx http scgi temporary files: &quot;scgi_temp&quot;</code></pre><p>执行编译安装</p><pre><code>make &amp;&amp; make install</code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/nginx/sbin/nginx</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>/usr/local/nginx/sbin/nginx -s stop</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>/usr/local/nginx/sbin/nginx -s reload</code></pre><h3 id="查看Nginx进程状态"><a href="#查看Nginx进程状态" class="headerlink" title="查看Nginx进程状态"></a>查看Nginx进程状态</h3><pre><code>ps aux |grep nginx</code></pre><p>结果形如</p><pre><code>root     24367  0.0  0.0  20472   604 ?        Ss   22:52   0:00 nginx: master process /usr/local/nginx/sbin/nginxnobody   24368  0.0  0.0  20900  1320 ?        S    22:52   0:00 nginx: worker processroot     24370  0.0  0.0 112664   976 pts/0    S+   22:52   0:00 grep --color=auto nginx</code></pre><blockquote><p>master proccess为主进程 守护进程<br>worker proccess为工作进程, 用于响应请求</p></blockquote><h3 id="设置开机自动启动"><a href="#设置开机自动启动" class="headerlink" title="设置开机自动启动"></a>设置开机自动启动</h3><p>编辑文件 /etc/rc.d/rc.local</p><pre><code>echo &quot;/usr/local/nginx/sbin/nginx&quot; &gt;&gt; /etc/rc.d/rc.local</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动nginx，在浏览器通过IP地址访问服务器。查看是否有响应。</p><p>~over</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160925/nginx_log.png&quot; alt=&quot;nginx&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://weizhimiao.github.io/categories/Nginx/"/>
    
    
    <category term="Nginx安装" scheme="https://weizhimiao.github.io/tags/Nginx%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>MySQL编译安装</title>
    <link href="https://weizhimiao.github.io/2016/09/25/MySQL%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/"/>
    <id>https://weizhimiao.github.io/2016/09/25/MySQL%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91/</id>
    <published>2016-09-25T12:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160925/mysql_log.png" alt="MySQL"></p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>OS：CentOS 7.2 64</p><p>MySQL：<a href="http://dev.mysql.com/downloads/mysql/">mysql-5.7.15</a></p><h2 id="编译环境准备"><a href="#编译环境准备" class="headerlink" title="编译环境准备"></a>编译环境准备</h2><pre><code># yum -y install make gcc-c++ cmake bison-devel ncurses-devel</code></pre><blockquote><p>make，Linux下非常重要的编译工具，最主要也是最基本的功能就是通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。<br>gcc-c++，C++ 编译器（gcc，C编译器）<br>cmake，一个跨平台的编译自动配置工具，（作用生成makefile 文件）<br>bison-devel 一个语法分析器生成器<br>ncurses-devel，Ncurses介绍摘要:Ncurses是一个能提供功能键定义(快捷键),屏幕绘制以及基于文本终端.</p></blockquote><h3 id="ncurses"><a href="#ncurses" class="headerlink" title="ncurses"></a>ncurses</h3><p>Ncurses 提供字符终端处理库，包括面板和菜单。它提供了一套控制光标，建立窗口，改变前景背景颜色以及处理鼠标操作的函数。使用户在字符终端下编写应用程序时绕过了那些恼人的底层机制。简而言之，他是一个可以使应用程序直接控制终端屏幕显示的函数库。<br>1、yum安装</p><pre><code>yum -y install ncurses-devel</code></pre><p>注：如果报错，包找不到，是<em>通配符没有识别，给文件名加双引号  “ncurses</em>”</p><p>2、源代码编译:</p><pre><code>下载解压cd ncurses-5.9./configure --with-shared --without-debug --without-ada --enable-overwritemakemake install</code></pre><ul><li>若不安装ncurses编译MySQL时会报错</li><li>–without-ada 参数为设定不编译为ada绑定，因进入chroot环境不能使用ada ；–enable-overwrite参数为定义把头文件安装到/tools/include下而不是/tools/include/ncurses目录</li><li>–with-shared 生成共享库</li></ul><h3 id="安装cmake和bison"><a href="#安装cmake和bison" class="headerlink" title="安装cmake和bison"></a>安装cmake和bison</h3><p>mysql在5.5以后，不再使用./configure工具，进行编译安装。而使用cmake工具替代了./configure工具。cmake的具体用法参考文档cmake说明。</p><p>bison是一个自由软件，用于自动生成语法分析器程序，可用于所有常见的操作系统</p><pre><code>yum -y install cmakeyum -y install bison</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>解压源码包</p><pre><code>tar -zxvf mysql-5.7.15.tar.gz</code></pre><p>进入源码包目录</p><pre><code>cd mysql-5.7.15</code></pre><p>编译</p><pre><code>cmake  \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DENABLED_LOCAL_INFILE=1 \-DWITH_BOOST=/usr/local/boost</code></pre><p>Boost，是为C++语言标准库提供扩展的一些C++程序库的总称，，由Boost社区组织开发、维护。<br>最后一行配置，是配置boost库的，如果没有boost包，编译会报错。<br>如果之前没有安装过，可以单独安装，也可在mysql安装的时候直接下载安装，这样的话，最后一行配置修改如下：</p><pre><code>-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/usr/local/boost #直接下载并安装</code></pre><pre><code>make &amp;&amp; make install</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="创建MySQL运行用户和用户组"><a href="#创建MySQL运行用户和用户组" class="headerlink" title="创建MySQL运行用户和用户组"></a>创建MySQL运行用户和用户组</h3><p>查看mysql用户及用户组</p><pre><code>cat /etc/passwd     查看用户列表cat /etc/group      查看用户组列表</code></pre><p>如果没有就创建</p><pre><code>groupadd mysqluseradd -g mysql mysql</code></pre><p>修改/usr/local/mysql权限</p><pre><code>chown -R mysql:mysql /usr/local/mysql</code></pre><p>初始化配置</p><pre><code>cd /usr/local/mysqlcp support-files/my-default.cnf /etc/my.cnf</code></pre><p>注：在启动MySQL服务时，会按照一定次序搜索my.cnf，先在/etc目录下找，找不到则会在安装目录下面找，在本例中就是 /usr/local/mysql/my.cnf，这是新版MySQL的配置文件的默认位置。</p><h3 id="初始化数据库并生成初始密码"><a href="#初始化数据库并生成初始密码" class="headerlink" title="初始化数据库并生成初始密码"></a>初始化数据库并生成初始密码</h3><pre><code>/usr/local/mysql/bin/mysqld --initialize --user=mysql</code></pre><p>会生成一个初始密码</p><pre><code># A temporary password is generated for root@localhost: -qeFRRlHV0jf</code></pre><p>密码：-qeFRRlHV0jf</p><h3 id="设置环境变量（使得mysql服务可以全局访问）"><a href="#设置环境变量（使得mysql服务可以全局访问）" class="headerlink" title="设置环境变量（使得mysql服务可以全局访问）"></a>设置环境变量（使得mysql服务可以全局访问）</h3><pre><code>vi ~/.bash_profile</code></pre><p>在修改PATH=$PATH:$HOME/bin为：</p><pre><code>PATH=$PATH:$HOME/bin:/usr/local/mysql/bin:/usr/local/mysql/lib</code></pre><p>重新加载环境变量</p><pre><code>[root@root ~]# source /root/.bash_profile    </code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h3><p>方法一：</p><pre><code># 将mysql的启动服务添加到系统服务中# cp support-files/mysql.server /etc/init.d/mysql# service mysql start</code></pre><p>方法二：</p><pre><code>/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;</code></pre><h3 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h3><p>方法一：</p><p>通过chkconfig实现。</p><p>方法二：直接修改 rc.local 文件</p><pre><code>echo &quot;/usr/local/mysql/bin/mysqld_safe --user=mysql &amp;&quot; &gt;&gt; /etc/rc.local</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>登录并修改初始密码（不修改密码不让你操作，就是这么任性）</p><pre><code># mysql -uroot -hlocalhost -pEnter password:-qeFRRlHV0jf（初始密码）# mysql&gt; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;xxxxxxx&#39;);</code></pre><p>重新登录</p><pre><code>#  mysql&gt; exit#  mysql -u root -pEnter password:</code></pre><p>能够登录进去，则说明MySQL安装成功。over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160925/mysql_log.png&quot; alt=&quot;MySQL&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>instanceof运算符的运用</title>
    <link href="https://weizhimiao.github.io/2016/09/22/PHP%E4%B8%ADInstanceOf%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://weizhimiao.github.io/2016/09/22/PHP%E4%B8%ADInstanceOf%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2016-09-22T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>在PHP5中，通过方法传递变量的类型有不确定性。我们很难判断，一些操作是否可以运行。<br>使用instanceof运算符，可以判断当前实例是否可以有这样的一个形态。当前实例使用 instanceof与当前类，父类（向上无限追溯），已经实现的接口比较时，返回真。</p><p>代码格式：实例名 instanceof 类名</p><span id="more"></span><h3 id="instanceof-运算符的运用"><a href="#instanceof-运算符的运用" class="headerlink" title="instanceof 运算符的运用"></a>instanceof 运算符的运用</h3><p>如下例子可以运行。</p><p>没用instanceof运算符判断就会报错，示例代码如下：</p><pre><code>&lt;?php   class User&#123;     private $name=&quot;zhenlw&quot;;     public function  getName()&#123;       return &quot;UserName is &quot;.$this-&gt;name;     &#125;  &#125;  class NormalUser extends User &#123;    private $age = 99;    public function getAge()&#123;      return &quot;age is &quot;.$this-&gt;age;    &#125;  &#125;  class UserAdmin&#123;    //操作.    public static function  getUserInfo(User $user)&#123;      echo $user-&gt;getAge();    &#125;  &#125;  $User = new User();  UserAdmin::getUserInfo($User);?&gt;</code></pre><p>运行后报如下错误：</p><pre><code>Fatal error: Call to undefined method User::getAge() in D:\xampp\htdocs\test\8\test.php on line 20</code></pre><p>因为你传入的对象参数根本没有getAge方法，如果是NormalUser的对象的话就可以正常运行了，这个时候我们运用instanceof运算符来进行判断，修改后的示例代码如下：</p><pre><code>&lt;?php  class User&#123;    private $name=&quot;zhenlw&quot;;    public function  getName()&#123;      return &quot;UserName is &quot;.$this-&gt;name;    &#125;  &#125;  class NormalUser extends User &#123;    private $age = 99;    public function getAge()&#123;      return &quot;age is &quot;.$this-&gt;age;    &#125;  &#125;  class UserAdmin&#123;  //操作.    public static function  getUserInfo(User $user)&#123;      if($user instanceof NormalUser)&#123;        echo $user-&gt;getAge();      &#125; elseif($user instanceof User)&#123;        echo $user-&gt;getName();      &#125;    &#125;  &#125;  $User = new User(); // 这里是User的对象.  UserAdmin::getUserInfo($User);  echo &quot;&lt;br&gt;&quot;;  $normaluser = new NormalUser(); // 这里是NormalUser的对象.  UserAdmin::getUserInfo($normaluser);?&gt;</code></pre><p>运行结果：</p><pre><code>UserName is zhenlwage is 99</code></pre><p>看到运行结果就知道了吧，运用instanceof判断数据类型后就可以保证代码的健壮性，不论你传入的是哪个对象，都可以正确的对此对象进行处理。</p><p>转自：<a href="http://blog.sina.com.cn/s/blog_4ce69a220100ksds.html">http://blog.sina.com.cn/s/blog_4ce69a220100ksds.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在PHP5中，通过方法传递变量的类型有不确定性。我们很难判断，一些操作是否可以运行。&lt;br&gt;使用instanceof运算符，可以判断当前实例是否可以有这样的一个形态。当前实例使用 instanceof与当前类，父类（向上无限追溯），已经实现的接口比较时，返回真。&lt;/p&gt;
&lt;p&gt;代码格式：实例名 instanceof 类名&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT使用小结</title>
    <link href="https://weizhimiao.github.io/2016/09/21/GIT%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/09/21/GIT%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2016-09-21T15:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在使用之前先明确两个概念。</p><ul><li><p>工作区（working directory）</p><blockquote><p>我们创建的文件夹</p></blockquote></li><li><p>版本库（Repository）</p><blockquote><p>一个工作区中隐藏的目录（.git）这个目录不算工作区<br>版本库</p><ul><li>stage，暂存区</li><li>master，分支</li></ul><p>日常我们进行git add操作，是将文件修改添加到了暂存区，而进行git commit操作，则是将暂存区中的修改提交至当前分支。</p></blockquote></li></ul><span id="more"></span><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ol><li><p>创建项目文件夹</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> demo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入项目目录</p><pre><code>cd demogit init（将该目录变成git可以管理的仓库（repository））</code></pre><p>初始化后，该目录下会产生一个.git 的隐藏文件夹。</p></li><li><p>添加文件到仓库</p><pre><code>git add 文件</code></pre><p>添加一个文件到仓库。<br>其实，该操作作用是将文件添加至Stage暂存区。</p></li></ol><p>  常用操作</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span>   <span class="token comment" spellcheck="true">#将所有文件添加至 stage</span><span class="token function">git</span> add -u  <span class="token comment" spellcheck="true">#将所有文件添加至 stage ，同时将工作区中删除的文件也从仓库中删除。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>git commit  提交到版本库<pre><code>git commit -m &quot;write readme file&quot;</code></pre></li></ol><p>-m 为对本次版本提交的说明</p><ol start="5"><li>git status 查看当前版本库状态<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> git_test$ <span class="token function">cd</span> git_test$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># Initialized empty Git repository in /Users/zhimiao/WWW/hexo/git_test/.git/</span>$ ll -a<span class="token comment" spellcheck="true"># total 0</span><span class="token comment" spellcheck="true"># drwxr-xr-x   3 zhimiao  staff   102B  9 23 10:25 .</span><span class="token comment" spellcheck="true"># drwxr-xr-x   6 zhimiao  staff   204B  9 23 10:25 ..</span><span class="token comment" spellcheck="true"># drwxr-xr-x  10 zhimiao  staff   340B  9 23 10:25 .git</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># On branch master</span><span class="token comment" spellcheck="true"># Initial commit</span><span class="token comment" spellcheck="true"># nothing to commit (create/copy files and use "git add" to track)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>git将所有的文件分为3类：已追踪的，被忽略的，和未追踪的。<ul><li>已追踪的（tracked）<blockquote><p>已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。即，一个文件通过执行git add，就会被添加到暂存区，该文件就变成一个已追踪的文件。</p></blockquote></li><li>被忽略的（ignored）<blockquote><p>被忽略的文件是指在版本库中被明确声明为不可见或者被忽略。一般通过在工作区新建 <code>.gitignore</code> 文件来来声明。<br>```<br>$ cat .gitignore<br>.DS_Store<br>Thumbs.db<br>db.json</p></blockquote></li></ul></li></ul><p><em>.log<br>node_modules/<br>public/<br>.deploy</em>/</p><blockquote><pre><code>    - 未追踪的（untracked）未追踪的文件是指那些不在前两类中的文件。git把工作目录下的所有文件当成一个集合，减去已经追踪的文件和忽略的文件，剩下的部分就作为未追踪的文件。</code></pre></blockquote><pre><code>$ echo &quot;git test&quot; &gt; readme.md$ git status# On branch master# Initial commit# Untracked files:#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)#     readme.md# nothing added to commit but untracked files present (use &quot;git add&quot; to track)$ git add readme.md$ git status# On branch master# Initial commit# Changes to be committed:#   (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)#     new file:   readme.md$ git commit -m &quot;add readme file&quot;# [master (root-commit) 81c90a0] add readme file#  1 file changed, 1 insertion(+)#  create mode 100644 readme.md$ git status#  On branch master#  nothing to commit, working directory clean</code></pre><ol start="6"><li><p>git diff 显示当前尚未缓存的改动记录</p><pre><code>$ echo &quot;Second Line &quot; &gt;&gt; readme.md$ git diff# diff --git a/readme.md b/readme.md# index f6edd6e..a1e649c 100644# --- a/readme.md# +++ b/readme.md# @@ -1 +1,2 @@#  git test# +add new Line</code></pre><p>在开头，原始文件被『–』符号标记起来，新文件被用『+++』标记。@@ 之间表示两个不同文件版本的上下文行，以减号（-）开始的行表示从原始文件删除该行以得到新文件。相反，以加号（+）开始的行表示从原始文件中添加该行以产生新文件，而以空格开始的行则表示两个版本都有的行。</p></li><li><p>git log 记录每次commit的信息</p><pre><code>$ git add readme.md$ git commit -m &quot;update&quot;$ echo &quot;third Lines;&quot; &gt;&gt; readme.md$ git add readme.md$ git commit -m &quot;update third&quot;$ git log# commit 2ba4ebfe3ccef91f0d34646f5a0e50e339ee6f7a# Author: weizhimiao &lt;532615323@qq.com&gt;# Date:   Fri Sep 23 11:21:24 2016 +0800##     update third## commit ed0fe412477c8ac828e450cbc319c06ac8db0445# Author: weizhimiao &lt;532615323@qq.com&gt;# Date:   Fri Sep 23 11:19:34 2016 +0800##     update## commit 81c90a01f972ef803bd16272e7983aa1b3e9fa9c# Author: weizhimiao &lt;532615323@qq.com&gt;# Date:   Fri Sep 23 10:42:58 2016 +0800##     add readme file</code></pre></li><li><p>git reset 修改命令</p><pre><code>git reset HEAD    废除本次修改，回到上次提交的状态git reset -hard [commit id]</code></pre><pre><code>$ git reset --hard HEAD^# HEAD is now at 7563423 update$ git log   # commit ed0fe412477c8ac828e450cbc319c06ac8db0445# Author: weizhimiao &lt;532615323@qq.com&gt;# Date:   Fri Sep 23 11:19:34 2016 +0800##     update## commit 81c90a01f972ef803bd16272e7983aa1b3e9fa9c# Author: weizhimiao &lt;532615323@qq.com&gt;# Date:   Fri Sep 23 10:42:58 2016 +0800##     add readme file#$ cat readme.md# git test# Second Lines;</code></pre><p>然后我们就回到了上一次提交的版本。</p></li><li><p>git rm 删除所有版本库记录（慎用）</p></li></ol><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>git clone 克隆一个本地库</p><pre><code>$ git clone git@github.com:weizhimiao/git_test.git# Cloning into &#39;git_test&#39;...# remote: Counting objects: 3, done.# remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0# Receiving objects: 100% (3/3), done.# Checking connectivity... done.$ ll# drwxr-xr-x  4 zhimiao  staff   136B  9 23 21:53 git_test$ cd git_test$ ll# -rw-r--r--  1 zhimiao  staff    12B  9 23 21:53 README.md$ git status# On branch master# Your branch is up-to-date with &#39;origin/master&#39;.# nothing to commit, working directory clean</code></pre><h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><blockquote><p>本地仓库名：git_test<br>远程仓库名：git_test<br>在本地git_test仓库下执行</p></blockquote><pre><code>$ git remote add origin git@github.com:weizhimiao/git_test.git</code></pre><blockquote><p>weizhimiao 是github账户名<br>origin 为远程仓库的名字，git的默认叫法</p></blockquote><p>将本地所有的内容推送到远程库上</p><pre><code>git push -u origin master 把本地master分支推送到远程库-u 为把本地master 分支和远程master分支关联起来，之后就可以通过以下命令进行推送了git push origin master</code></pre><h2 id="分享与更新项目"><a href="#分享与更新项目" class="headerlink" title="分享与更新项目"></a>分享与更新项目</h2><ol><li>git push origin dev  提交到远程dev分支</li></ol><ol start="2"><li><p>git pull origin dev  拉取远程dev分支到本地并和本地dev分支合并</p></li><li><p>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:weizhimiao/git_test.git  将本地仓库推送至名为test的仓库里</p></li></ol><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建：</p><pre><code>$ git branch dev$ git branch#   dev# * master$ git checkout dev# Switched to branch &#39;dev&#39;#$ git branch# * dev#   master</code></pre><blockquote><p>git branch dev 创建dev分支<br>git checkout dev  切换当前分支</p></blockquote><p>等价于</p><pre><code>$ git checkout -b dev 创建并切换到dev分支</code></pre><pre><code># git branch 查看当前分支# git branch -a 查看本地和远程所有分支# git branch -r 常看远程分支# git branch -d 删除本地分支# git checkout master 用于dev分支完成工作后，切换回master 分支## git merge 分支合并# 如当前分支是master，本地另一个分支是dev，用下面命令将dev合并到master分支# git merge dev</code></pre><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre><code># git log 查看历史纪录## 回退到上一个版本# git reset -hard HEAD^# 或# git reset --hard [commit id]回退至指定版本号的版本#### git中# HEAD表示当前版本# HEAD^表示上一个版本# HEAD^^ 上上一个版本# HEAD~100 上100个版本## git reflog 查看命令历史# 一般通过这个命令查看之前版本号# 例如：（前7个字符就是版本号的缩写）$ git reflogbb862b6 HEAD@&#123;0&#125;: merge dev: Fast-forward3223509 HEAD@&#123;1&#125;: checkout: moving from dev to masterbb862b6 HEAD@&#123;2&#125;: commit: dev branch commint3223509 HEAD@&#123;3&#125;: checkout: moving from master to dev3223509 HEAD@&#123;4&#125;: checkout: moving from master to master3223509 HEAD@&#123;5&#125;: checkout: moving from dev to master3223509 HEAD@&#123;6&#125;: checkout: moving from master to dev3223509 HEAD@&#123;7&#125;: commit: add readme.md54906f2 HEAD@&#123;8&#125;: pull origin master: Merge made by the &#39;recursive&#39; strategy.7563423 HEAD@&#123;9&#125;: reset: moving to HEAD^7865e6f HEAD@&#123;10&#125;: commit: update third7563423 HEAD@&#123;11&#125;: commit: update81c90a0 HEAD@&#123;12&#125;: reset: moving to HEAD^ed0fe41 HEAD@&#123;13&#125;: reset: moving to HEAD^2ba4ebf HEAD@&#123;14&#125;: commit: update thirded0fe41 HEAD@&#123;15&#125;: commit: update81c90a0 HEAD@&#123;16&#125;: commit (initial): add readme file</code></pre><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><blockquote><p>git diff HEAD – README.md</p></blockquote><p>查看工作区和版本库里最新版本的区别</p><pre><code>$ git diff HEAD -- README.md# diff --git a/README.md b/README.md# index 9235721..62c0eaa 100644# --- a/README.md# +++ b/README.md# @@ -1 +1 @@# -First Line!# +branch dev line</code></pre><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ol><li>修改了工作区，想直接丢弃<pre><code>$ git checkout -- filename</code></pre></li><li>修改了工作区内容，同事添加到了暂存区<pre><code>$ git reset HEAD filename$ git checkout -- filename</code></pre></li></ol><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><pre><code>$ git rm filename$ git commit 提交到版本库</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;在使用之前先明确两个概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;工作区（working directory）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们创建的文件夹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;版本库（Repository）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个工作区中隐藏的目录（.git）这个目录不算工作区&lt;br&gt;版本库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stage，暂存区&lt;/li&gt;
&lt;li&gt;master，分支&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日常我们进行git add操作，是将文件修改添加到了暂存区，而进行git commit操作，则是将暂存区中的修改提交至当前分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://weizhimiao.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="git" scheme="https://weizhimiao.github.io/tags/git/"/>
    
    <category term="版本控制" scheme="https://weizhimiao.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mac下包管理工具homebrew</title>
    <link href="https://weizhimiao.github.io/2016/09/20/Mac%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7homebrew/"/>
    <id>https://weizhimiao.github.io/2016/09/20/Mac%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7homebrew/</id>
    <published>2016-09-20T15:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>homebrew,一个在Mac OS上的软件包管理工具。是一款有Ruby开发的智能包管理系统.</p><p><a href="http://brew.sh/">官网地址</a></p><ul><li><p>安装：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/bin/ruby -e <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>功能：</p><blockquote><p>软件包管理。homebrew会将套件安装到独立目录，并将文件软连接链接到/usr/local</p></blockquote></li><li><p>命令格式</p><pre><code>$ brew -hExample usage:brew search [TEXT|/REGEX/]brew (info|home|options) [FORMULA...]brew install FORMULA...brew updatebrew upgrade [FORMULA...]brew uninstall FORMULA...brew list [FORMULA...]Troubleshooting:brew configbrew doctorbrew install -vd FORMULABrewing:brew create [URL [--no-fetch]]brew edit [FORMULA...]https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.mdFurther help:man brewbrew help [COMMAND]brew home</code></pre></li><li><p>示例</p><pre><code>$ brew install wget</code></pre></li></ul><h2 id="brew-cask"><a href="#brew-cask" class="headerlink" title="brew-cask"></a>brew-cask</h2><p>brew-cask,是一套建立在homebrew之上的Mac软件安装命令行工具。其与brew的区别是，后者侧重与软件套件和软件环境的配置安装。</p><p><a href="http://caskrom.github.io/">官网</a></p><ul><li><p>安装：</p><pre><code>$ brew install brew-cask</code></pre></li><li><p>命令格式</p><pre><code>$ brew cask -hbrew-cask provides a friendly homebrew-style CLI workflow for theadministration of macOS applications distributed as binaries.Commands:  audit                  verifies installability of Casks  cat                    dump raw source of the given Cask to the standard output  cleanup                cleans up cached downloads and tracker symlinks  create                 creates the given Cask and opens it in an editor  doctor                 checks for configuration issues  edit                   edits the given Cask  fetch                  downloads remote application files to local cache  home                   opens the homepage of the given Cask  info                   displays information about the given Cask  install                installs the given Cask  list                   with no args, lists installed Casks; given installed Casks, lists staged files  search                 searches all known Casks  style                  checks Cask style using RuboCop  uninstall              uninstalls the given Cask  update                 a synonym for &#39;brew update&#39;  zap                    zaps all files associated with the given CaskSee also &quot;man brew-cask&quot;</code></pre></li><li><p>示例</p><pre><code>$ brew cask install iterm2</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;Homebrew&lt;/h2&gt;&lt;p&gt;homebrew,一个在Mac OS上的软件包管理工具。是一款有Ruby开发的智能包管理系统</summary>
      
    
    
    
    <category term="Mac" scheme="https://weizhimiao.github.io/categories/Mac/"/>
    
    
    <category term="Mac" scheme="https://weizhimiao.github.io/tags/Mac/"/>
    
    <category term="homebrew" scheme="https://weizhimiao.github.io/tags/homebrew/"/>
    
  </entry>
  
  <entry>
    <title>Schema数据类型优化</title>
    <link href="https://weizhimiao.github.io/2016/09/19/Schema%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <id>https://weizhimiao.github.io/2016/09/19/Schema%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</id>
    <published>2016-09-19T10:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>良好的数据路逻辑设计和物理设计是高性能的基石，所以要打造一个高性能的数据库服务，在Schema设计之初就应该需要权衡各种因素。</p><h2 id="选择最优化的数据类型"><a href="#选择最优化的数据类型" class="headerlink" title="选择最优化的数据类型"></a>选择最优化的数据类型</h2><p>数据库支持的数据类型非常多，选择一个正确的数据类型对于获得高性能至关重要。</p><p>选择合适数据类型的几个原则：</p><ol><li><p>更小的通常更好<br>一般情况下，应该尽量使用可以正确数据类型的最小数据类型。但也要确保没有低估需要存储的范围。</p></li><li><p>简单就好<br>简单的数据类型的操作通常需要更少的CPU周期。例如，</p></li></ol><ul><li>整型比字符串操作代价更低</li><li>使用MySQL内建的数据类型（比如，date、time、datetime），比用字符串更快</li><li>使用整型存储一个IP地址，比用一个字符串更好</li></ul><ol start="3"><li>尽量避免使用NULL<br>因为如果在查询中包含有NULL的列，对MySQL来说更难优化。所以通常情况下，最好指定列为 NOT NULL。</li></ol><p><strong>TIPS：</strong><br>datetime和timstamp列都可以存储相同类型的数据（时间和日期，都可以精确到秒），然而timestamp实际只使用datetime一般的存储空间。但另一方面，timestamp允许的时间范围要小的多。</p><span id="more"></span><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><ol><li>数字</li><li>整数    - TINYINT (8)    - SMALLINT (16)    - MEDIUMINT (24)    - INT (32)    - BIGINT (64)</li></ol><pre><code>&gt; **TIPS1:** 整数类型有可选的 unsigned 属性，表示不允许有负值，如果将要使用的列不会出现负值的话，加上这个属性，将会可以使正数的上限增加一倍。&gt; **TIPS2:** int(1)与int(11)，对于存储和计算来说，这两者本质是没有区别的；两者只是在MySQL的一些交互工具中略有差别（比如，MySQL命令行客户端，用来控制显示字符的个数）。</code></pre><ol start="2"><li>实数    - 作用<blockquote><p>存储小数</p><p>存储比BIGINT更大的数</p></blockquote></li></ol><pre><code>- float- double&gt; float 和 double支持使用标准的浮点运算进行近似的计算。- decimal&gt; decimal 类型用于存储精确的小数，支持精确的计算。&gt;&gt; 由于CPU不支持对decimal的直接计算，所以对decimal的精确计算是由MySQL服务器自己来实现。&gt;&gt; **Tips:** 因为在进行精确计算时需要额外的空间和计算开销，所以尽量只对小数才使用decimal。比如，财务数据。另外如果数据量大的话，可以考虑使用bigint代替decimal，只需将存储的货币单位根据小数的位数乘以相应的倍数即可。</code></pre><ol start="2"><li><p>字符串</p></li><li><p>CHAR</p><blockquote><p>char 类型是定长的：MySQL是根据定义的字符串长度分配足够的空间。<br>char，适合存储很短的字符串，或者所有值的长度都差不多的的字符串。例如，密码的md5值。<br>另外，char还适合存储经常进行变更的值，相比于vachar，char类型很少会产生碎片。所以这一类的列，会比varchar更好。</p></blockquote></li><li><p>VARCHAR</p><blockquote><p>varchar 类型用于存储可变长的字符串。它只使用必要的空间，所以比定长类型更节省空间。</p><p>varchar,需要使用一个或者两个额外的字节来存储当前字符串的长度信息；如果列的长度小于或等于255个字节，则只需要一个字节表示，否则就需要两个字节来表示。</p><p>下面的这些情况适合使用varchar</p><ol><li>字符串列的长度比平均长度大很多</li><li>列的更新很少，所以碎片不是问题</li><li>使用了像UTF-8这样复杂的字符集，因为该字符集中每个字符可能使用不同的字节来进行存储</li></ol></blockquote></li></ol><pre><code>**Tips:**用varchar(5)和varchar(200)来存储 「hello」有什么区别？首先两者在存储空间的开销是一样的。但是，一般的列在查询时会消耗更多的内存，因为在读到这些列时MySQL通常会分配固定大小的内存块来保存内部值。尤其在使用内存临时表进行排序或者其他操作时，会特别的糟糕。所以最好的策略就是，**分配真正需要的空间**。**Tips：**字符串长度定义不是字节数，而是字符数。两者概念是不同的，多字节字符集会需要更多的空间存储单个字符。</code></pre><ol start="3"><li><p>BLOB和TEXT</p><blockquote><p>两者都是为存储很大的数据而设计的字符串数据类型，不同的是两者分别采用二进制和字符方式存储。</p><p>MySQL在处理两个类型的值时，处理基本相同，仅有的不同是BLOB类型是以二进制格式来存储的，所以没有排序规则和字符集，而text类型有排序规则和字符集。</p></blockquote></li><li><p>枚举（ENUM）</p><blockquote><p>枚举可以把一些不重复的字符串存储成一个预定义的集合。<br>MySQL会在存储枚举类型时粉肠紧凑，会根据列的值的数量压缩到一个或者两个字节中。<br>MySQL会在内部将每个值在列表中的位置保存成整数，而这些『数字–字符串』的对应关系，会保存在 .frm 文件中。<br>所以当该列需要新添加一个新的枚举值时，必须添加在之前枚举列表的最后面，否则就会出现数据错乱的问题。切记。</p></blockquote></li><li><p>日期和时间类型</p></li></ol><ul><li><p>DATETIME</p><blockquote><p>该类型能保存大范围的值，从1001年到9999年，精度为秒。他会把时间封装到YYYYMMDDHHIISS的整数中，没有时区概念。使用8个字节的存储空间。</p></blockquote></li><li><p>TIMESTAMP</p><blockquote><p>该类型保存了从1970-01-01 00：00：00（格林威治时间）以来的秒数。该类型使用4个字节的存储空间，所以只能表示1970到2023年，其值还具有时区的概念。</p></blockquote></li></ul><ol start="6"><li>位数据类型<blockquote><p>存储更紧凑。但所有这些位类型，不管底层存储格式和存储方式，从技术上来说都是字符串类型。虽然用它存储数据更紧凑，但是对于大部分应用来说，最好避免使用该类型。</p></blockquote></li></ol><ul><li><p>BIT</p></li><li><p>SET</p></li></ul><ol start="7"><li>特殊类型的数据<blockquote><p>某些数据的类型并不直接和内置的类型一致。所以需要一定的转换进行存储。</p></blockquote></li></ol><ul><li><p>低于秒级的时间戳</p><blockquote><p>低于秒级的时间需要在引用层做处理，一般可以通过存储两个或者多个列来存储（一个存储秒级的时间戳，另外的存储秒级以下的）</p></blockquote></li><li><p>ipv4地址</p><blockquote><p>我们常见到有人会用 varchar(15)来存错一个IP地址，IP地址实际是一个32位的无符号整数，所以应该用无符号整数来存储IP地址。MySQL提供了 INET_ATON()和 INET_NTOA() 函数在这两表示方法之间转换。</p></blockquote></li></ul><p>love over~<br>2016-09-19</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28947001&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;p&gt;良好的数据路逻辑设计和物理设计是高性能的基石，所以要打造一个高性能的数据库服务，在Schema设计之初就应该需要权衡各种因素。&lt;/p&gt;
&lt;h2 id=&quot;选择最优化的数据类型&quot;&gt;&lt;a href=&quot;#选择最优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择最优化的数据类型&quot;&gt;&lt;/a&gt;选择最优化的数据类型&lt;/h2&gt;&lt;p&gt;数据库支持的数据类型非常多，选择一个正确的数据类型对于获得高性能至关重要。&lt;/p&gt;
&lt;p&gt;选择合适数据类型的几个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;更小的通常更好&lt;br&gt;一般情况下，应该尽量使用可以正确数据类型的最小数据类型。但也要确保没有低估需要存储的范围。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单就好&lt;br&gt;简单的数据类型的操作通常需要更少的CPU周期。例如，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;整型比字符串操作代价更低&lt;/li&gt;
&lt;li&gt;使用MySQL内建的数据类型（比如，date、time、datetime），比用字符串更快&lt;/li&gt;
&lt;li&gt;使用整型存储一个IP地址，比用一个字符串更好&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;尽量避免使用NULL&lt;br&gt;因为如果在查询中包含有NULL的列，对MySQL来说更难优化。所以通常情况下，最好指定列为 NOT NULL。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;TIPS：&lt;/strong&gt;&lt;br&gt;datetime和timstamp列都可以存储相同类型的数据（时间和日期，都可以精确到秒），然而timestamp实际只使用datetime一般的存储空间。但另一方面，timestamp允许的时间范围要小的多。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="数据类型" scheme="https://weizhimiao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎概述</title>
    <link href="https://weizhimiao.github.io/2016/09/17/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/"/>
    <id>https://weizhimiao.github.io/2016/09/17/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/</id>
    <published>2016-09-17T15:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>基于存储引擎在MySQL架构中的地位，在学习和使用MySQL时我们需要对MySQL的各种存储引擎有一个大概的了解。<br>并且知道在实际项目中如何选择适合的存储引擎，以及如何实现不同存储引擎的相互切换。</p><span id="more"></span><h2 id="存储引擎分类"><a href="#存储引擎分类" class="headerlink" title="存储引擎分类"></a>存储引擎分类</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB，是MySQL的默认事务型引擎，也是做重要、使用最广泛的存储引擎。它的性能和自动崩溃恢复特性，使得它在非事务行存储的需求中也很流行。所以除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。并且InnoDB作为事务型存储引擎，它通过一些机制和工具可以支持真正的热备份，而MySQL其他的存储引擎则不支持热备份。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>在MySQL 5.1 及之前的版本，MyISAM是MySQL默认的存储引擎。MyISAM提供大量的特性，包括全文索引、压缩、空间函数（GIS）等，但是MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。尽管MyISAM不支持事务、不支持崩溃后的安全恢复，但是对于一些只读的数据，或者表比较小，可以忍受repair（修复）操作，则依然可以继续使用MyISAM。<strong>但请不要默认使用MyISAM，而是应当默认使用InnoDB</strong></p><h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><p>Archive 存储引擎只支持INSERT 和SELECT 操作，在MySQL 5.1之前还不支持索引。Archive会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少。但是每次select操作都需要对全表进行扫描，所以Archive表适合日志和数据采集类应用，或者一些需要更快速insert操作的场合下使用。总之，MyISAM是一个针对告诉插入和压缩做了优化的简单引擎。</p><h3 id="Blackhole"><a href="#Blackhole" class="headerlink" title="Blackhole"></a>Blackhole</h3><p>Blackhole引擎没有实现任何的存储机制，他会丢弃所有的插入的数据，不做任何的保存。但是服务器会记录Blackhole表的日志，所以可以用于复制数据库到备库，或者只是简单地记录到日志。这种特殊的存储引擎可以在一些特殊的复制架构和日志审核时发挥所用。</p><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但这种表不支持索引。CSV引擎可以在数据运行是拷入或者烤出文件。可以将Excel等电子表格中的数据存储为CSV文件，然后复制到MySQL数据目录下，然后就能在MySQL中打开使用。因此，CSV引擎可以作为一种数据交换的机制，非常有用。</p><h3 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h3><p>Federated引擎是访问其他MySQL服务器的一个代理，他会创建一个到远程MySQL服务器的的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。但是尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题。因此默认是禁用的。</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory表所有的数据都保存在内存中，因此Memory表的访问速度非常的快（至少要比MyISAM快一个数量级），并且不需要磁盘的I/O操作。但是Memory表在系统重启后虽然表结构会保留，但是数据会丢失。</p><p>Memory表支持Hash索引，因此查询操作非常快。但是MySQL表采用的表级锁，因此并发写入的性能较低。</p><p>Memory表的应用场景：</p><ul><li>用于查找（lookup）或者映射（mapping）表。</li><li>用于缓存周期性聚合数据的结果。</li><li>用于保存数据分析中产生的中间问题。</li></ul><p><strong>Tips：</strong><br>如果MySQL在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是Memory表。如果中间结果大大超出了Memory表的限制，或者有大量的BLOB或TEXT字段，则临时表会转换成MyISAM表。</p><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>Merge引擎是MyISAM的一种变种。Merge表是由多个MyISAM表合并而来的虚拟表。</p><h3 id="NDB"><a href="#NDB" class="headerlink" title="NDB"></a>NDB</h3><p>MySQL服务器、NDB集群引擎、以及分布式的、share-nothing的、容灾的、高可用的NDB数据库组合，被称之为MySQL集群（MySQL Cluster）。</p><h3 id="其他的第三方存储引擎"><a href="#其他的第三方存储引擎" class="headerlink" title="其他的第三方存储引擎"></a>其他的第三方存储引擎</h3><p>MySQL从07年开始提供了插件式的存储引擎API，从此出现了一系列为不同目的而设计的存储引擎。其中一些已经合并到MySQL服务器，但大多数还是第三方产品或者开源项目。比较有名的有：</p><ul><li>OLTP类引擎</li><li>面向列的存储引擎</li><li>社区存储引擎</li></ul><h2 id="选择合适的存储引擎的考虑因素"><a href="#选择合适的存储引擎的考虑因素" class="headerlink" title="选择合适的存储引擎的考虑因素"></a>选择合适的存储引擎的考虑因素</h2><p>不同的应用可能会根据不同的需求而采用不同的存储引擎。那么我们再为应用选择存储引擎时，通常会考虑以下几点：</p><ul><li><p>事务<br>引用是否需要事务支持。如果需要，那么InnoDB是目前最稳定且经过验证的选择。如果不需要，并且主要是select和insert操作，那么MyISAM是不错的选择。</p></li><li><p>备份<br>如果可以定期的通过关闭服务器来执行备份，那么备份因素就可以忽略。反之，如果需要支持在线热备份，那么选择InnoDB就是基本的要求。</p></li><li><p>崩溃恢复<br>相对而言，MyISAM崩溃后发生的数据毁坏的概率要比InnoDB高的多，并且恢复速度也要慢的多。所以，即使不需要事务支持，很多人也会选择InnoDB引擎。</p></li><li><p>特有的特性<br>有些应用可能需要一些存储引擎锁独有的特性或者优化，比如依赖聚簇索引的优化，或者需要对地理空间的搜索。</p></li></ul><p><strong>总之，如无特殊的需求和例外，统统建议选择InnoDB存储引擎。</strong></p><h2 id="如何转换表的存储引擎"><a href="#如何转换表的存储引擎" class="headerlink" title="如何转换表的存储引擎"></a>如何转换表的存储引擎</h2><p>有很多中方法可以转换，一般我们会使用以下三种方法：</p><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span><span class="token keyword">alter</span> <span class="token keyword">table</span> mytable <span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">innodb</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述语法可以适应与任何存储引擎。但是当表数据很大时，这种方法将会执行很长时间。MySQL会按行将数据从原表复制到一张新的表中。所以，在繁忙的表上执行此操作要非常小心。</p><h3 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入/导出"></a>导入/导出</h3><p>使用mysqldump工具将数据到出到文件，然后修改文件中create table 语句中的存储引擎的选项，（同时注意修改表名，避免在导入的时候将原表删除，造成数据丢失）。然后导入文件到数据库，这样就得到了一个原表的一个全量复制表。</p><h3 id="创建与查询"><a href="#创建与查询" class="headerlink" title="创建与查询"></a>创建与查询</h3><p>综合第一种方法的高效和第二种的安全。不需要导出整张表的数据，而是先创建一个新的存储引擎的表，然后利用 insert…select语法来导数据。</p><pre><code>mysql&gt;create table innodb_table like myisam_table;mysql&gt;alter table innodb_table engine=innodb;mysql&gt;insert into innodb_table select * from myisam_table;</code></pre><p>如果数据量大的话，可以考虑分批处理，并使用事务进行提交操作；</p><pre><code>mysql&gt;start transaction;mysql&gt;insert into innodb_table select * from myisam_table where id between x and y;mysql&gt;commit;</code></pre><p>如果有必要，在操作的时候可以对原表加锁，以确保新表和原表数据一致。<br>这样操作之后也会得到一个对原表的全量复制的表，如果需要还可以删除原表。</p><p><strong>Tips：</strong><br>Persona Toolkit 提供了一个 pt-online-schema-change的工具（基于Facebook的在线变更技术），可以比较简单、方便的执行上述过程，避免收工操作可能会带来的错误是繁琐。。。。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于存储引擎在MySQL架构中的地位，在学习和使用MySQL时我们需要对MySQL的各种存储引擎有一个大概的了解。&lt;br&gt;并且知道在实际项目中如何选择适合的存储引擎，以及如何实现不同存储引擎的相互切换。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="存储引擎" scheme="https://weizhimiao.github.io/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>如何查看表的相关信息</title>
    <link href="https://weizhimiao.github.io/2016/09/17/MySQL%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/"/>
    <id>https://weizhimiao.github.io/2016/09/17/MySQL%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</id>
    <published>2016-09-17T14:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>在文件系统中，MySQL将每个数据库（也被称为schema）保存为数据目录下的一个子目录。在创建表的时候，MySQL会在数据库子目录下创建一个和表同名的 .frm 文件对表的定义。例如，创建一个名为 mytable 的表，MySQL会在 mytable.frm 文件中保存对该表的定义。</p><p>通常，我们可以使用 show table status 命令来显示表的相关信息。（MySQL 5.0 + 的版本，也可以查看 INFOMATION_SCHEMA 中对应的表的信息）。<br>例如，对于MySQL数据库中的 user 表：</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">table</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'user'</span> \G<span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>           Name: <span class="token keyword">user</span>         <span class="token keyword">Engine</span>: MyISAM        Version: <span class="token number">10</span>     Row_format: Dynamic           <span class="token keyword">Rows</span>: <span class="token number">14</span> Avg_row_length: <span class="token number">63</span>    Data_length: <span class="token number">952</span>Max_data_length: <span class="token number">281474976710655</span>   Index_length: <span class="token number">2048</span>      Data_free: <span class="token number">64</span> <span class="token keyword">Auto_increment</span>: <span class="token boolean">NULL</span>    Create_time: <span class="token number">2012</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">25</span> <span class="token number">14</span>:<span class="token number">23</span>:<span class="token number">08</span>    Update_time: <span class="token number">2015</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">11</span> <span class="token number">11</span>:<span class="token number">17</span>:<span class="token number">42</span>     Check_time: <span class="token boolean">NULL</span>      Collation: utf8_bin       Checksum: <span class="token boolean">NULL</span> Create_options:        <span class="token keyword">Comment</span>: Users <span class="token operator">and</span> <span class="token keyword">global</span> <span class="token keyword">privileges</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span id="more"></span><p>下面简单介绍一下每行的含义：</p><ul><li><p>Name</p><blockquote><p>表名。</p></blockquote></li><li><p>Engine</p><blockquote><p>表的存储引擎。</p></blockquote></li><li><p>Row_format</p><blockquote><p>行的格式，对于MyISAM表，可选的值为Dynamic、Fixed、Compressed。</p></blockquote><ul><li>Dynamic，表示行的长度是可变的，一般包含可变长度的字段，如varchar、blob等。</li><li>Fixed，行的长度是固定的，只包含固定长短的列。</li><li>Compressed，只在压缩表中出现，表示是被压缩的。</li></ul></li><li><p>Rrows</p><blockquote><p>表中行数，对于MyISAM和其他的一些存储引擎该值是精确的，但对于InnoDB该值只是一个大概值。</p></blockquote></li><li><p>Avg_row_length</p><blockquote><p>平均每行包含的字节数</p></blockquote></li><li><p>Data_length</p><blockquote><p>表数据的大小(单位：字节)</p></blockquote></li><li><p>Max_data_length</p><blockquote><p>表数据的最大容量，该值和存储引擎有关。</p></blockquote></li><li><p>Index_length</p><blockquote><p>索引的大小(单位：字节)</p></blockquote></li><li><p>Data_free</p><blockquote><p>对于MyISAM表示已经分配但是目前没有被使用的空间。这部分空间包括之前删除的行，以及后续可以被Insert利用的行。</p></blockquote></li><li><p>Auto_increment</p><blockquote><p>下一个Auto_increment的值。</p></blockquote></li><li><p>Create_time</p><blockquote><p>表的创建时间。</p></blockquote></li><li><p>Update_time</p><blockquote><p>表数据的最后修改时间。</p></blockquote></li><li><p>Check_time</p><blockquote><p>使用check table命令或者muisamchk 工具最后一次检查表的时间。</p></blockquote></li><li><p>Collation</p><blockquote><p>表的默认字符集和字符列排序规则。</p></blockquote></li><li><p>Checksum</p><blockquote><p>如果启用，保存的是整个表的实时校验和。</p></blockquote></li><li><p>Create_options</p><blockquote><p>创建表时指定的其他选项。</p></blockquote></li><li><p>Comment</p><blockquote><p>该列包含了一些其他的额外信息。对于MyISAM表，保存的是在表创建的时候附带的注释。对于InnoDB表，该值保存的是InnoDB表空间的剩余空间信息。如果是一个视图，该列将会包含『VIEW』字样。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在文件系统中，MySQL将每个数据库（也被称为schema）保存为数据目录下的一个子目录。在创建表的时候，MySQL会在数据库子目录下创建一个和表同名的 .frm 文件对表的定义。例如，创建一个名为 mytable 的表，MySQL会在 mytable.frm 文件中保存对该表的定义。&lt;/p&gt;
&lt;p&gt;通常，我们可以使用 show table status 命令来显示表的相关信息。（MySQL 5.0 + 的版本，也可以查看 INFOMATION_SCHEMA 中对应的表的信息）。&lt;br&gt;例如，对于MySQL数据库中的 user 表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;mysql&amp;gt; show table status like &amp;#39;user&amp;#39; \G;
*************************** 1. row ***************************
           Name: user
         Engine: MyISAM
        Version: 10
     Row_format: Dynamic
           Rows: 14
 Avg_row_length: 63
    Data_length: 952
Max_data_length: 281474976710655
   Index_length: 2048
      Data_free: 64
 Auto_increment: NULL
    Create_time: 2012-12-25 14:23:08
    Update_time: 2015-08-11 11:17:42
     Check_time: NULL
      Collation: utf8_bin
       Checksum: NULL
 Create_options:
        Comment: Users and global privileges
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MVCC多版本并发控制</title>
    <link href="https://weizhimiao.github.io/2016/09/16/MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/16/MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%95%B4%E7%90%86/</id>
    <published>2016-09-16T17:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中大多数事务型的存储引擎都不是简单的行级锁。为了提高并发性，他们一般会采用多版本并发控制（MVCC，一种行级锁的变种）来使很多情况下在避免加锁的情况下就实现并发操作，从而是的系统开销更低。</p><p>MySQL的InnoDB存储引擎的MCVV，是通过在每行记录后面保存两个隐藏的列来实现。一个保存行的创建时间，另一个保存过期时间。当然这里所说的时间并不是实际时间，是系统版本号。数据库系统在每开始一个事务，其系统版本号就会自动递增。一个事务开始时刻，事务会去当前的系统版本号作为当前事务的事务版本号，用来和查询到的每行记录的版本号做比较。</p><table><thead><tr><th>id</th><th>fields …</th><th>create_version</th><th>delete_version</th></tr></thead><tbody><tr><td>1</td><td>….</td><td>1</td><td></td></tr><tr><td>2</td><td>….</td><td>2</td><td>3</td></tr></tbody></table><span id="more"></span><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Repeatable read 隔离级别下，MVCC具体操作：</p><h3 id="Select-操作："><a href="#Select-操作：" class="headerlink" title="Select 操作："></a>Select 操作：</h3><p>a. InnoDB 只查找版本号小于当前事务版本号的行（即，行的系统版本号小于或者等于当前事务的系统版本号），以确保当前事务读取到的行，要么是当前事务开始之前就已经存在的行，要么就是当前事务插入或者修改过的行。<br>b. 行的删除版本号要么未定义，要么大于当前事务的版本号。这样可以确保当前事务读取到行，在事务开始之前为被删除。</p><p>只有同事符合上述两个条件的记录，才能被作为查询结果被返回。</p><h3 id="Insert-操作："><a href="#Insert-操作：" class="headerlink" title="Insert 操作："></a>Insert 操作：</h3><p>InnoDB为新插入的行保存当前事务的版本号作为行版本号。</p><h3 id="Delete-操作："><a href="#Delete-操作：" class="headerlink" title="Delete 操作："></a>Delete 操作：</h3><p>InnoDB为删除的每一行记录保存当前的事务版本号作为行删除标识。</p><h3 id="Update-操作："><a href="#Update-操作：" class="headerlink" title="Update 操作："></a>Update 操作：</h3><p>InnoDB会插入一条新纪录，保存当前事务版本号作为改行的行版本号，同事保存当前的事务版本号到原来的行作为行删除标识版本号。</p><h2 id="多版本并发控制优缺点"><a href="#多版本并发控制优缺点" class="headerlink" title="多版本并发控制优缺点"></a>多版本并发控制优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>通过两个额外的版本号，能使大多数读操作都可以不用加锁，从而使得查询性能更好。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每行记录多需要做存储两个版本号，需要浪费额外的存储空间。</p><p><strong>TIPS:</strong><br>MVCC，只在Repeatable read 和read committed两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为 read uncommitted总是读取最新的行，而不是符合当前事务版本号的行，而 serializable 则会对所有读取的行都会加锁。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL中大多数事务型的存储引擎都不是简单的行级锁。为了提高并发性，他们一般会采用多版本并发控制（MVCC，一种行级锁的变种）来使很多情况下在避免加锁的情况下就实现并发操作，从而是的系统开销更低。&lt;/p&gt;
&lt;p&gt;MySQL的InnoDB存储引擎的MCVV，是通过在每行记录后面保存两个隐藏的列来实现。一个保存行的创建时间，另一个保存过期时间。当然这里所说的时间并不是实际时间，是系统版本号。数据库系统在每开始一个事务，其系统版本号就会自动递增。一个事务开始时刻，事务会去当前的系统版本号作为当前事务的事务版本号，用来和查询到的每行记录的版本号做比较。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;fields …&lt;/th&gt;
&lt;th&gt;create_version&lt;/th&gt;
&lt;th&gt;delete_version&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;….&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;….&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="MVCC" scheme="https://weizhimiao.github.io/tags/MVCC/"/>
    
    <category term="多版本并发控制" scheme="https://weizhimiao.github.io/tags/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>事务的ACID概念</title>
    <link href="https://weizhimiao.github.io/2016/09/16/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%A6%82%E5%BF%B5/"/>
    <id>https://weizhimiao.github.io/2016/09/16/%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%A6%82%E5%BF%B5/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中的事务就是一组原子行的SQL查询，或者说一个独立的工作但愿。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p><p>ACID表示原子性（atomicity）、一致性（consistency）、隔离行（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些特征。</p><blockquote><p>一个实现了ACID的数据库，相比于没有实现ACID的数据库，通常需要更强的CPU，更大的内存，更多的存储空间。所以对于一些不需要事务支持的查询类型应用，选择一个非事务型的存储引擎，是可以获得更高的性能的。</p></blockquote><span id="more"></span><h2 id="事务ACID的概念"><a href="#事务ACID的概念" class="headerlink" title="事务ACID的概念"></a>事务ACID的概念</h2><ul><li><p>A,automicity 原子性</p><blockquote><p>即，一个不可分割的最小单元。</p></blockquote></li><li><p>C,consistency 一致性</p><blockquote><p>总是从一种状态到另一种状态，没有第三种状态。</p></blockquote></li><li><p>I,isolation 隔离性</p><blockquote><p>一个事务再提交之前，对其他事务是不可见的。即不同的事务之间相互之间不影响。</p></blockquote></li><li><p>D,durability 持久性</p><blockquote><p>事务一旦提交，就会永久生效。</p></blockquote></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>隔离级别，规定一个事务中所做的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。<br>一般，较低隔离级别的隔离可以支持更高的并发，系统的开销会更低。</p><h3 id="隔离要解决的问题"><a href="#隔离要解决的问题" class="headerlink" title="隔离要解决的问题"></a>隔离要解决的问题</h3><ul><li><p>脏读，Dirty read</p><blockquote><p>即其他事务可以读取到当前事务未提交的数据。</p></blockquote></li><li><p>不可重复读，nonrepeatable read</p><blockquote><p>即两次执行同样的查询，得到的结果可能是不一样的。</p></blockquote></li><li><p>幻读，Phantom read</p><blockquote><p>某一个事务在取一范围记录时，另一事务又在该范围插入了新纪录，当之前事务再读取该范围是，就会产生幻读。</p></blockquote></li></ul><h3 id="不同的隔离划分"><a href="#不同的隔离划分" class="headerlink" title="不同的隔离划分"></a>不同的隔离划分</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读可能性</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>read committed</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>repeatable read</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>serializable</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr></tbody></table><ul><li><p>Read uncommitted（未提交读）</p><blockquote><p>在这个级别下，事务中的修改，即使在没有提交的情况下，其他的事务也是可见的。<br>所以，除非有非常必要的理由，在实际应用中一般很少使用。</p></blockquote></li><li><p>Read committed（提交读）</p><blockquote><p>read committed隔离级别满足前面提到的隔离性的定义。即一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始到提交之前，所做的任何修改对其他的事务都是不可见的。<br><strong>大多数的数据库系统的默认隔离级别都是这个级别</strong><br>但这个级别有时候会出现不可重复读的现象，即执行两次同样的查询可能会得到两个不同的结果。</p></blockquote></li><li><p>repeatable read（可重复读）</p><blockquote><p>该级别解决了脏读的问题，而且保证了在同一个事务中多次读取同一条记录的结果是一致的。<br><strong>该级别是MySQL的默认事务级别</strong><br>但是理论上，该级别下会出现另一个幻读的问题。<br>MySQL的InnoDB通过多版本并发控制（MVCC）来解决了该级别下出现幻读的可能性问题。</p></blockquote></li><li><p>serializable（可串行化）</p><blockquote><p>该级别为最高的隔离级别。他通过强制事务串行执行，避免了前面 repeatable read 级别下可能会出现幻读的情况。简单说，就是serializable会在读取的每行数据上都加锁。所以会导致大量的超时和锁争用的情况。故实际应用中该级别也很少用到。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库中的事务就是一组原子行的SQL查询，或者说一个独立的工作但愿。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。&lt;/p&gt;
&lt;p&gt;ACID表示原子性（atomicity）、一致性（consistency）、隔离行（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些特征。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个实现了ACID的数据库，相比于没有实现ACID的数据库，通常需要更强的CPU，更大的内存，更多的存储空间。所以对于一些不需要事务支持的查询类型应用，选择一个非事务型的存储引擎，是可以获得更高的性能的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="事务" scheme="https://weizhimiao.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="ACID" scheme="https://weizhimiao.github.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>MySQL并发控制整理</title>
    <link href="https://weizhimiao.github.io/2016/09/16/MySQL%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/16/MySQL%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%95%B4%E7%90%86/</id>
    <published>2016-09-16T13:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>根据控制的不同层次，MySQL的并发控制可以分为：</p><ul><li>服务器层</li><li>存储引擎层</li></ul><p>实现并发控制的方法策略：<em><strong>锁机制</strong></em></p><ul><li>共享锁（shared lock）&lt;======&gt; 读锁（read lock）</li><li>排它锁（exclusive lock） &lt;======&gt; 写锁（write lock）</li></ul><p>如何选择适合的锁？<em><strong>锁策略</strong></em></p><ul><li>锁的粒度越小，系统的并发性越高</li><li>所得操作越多，系统的开销越大<blockquote><p>所以所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。</p></blockquote></li></ul><span id="more"></span><h2 id="MySQL中锁策略类型"><a href="#MySQL中锁策略类型" class="headerlink" title="MySQL中锁策略类型"></a>MySQL中锁策略类型</h2><p>MySQL不同的存储引擎中用到的锁策略基本有两种。一种是表级锁，另一种是行级锁。</p><ul><li><p>表锁，一种开销最小的锁策略。</p><blockquote><p>一个用户对表进行写操作时，需要先获得写锁，这是其他用户读该表进行的读写操作都会进行阻塞。只有当前写操作被释放之后，其他人才能活的读锁。当当前表有读锁时，其他人也可以继续获得读锁。读锁是共享性的不同的读锁之间是互相不阻塞的。<br>另外，写锁的优先级高于读锁。所以当有多个锁请求存在是，读锁的请求会被优先插入到锁队列的前边。</p></blockquote></li><li><p>行锁，最大程度支持并发处理，同时也是锁开销最大的锁策略。</p><blockquote><p>顾名思义，行级锁只在将要修改的记录行上进行锁操作，对其他的行的操作没有影响。</p></blockquote></li></ul><p>尽管我们一般提到的锁，都处于存储引擎这一层，但是MySQL本身在某些情况下，也会对锁策略进行控制。比如表的alter table操作，会对表本身使用表锁，而直接忽略存储引擎的锁机制。</p><h2 id="MySQL中死锁问题解决方法"><a href="#MySQL中死锁问题解决方法" class="headerlink" title="MySQL中死锁问题解决方法"></a>MySQL中死锁问题解决方法</h2><blockquote><p>死锁，即两个或者多个事务在同一资源上相互占用，并请求占用对方已经占用的资源的情况。</p></blockquote><p>既然有锁存在，当然就会有死锁的情况发生。那么MySQL中是如何处理死锁问题的呢？<br>死锁的通常解决方案有两种，即：</p><ul><li>死锁检测机制</li><li>超时机制</li></ul><p>InnoDB存储引擎在检测到有死锁发生的处理方法是，将当前持有最少的行级锁的事务进行回滚。待打破死锁后，重新执行因为死锁而回滚的事务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据控制的不同层次，MySQL的并发控制可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器层&lt;/li&gt;
&lt;li&gt;存储引擎层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现并发控制的方法策略：&lt;em&gt;&lt;strong&gt;锁机制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享锁（shared lock）&amp;lt;======&amp;gt; 读锁（read lock）&lt;/li&gt;
&lt;li&gt;排它锁（exclusive lock） &amp;lt;======&amp;gt; 写锁（write lock）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何选择适合的锁？&lt;em&gt;&lt;strong&gt;锁策略&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁的粒度越小，系统的并发性越高&lt;/li&gt;
&lt;li&gt;所得操作越多，系统的开销越大&lt;blockquote&gt;
&lt;p&gt;所以所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="并发控制" scheme="https://weizhimiao.github.io/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL逻辑架构设计</title>
    <link href="https://weizhimiao.github.io/2016/09/16/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/09/16/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93/</id>
    <published>2016-09-16T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>通常MySQL架构有两种划分，一种划为两层架构，另一种划为三层。<br>两层架构划为MySQL服务器层和存储引擎层，三层架构则把MySQL层又划为两层。</p><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160916/MySQLJiaGouTu1.png" alt="MySQL架构图"></p><span id="more"></span><h2 id="三层架构说明"><a href="#三层架构说明" class="headerlink" title="三层架构说明"></a>三层架构说明</h2><ul><li><p>第一层，用于连接处理、授权认证、安全认证等等。大多数基于客户端/服务器端的工具或者服务器都有类似架构。</p></li><li><p>第二层，是MySQL架构的核心部分。MySQL的大部分核心服务功能大都在这一层。包括查询解析、分析、优化、缓存以及所有的内置函数的实现，还有所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、试图等。</p></li><li><p>第三层，存储引擎层。存储引擎负责MySQL中数据的存储和读取。每个存储引擎都有自己的优势和劣势。MySQL服务器层通过API与存储引擎进行通信。存储引擎本身是不会解析SQL，且不同的存储引擎之间也是不会相互通信。</p></li></ul><h2 id="MySQL服务器接收-处理一个查询请求的过程"><a href="#MySQL服务器接收-处理一个查询请求的过程" class="headerlink" title="MySQL服务器接收/处理一个查询请求的过程"></a>MySQL服务器接收/处理一个查询请求的过程</h2><ol><li><p>当MySQL服务器接收到一个查询请求，首先会对当前的连接请求进行认证，认证其用户名和密码信息。</p></li><li><p>连接成功之后，会继续验证该连接是否具有执行某个特定查询的权限。</p></li><li><p>所有的验证都通过，如果是 select 操作，MySQL会先检查查询缓存中是否存在该缓存，如果存在直接返回结果。不存在继续下一步。</p></li><li><p>解析查询，并创建内部数据结构（生成 解析树），然后对解析树进行各种优化（包括，重写查询，决定表的读取顺序、选择合适的索引等等）。</p></li><li><p>通过存储引擎存储或者提取结果。</p></li><li><p>如果是select操作，生成查询缓存。</p></li><li><p>返回结果。</p></li></ol><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常MySQL架构有两种划分，一种划为两层架构，另一种划为三层。&lt;br&gt;两层架构划为MySQL服务器层和存储引擎层，三层架构则把MySQL层又划为两层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160916/MySQLJiaGouTu1.png&quot; alt=&quot;MySQL架构图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="https://weizhimiao.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL逻辑架构" scheme="https://weizhimiao.github.io/tags/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Apache中PHP支持模式小结</title>
    <link href="https://weizhimiao.github.io/2016/09/07/Apache%20%E4%B8%ADPHP%E6%94%AF%E6%8C%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://weizhimiao.github.io/2016/09/07/Apache%20%E4%B8%ADPHP%E6%94%AF%E6%8C%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2016-09-07T12:10:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>Apache通过不同的方式，能够实现对PHP支持。常见的几种支持方式有：</p><ul><li>模块支持（handler模式）</li><li>CGI模块</li><li>FastCGI模式，用Apache内置进程管理器</li><li>FastCGI模式，用php-fpm进程管理器</li></ul><span id="more"></span><h2 id="Apache安装、PHP安装、mod-fastcgi模块安装"><a href="#Apache安装、PHP安装、mod-fastcgi模块安装" class="headerlink" title="Apache安装、PHP安装、mod_fastcgi模块安装"></a>Apache安装、PHP安装、mod_fastcgi模块安装</h2><h3 id="Apache-安装"><a href="#Apache-安装" class="headerlink" title="Apache 安装"></a>Apache 安装</h3><p>略过···</p><h3 id="PHP-安装"><a href="#PHP-安装" class="headerlink" title="PHP 安装"></a>PHP 安装</h3><p>示例：安装PHP5.6</p><ol><li>下载、解压<pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ ~]#wget http://cn2.php.net/distributions/php-5.6.25.tar.gz[root@iZ23a3ua2stZ ~]#tar -zxvf php-5.6.25.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>./configure<pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ ~]#cd php-5.6.25[root@iZ23a3ua2stZ php-5.6.25]#./configure --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql --enable-fpm --prefix=/usr/local/php5.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><code>--enable-fpm</code> 用来来激活对 FPM 的支持</li></ol><p>  <code>--with-apxs2</code> 该参数作用是把php的解释模块编译成so 文件，并自动添加到 Apache的modules中，并自动在 <code>httpd.conf</code> 中加入对应的加载指令<code>LoadModule php5_module modules/libphp5.so</code></p><blockquote><p><strong>报错1：</strong> 在运行 <code>./configure</code> 时可能会报以下这样的错误。提示我们 运行不了 <code>apxs</code> 这个工具。</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">Sorry, I cannot run apxs.  Possible reasons follow:1 Perl is not installed2 apxs was not found. Try to pass the path using --with-apxs2=/path/to/apxs3 Apache was not built using --enable-so (the apxs usage page is displayed)The output of /usr/local/apache2/bin/apxs follows:./configure: /usr/local/apache2/bin/apxs: /replace/with/path/to/perl/interpreter: bad interpreter: No such file or directoryconfigure: error: Aborting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>之前我们在Apache模块化体系的小结中介绍过 <code>apxs</code> 实际是一个 perl 脚本。上面报错中 <code>/replace/with/path/to/perl/interpreter</code> 提示我们找不到这个文件，<br>这行实际是 perl 脚本的声明，我们需要将它改成我们服务器perl脚本的地址。</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ php-5.6.25]# which perl/usr/bin/perl[root@iZ23a3ua2stZ php-5.6.25]# vi /usr/local/apache2/bin/apxs#将第一行 `#!/replace/with/path/to/perl/interpreter` 改成 `#!/usr/bin/perl`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>报错2：</strong> configure: error: xml2-config not found. Please check your libxml2 installation.<br>提示我们缺少 <code>libxml2</code>。安装 <code>libxml2</code>.</p></blockquote><pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ php-5.6.25]#yum install libxml2[root@iZ23a3ua2stZ php-5.6.25]#yum install libxml2-devel -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  <code>./configure</code> 成功会有如下显示。</p><pre class="line-numbers language-sh"><code class="language-sh">+--------------------------------------------------------------------+| License:                                                           || This software is subject to the PHP License, available in this     || distribution in the file LICENSE.  By continuing this installation || process, you are bound by the terms of this license agreement.     || If you do not agree with the terms of this license, you must abort || the installation process at this point.                            |+--------------------------------------------------------------------+Thank you for using PHP.config.status: creating php5.specconfig.status: creating main/build-defs.hconfig.status: creating scripts/phpizeconfig.status: creating scripts/man1/phpize.1config.status: creating scripts/php-configconfig.status: creating scripts/man1/php-config.1config.status: creating sapi/cli/php.1config.status: creating sapi/fpm/php-fpm.confconfig.status: creating sapi/fpm/init.d.php-fpmconfig.status: creating sapi/fpm/php-fpm.serviceconfig.status: creating sapi/fpm/php-fpm.8config.status: creating sapi/fpm/status.htmlconfig.status: creating sapi/cgi/php-cgi.1config.status: creating ext/phar/phar.1config.status: creating ext/phar/phar.phar.1config.status: creating main/php_config.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>编译</p><pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ php-5.6.25]#make && make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功安装</p><pre><code>Build complete.Don&#39;t forget to run &#39;make test&#39;.Installing PHP SAPI module:       apache2handler/usr/local/apache2/build/instdso.sh SH_LIBTOOL=&#39;/usr/local/apache2/build/libtool&#39; libphp5.la /usr/local/apache2/modules/usr/local/apache2/build/libtool --mode=install install libphp5.la /usr/local/apache2/modules/libtool: install: install .libs/libphp5.so /usr/local/apache2/modules/libphp5.solibtool: install: install .libs/libphp5.lai /usr/local/apache2/modules/libphp5.lalibtool: install: warning: remember to run `libtool --finish /root/php-5.6.25/libs&#39;chmod 755 /usr/local/apache2/modules/libphp5.so[activating module `php5&#39; in /usr/local/apache2/conf/httpd.conf]Installing shared extensions:     /usr/local/php5.6/lib/php/extensions/no-debug-zts-20131226/Installing PHP CLI binary:        /usr/local/php5.6/bin/Installing PHP CLI man page:      /usr/local/php5.6/php/man/man1/Installing PHP FPM binary:        /usr/local/php5.6/sbin/Installing PHP FPM config:        /usr/local/php5.6/etc/Installing PHP FPM man page:      /usr/local/php5.6/php/man/man8/Installing PHP FPM status page:   /usr/local/php5.6/php/php/fpm/Installing PHP CGI binary:        /usr/local/php5.6/bin/Installing PHP CGI man page:      /usr/local/php5.6/php/man/man1/Installing build environment:     /usr/local/php5.6/lib/php/build/Installing header files:           /usr/local/php5.6/include/php/Installing helper programs:       /usr/local/php5.6/bin/program: phpizeprogram: php-configInstalling man pages:             /usr/local/php5.6/php/man/man1/page: phpize.1page: php-config.1Installing PEAR environment:      /usr/local/php5.6/lib/php/[PEAR] Archive_Tar    - installed: 1.4.0[PEAR] Console_Getopt - installed: 1.4.1[PEAR] Structures_Graph- installed: 1.1.1[PEAR] XML_Util       - installed: 1.3.0[PEAR] PEAR           - installed: 1.10.1Wrote PEAR system config file at: /usr/local/php5.6/etc/pear.confYou may want to add: /usr/local/php5.6/lib/php to your php.ini include_path/root/php-5.6.25/build/shtool install -c ext/phar/phar.phar /usr/local/php5.6/binln -s -f phar.phar /usr/local/php5.6/bin/pharInstalling PDO headers:           /usr/local/php5.6/include/php/ext/pdo/</code></pre></li><li><p>设置配置文件</p><pre><code>cp php.ini-development /usr/local/php5.6/lib/php.ini</code></pre></li></ol><h3 id="mod-fastcgi-模块安装"><a href="#mod-fastcgi-模块安装" class="headerlink" title="mod_fastcgi 模块安装"></a>mod_fastcgi 模块安装</h3><ol><li>下载、解压<br><a href="http://n.sinaimg.cn/games/3ece443e/20160907/mod_fastcgi-2.4.6.tar.gz">mod_fastcgi-2.4.6.tar.gz</a><pre><code>[root@iZ23a3ua2stZ ~]#wget http://n.sinaimg.cn/games/3ece443e/20160907/mod_fastcgi-2.4.6.tar.gz[root@iZ23a3ua2stZ ~]#tar -zxvf mod_fastcgi-2.4.6.tar.gzcd mod_fastcgi-2.4.6</code></pre></li><li>编译、安装</li></ol><ul><li>查看安装说明<pre><code>[root@iZ23a3ua2stZ ~]#cd mod_fastcgi-2.4.6[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]##查看 安装说明文件 (Apache 1.x请查看 INSTALL 文件)[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]#vi INSTALL.AP2  ···$ cd &lt;mod_fastcgi_dir&gt;$ cp Makefile.AP2 Makefile$ make$ make installIf your Apache2 installation isn&#39;t in /usr/local/apache2, thenset the top_dir variable when running make (or edit theMakefile), e.g.$ make top_dir=/opt/httpd/2.0.40Add an entry to httpd.conf like this:LoadModule fastcgi_module modules/mod_fastcgi.so···</code></pre>虽然说明文件里描述的很清楚，但我们按照里面的步骤进行编译时，会产生报错。于是找了一大圈问题，发现在 <code>apache2.4</code> 下安装 <code>mod_fastcgi 2.4.6</code> 编译时汇报错，需要打个补丁。</li></ul><ol start="3"><li><p>打补丁<br><a href="http://n.sinaimg.cn/games/3ece443e/20160907/byte-compile-against-apache24.diff">补丁下载地址</a></p><pre class="line-numbers language-sh"><code class="language-sh">[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]#wget http://n.sinaimg.cn/games/3ece443e/20160907/byte-compile-against-apache24.diff[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]#patch -p1 < byte-compile-against-apache24.diff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>继续编译、安装</p><pre><code>[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]#make[root@iZ23a3ua2stZ mod_fastcgi-2.4.6]#make install</code></pre><p>然后查看<code>/usr/local/apache2/modules/</code> 下是否已经编译成功 <code>mod_fastcgi.so</code>，<br>并在 <code>httpd.conf</code> 中添加 <code>LoadModule fastcgi_module modules/mod_fastcgi.so</code> 指令。</p></li></ol><h2 id="各种模式配置"><a href="#各种模式配置" class="headerlink" title="各种模式配置"></a>各种模式配置</h2><h3 id="模块模式（最简单）"><a href="#模块模式（最简单）" class="headerlink" title="模块模式（最简单）"></a>模块模式（最简单）</h3><ul><li>在 <code>httpd.conf</code> 中添加或者开启<pre class="line-numbers language-ini"><code class="language-ini">LoadModule php5_module modules/libphp5.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>然后在 <code>httpd.conf</code> 中找到 <code>&lt;IfModule mime_module&gt;</code> 配置段，在其中添加<pre class="line-numbers language-ini"><code class="language-ini">AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>重启 Apache ,在站点目录下添加 <code>index.php</code><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>通过浏览器访问该文件，能够正确输出，则说明配置成功。<blockquote><p>这时 <code>phpinfo();</code> 输出的 <code>Server API</code> 应该为 <code>Apache 2.0 Handler</code>.</p></blockquote></li></ul><h3 id="CGI模式"><a href="#CGI模式" class="headerlink" title="CGI模式"></a>CGI模式</h3><ul><li><p>在 <code>httpd.conf</code> 中添加或者开启</p><pre class="line-numbers language-ini"><code class="language-ini">LoadModule cgid_module modules/mod_cgid.soLoadModule actions_module modules/mod_actions.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>mod_cgid</code> ,CGI 处理模块。在某些Unix操作系统上，在多线程服务器fork一个进程是一个代价非常大的操作，因为新进程将会复制父进程所有的线程。为了避免每次CGI调用都进行这样代价大的操作。mod_cgid 采用外部守护进程来负责分派子进程来运行CGI脚本。主服务器使用Unix套接字来与此守护进程进行通信。</p></blockquote><blockquote><p>如果在Apache编译过程中选择了多线程MPM，那么Apache将会默认安装mod_cgid模块，而不是mod_cgi。但在用户配置使用层面，mod_cgid 和 mod_cgi 基本相同，唯一例外的是，mod_cgid 通过指令 ScriptSock 给socket命名用于与CGI守护进程通信。</p></blockquote><blockquote><p><code>mod_actions</code> ,模块提供基于基于媒体类型或请求方法来执行CGI脚本的方法。该模块引入 <code>Action</code> 和 <code>Script</code> 两个指令。</p></blockquote></li><li><p>然后在 <code>httpd.conf</code> 中找到 <code>&lt;IfModule mime_module&gt;</code> 配置段，在其中添加</p><pre class="line-numbers language-ini"><code class="language-ini">AddHandler php-cgi .phpAction php-cgi "/cgi-bin/php-cgi"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后在 <code>httpd.conf</code> 中找到 <code>&lt;IfModule cgid_module&gt;</code> 配置段，在其中添加</p><pre class="line-numbers language-ini"><code class="language-ini">&lt;IfModule cgid_module>  Scriptsock /var/run/cgid.sock&lt;/IfModule><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重启 Apache ,在站点目录下添加 <code>index.php</code></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过浏览器访问该文件，能够正确输出，则说明配置成功。</p><blockquote><p>这时 <code>phpinfo();</code> 输出的 <code>Server API</code> 应该为 <code>CGI/FastCGI</code>.</p></blockquote></li></ul><h3 id="FastCGI模式，用Apache内置进程管理器"><a href="#FastCGI模式，用Apache内置进程管理器" class="headerlink" title="FastCGI模式，用Apache内置进程管理器"></a>FastCGI模式，用Apache内置进程管理器</h3><ul><li><p>在 <code>httpd.conf</code> 中添加或者开启</p><pre class="line-numbers language-ini"><code class="language-ini">LoadModule fastcgi_module modules/mod_fastcgi.soLoadModule actions_module modules/mod_actions.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后在 <code>httpd.conf</code> 中添加 <code>&lt;IfModule fastcgi_module&gt;</code> 配置段</p><pre class="line-numbers language-ini"><code class="language-ini">&lt;IfModule fastcgi_module> FastCgiServer /usr/local/apache2/cgi-bin/php-cgi -processes 20 AddType application/x-httpd-php .php AddHandler php-fastcgi .php Action php-fastcgi /cgi-bin/php-cgi&lt;/IfModule><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>-processes 20</code> ,配置启动的进程数</p></blockquote></li><li><p>重启 Apache ,执行 <code>ps aux | grep php</code> 查看相应 php-cgi 进程是否启动</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZ23a3ua2stZ apache2<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps aux | grep php</span>daemon   21382  0.0  0.5  42104  5604 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21435  0.0  0.4  42104  4724 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21436  0.0  0.4  42104  4732 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21437  0.0  0.4  42104  4724 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21438  0.0  0.4  42104  4724 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21439  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21440  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21441  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21442  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21443  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21444  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21445  0.0  0.4  42104  4724 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21446  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21447  0.0  0.4  42104  4724 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21448  0.0  0.4  42104  4728 ?        S    11:30   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21449  0.0  0.4  42104  4728 ?        S    11:31   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21450  0.0  0.4  42104  4724 ?        S    11:31   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21451  0.0  0.4  42104  4724 ?        S    11:31   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21452  0.0  0.4  42104  4732 ?        S    11:31   0:00 /usr/local/apache2/cgi-bin/php-cgidaemon   21453  0.0  0.4  42104  4728 ?        S    11:31   0:00 /usr/local/apache2/cgi-bin/php-cgiroot     21455  0.0  0.0 112668   984 pts/0    S+   11:31   0:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在站点目录下添加 <code>index.php</code></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过浏览器访问该文件，能够正确输出，则说明配置成功。</p><blockquote><p>这时 <code>phpinfo();</code> 输出的 <code>Server API</code> 应该为 <code>CGI/FastCGI</code>.</p></blockquote></li></ul><h3 id="FastCGI模式，使用php-fpm进程管理器"><a href="#FastCGI模式，使用php-fpm进程管理器" class="headerlink" title="FastCGI模式，使用php-fpm进程管理器"></a>FastCGI模式，使用php-fpm进程管理器</h3><ul><li><p>在 <code>httpd.conf</code> 中添加或者开启</p><pre class="line-numbers language-ini"><code class="language-ini">LoadModule fastcgi_module modules/mod_fastcgi.soLoadModule actions_module modules/mod_actions.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>然后在 <code>httpd.conf</code> 中添加 <code>&lt;IfModule fastcgi_module&gt;</code> 配置段</p><pre class="line-numbers language-ini"><code class="language-ini">&lt;IfModule fastcgi_module> FastCgiExternalServer /usr/local/apache2/cgi-bin/php-cgi -host 127.0.0.1:9000 AddType application/x-httpd-php .php AddHandler php-fastcgi .php Action php-fastcgi /cgi-bin/php-cgi&lt;/IfModule><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>-host 127.0.0.1:9000</code> ,是php-fpm的开启端口，所以我们还需要把php-fpm打开。</p></blockquote></li><li><p>启动 <code>php-fpm</code></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZ23a3ua2stZ apache2<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/php5.6/sbin/php-fpm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>/usr/local/php/sbin/php-fpm{start|stop|quit|restart|reload|logrotate}</p><p>–start 启动php的fastcgi进程<br>–stop 强制终止php的fastcgi进程<br>–quit 平滑终止php的fastcgi进程<br>–restart 重启php的fastcgi进程<br>–reload 重新平滑加载php的php.ini<br>–logrotate 重新启用log文件</p></blockquote></li><li><p>重启 Apache ,执行 <code>ps aux | grep php</code> 查看相应 php-cgi 进程是否启动</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZ23a3ua2stZ apache2<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps aux | grep php</span><span class="token punctuation">[</span>root@iZ23a3ua2stZ apache2<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps aux | grep php</span>root     21680  0.0  0.3 147920  3660 ?        Ss   12:41   0:00 php-fpm: master process <span class="token punctuation">(</span>/usr/local/php5.6/etc/php-fpm.conf<span class="token punctuation">)</span>nobody   21681  0.0  0.3 147920  3312 ?        S    12:41   0:00 php-fpm: pool wwwnobody   21682  0.0  0.4 147920  4888 ?        S    12:41   0:00 php-fpm: pool wwwroot     21684  0.0  0.0 112664   980 pts/3    S+   12:42   0:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在站点目录下添加 <code>index.php</code></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过浏览器访问该文件，能够正确输出，则说明配置成功。</p><blockquote><p>这时 <code>phpinfo();</code> 输出的 <code>Server API</code> 应该为 <code>FPM/FastCGI</code>.</p></blockquote></li></ul><h2 id="各种模式比较"><a href="#各种模式比较" class="headerlink" title="各种模式比较"></a>各种模式比较</h2><blockquote><p>有空再整理。。。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache通过不同的方式，能够实现对PHP支持。常见的几种支持方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块支持（handler模式）&lt;/li&gt;
&lt;li&gt;CGI模块&lt;/li&gt;
&lt;li&gt;FastCGI模式，用Apache内置进程管理器&lt;/li&gt;
&lt;li&gt;FastCGI模式，用php-fpm进程管理器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="FastCGI" scheme="https://weizhimiao.github.io/tags/FastCGI/"/>
    
    <category term="CGI" scheme="https://weizhimiao.github.io/tags/CGI/"/>
    
    <category term="Apache&amp;PHP" scheme="https://weizhimiao.github.io/tags/Apache-PHP/"/>
    
  </entry>
  
  <entry>
    <title>Apache 虚拟主机配置</title>
    <link href="https://weizhimiao.github.io/2016/09/05/Apache%20%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <id>https://weizhimiao.github.io/2016/09/05/Apache%20%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE/</id>
    <published>2016-09-05T14:10:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟主机指的是在单一机器上运行多个网站。</p><ul><li>常见的共有三种不同的配置方式。<ul><li>基于域名</li><li>基于端口（需要增加相对应的 <code>Listen</code> 指令）</li><li>基于IP</li></ul></li><li>动态虚拟主机配置。</li></ul><span id="more"></span><h2 id="常规配置方式"><a href="#常规配置方式" class="headerlink" title="常规配置方式"></a>常规配置方式</h2><h3 id="在httpd-conf-文件中启用-httpd-vhost-conf-配置文件"><a href="#在httpd-conf-文件中启用-httpd-vhost-conf-配置文件" class="headerlink" title="在httpd.conf 文件中启用 httpd-vhost.conf 配置文件"></a>在<code>httpd.conf</code> 文件中启用 <code>httpd-vhost.conf</code> 配置文件</h3><pre class="line-numbers language-ini"><code class="language-ini"># Virtual hostsInclude conf/extra/httpd-vhosts.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="配置-httpd-vhosts-conf"><a href="#配置-httpd-vhosts-conf" class="headerlink" title="配置 httpd-vhosts.conf"></a>配置 <code>httpd-vhosts.conf</code></h3><ol><li>基于域名配置<pre class="line-numbers language-ini"><code class="language-ini">&lt;VirtualHost *:80> ServerName domain1.com DocumentRoot  "D:\data\domain1.com" &lt;Directory />     Options +Indexes +FollowSymLinks +ExecCGI     AllowOverride All     Order allow,deny     Allow from all     Require all granted &lt;/Directory> DirectoryIndex index.php index.html&lt;/VirtualHost><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>注：( <code>Require all granted</code> )</strong></p><blockquote><p>Apache 2.4 及以上版本访问控制与2.2有所变换，所以在2.4+的版本需要在目录下添加 <code>Require all granted</code> 否则会出现访问不到的情况。<br><a href="http://httpd.apache.org/docs/2.4/upgrading.html">更多详情，点击查看</a></p></blockquote><ol start="2"><li>基于端口配置</li></ol><ul><li>基于端口的配置需要先在 <code>httpd.conf</code> 中添加相应端口的 <code>Listen</code> 指令。<pre class="line-numbers language-ini"><code class="language-ini">#httpd.confListen 81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><code>httpd-vhosts.conf</code><pre class="line-numbers language-ini"><code class="language-ini">&lt;VirtualHost *:81>#ServerName 10.235.65.14:81DocumentRoot  "D:\data\domain3.com"&lt;Directory />    Options +Indexes +FollowSymLinks +ExecCGI    AllowOverride All    Order allow,deny    Allow from all    Require all granted&lt;/Directory>DirectoryIndex index.php index.html&lt;/VirtualHost><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="3"><li>基于IP地址配置<pre class="line-numbers language-ini"><code class="language-ini">&lt;VirtualHost *:80> ServerName 10.235.65.14 DocumentRoot  "D:\data\domain2.com" &lt;Directory />     Options +Indexes +FollowSymLinks +ExecCGI     AllowOverride All     Order allow,deny     Allow from all     Require all granted &lt;/Directory> DirectoryIndex index.php index.html&lt;/VirtualHost><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>配置完成之后，需要重启 Apache 配置才会生效。在浏览器中输入相应的域名，IP或者端口进行查看，能正常输出我们分别设置的内容，则说明我们配置成功。</p><h2 id="动态虚拟主机配置"><a href="#动态虚拟主机配置" class="headerlink" title="动态虚拟主机配置"></a>动态虚拟主机配置</h2><p>上面谈到的虚拟主机配置方式，每次配置完成之后都必须重启 Apache 才能生效。并且当我们要配置多个虚拟主机时就需要增加多个 <code>&lt;VirtualHost &gt;···&lt;/VirtualHost&gt;</code> ,显得繁琐。那么有没有一种更好，更有效的方式来进行配置呢？</p><p><code>mod_vhost_alias</code> 模块为我们提供了一种动态配置虚拟主机的方式。我们只需设置一个目录，将不同的站点资源按照一定的规则放到该目录下即可。并且不用修改配置文件，且不用重新启动Apache服务器。</p><p>动态配置优缺点：</p><ul><li>优点：<ul><li>配置文件更小，意味着Apache启动会更快，并且占用内存更少。正重要的是，更小的配置结构更易于维护，我们人为配置出错的机会更小。</li><li>添加新的虚拟主机，我们只需要根据相应的规则在指定的，目录下面创建文件即可。不需要重新配置和启动Apache。</li></ul></li><li>缺点：<ul><li>无法针对每个虚拟主机设置不同的日志文件。如果我们有很多的虚拟主机这确实是一个非常糟糕的事情。我们可以选择将日志记录到一个管道或者FIFO，在另一端再将日志文件按照不同的虚拟主机进行分割。比如 <a href="http://httpd.apache.org/docs/current/programs/split-logfile.html"><code>aplit-logfile</code></a> 工具。</li></ul></li></ul><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><ul><li>准备<ul><li>在 <code>httpd.conf</code> 中开启 <code>mod_vhost_alias.so</code> 模块,并添加一个新的子配置文件 <code>httpd-vhost-alias.conf</code> 方便我们配置。<pre class="line-numbers language-ini"><code class="language-ini">#开启 mod_vhost_alias.so 模块LoadModule vhost_alias_module libexec/apache2/mod_vhost_alias.so#去掉 LoadModule 前面的注释···#添加子配置文件#Include /private/etc/apache2/extra/httpd-vhost-alias.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>配置<ul><li>打开子配置文件 <code>httpd-vhost-alias.conf</code> ，添加以下配置。<pre class="line-numbers language-ini"><code class="language-ini">UseCanonicalName OffVirtualDocumentRoot /data1/www/%0&lt;Directory "/data1/www/">Options NoneAllowOverride NoneOrder allow,denyAllow from all&lt;/Directory><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>保存，并重启 Apache 。</li></ul></li><li>测试<ul><li>分别绑定不同的域名到服务器，并在 <code>/data1/www/</code> 目录下按照不同域名新建目录，将个站点的资源分别放进相应的目录。<br>```ini</li></ul>127.0.0.1 domain1.com<br>127.0.0.1 domain2.com<br>127.0.0.1 domain3.com<pre><code>```bash/data1/www/domain1.com/index.html   #this is domain1.com test text/data1/www/domain2.com/index.html   #this is domain2.com test text</code></pre><ul><li>浏览器分别访问 <code>domain1.com</code> 和 <code>domain2.com </code> ，查看是否是否能够正确显示出相应内容。</li><li>在 <code>/data1/www/</code> 目录下继续添加 <code>/data1/www/domain3.com/index.html</code> ,然后继续用浏览器访问 <code>domain3.com</code> ，查看是否能将 <code>/data1/www/domain3.com/index.html</code> 的内容输出。</li></ul></li></ul><ul><li><a href="http://httpd.apache.org/docs/current/vhosts/mass.html">更多配置参数及方法，请查看</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟主机指的是在单一机器上运行多个网站。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常见的共有三种不同的配置方式。&lt;ul&gt;
&lt;li&gt;基于域名&lt;/li&gt;
&lt;li&gt;基于端口（需要增加相对应的 &lt;code&gt;Listen&lt;/code&gt; 指令）&lt;/li&gt;
&lt;li&gt;基于IP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态虚拟主机配置。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Apache虚拟主机" scheme="https://weizhimiao.github.io/tags/Apache%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>.htaccess 文件功能及配置介绍</title>
    <link href="https://weizhimiao.github.io/2016/09/05/htaccess%20%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/09/05/htaccess%20%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/</id>
    <published>2016-09-05T02:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>URL重定向是<code>.htaccess</code> 的重头戏，它可以将长地址转为短地址、将动态地址转为静态地址、重定向丢失的页面、防止盗链、实现自动语言转换等等。</p><p><strong>难点：</strong> 正则表达式的运用和理解。</p><span id="more"></span><h2 id="准备-mod-rewrite"><a href="#准备-mod-rewrite" class="headerlink" title="准备 mod_rewrite"></a>准备 mod_rewrite</h2><p>要实现上述功能，首先得装上mod_rewrite 模块，并确保启用了该模块。</p><p>一般我们会这样设置。</p><pre><code>&lt;IfModule mod_rewrite.c&gt;  Options +FollowSymlinks  RewriteEngine on  ...&lt;IfModule&gt;</code></pre><p><em><strong>Tips:</strong></em></p><ul><li>FollowSymlinks:必须启用，这是rewrite引擎的安全要求。</li><li>RewriteEngine：用于启用rewrite引擎。</li></ul><h2 id="URL重写及重定向"><a href="#URL重写及重定向" class="headerlink" title="URL重写及重定向"></a>URL重写及重定向</h2><p>利用<code>.htaccess</code> 文件可以实现对URL的重写（rewrite）与重定向（redirect）</p><ol><li>将<code>.html</code> 映射到<code>.php</code><pre><code>Options +FollowSymlinksRewriteEngine onRewriteRule ^(.*)\.html$ $1.php [NC]</code></pre></li></ol><p><em><strong>注</strong></em></p><ul><li>必须保证服务器上有对应的<code>.php</code> 文件，否则会报 404</li><li>浏览器和搜索引擎可同事用<code>.html</code> 和<code>.php</code> 访问到网页。</li><li>[NC] 表示不区分大小写</li></ul><ol start="2"><li>临时重定向（R=302）与永久重定向（R=301）<pre><code>RewriteEngine onRewriteBase /RewriteRule ^(.*)\.html $1.php [R,NC,L]</code></pre></li></ol><p><em><strong>注</strong></em></p><ul><li><p>RewriteBase 定义了重写基准目录。</p><blockquote><p>例如，如虚拟机站点设在 /var/www目录下，删除这行这行将会导致重定向到 <a href="http://your-domain/var/www/1.php">http://your-domain/var/www/1.php</a>. 显然这不是我们想要的。如果RewriteBase /base/，那么将会重定向到<a href="http://your-domain/base/1.php">http://your-domain/base/1.php</a>.</p></blockquote></li><li><p>对于重写基准目录，我们还可以将 <code>$1.php</code> 变成 <code>/$1.php</code> 实现直接变换，这是就可以将 <code>RewriteBase</code> 省略。</p></li><li><p>字母<code>L</code>，表示如果能匹配到本条规则，则本条规则是最后一条（Last），忽略之后的规则。</p></li></ul><p>  永久重定向（R=301）</p><pre><code>RewriteEngine onRewriteRule ^(.*)$ http://newdomain/$1 [R=301,NC,L]</code></pre><ol start="3"><li><p>为什么要用重定向</p></li><li><p>通过重定向，浏览器知道页面位置发生变化，从而会改变地址栏到新的地址。</p></li><li><p>通过重定向，搜索引擎能够发现位置发生变化，从而进行更新。</p></li><li><p>R=302，R=301都是亲搜索引擎的，是SEO的一个重要手段。</p></li><li><p><strong>URL重写用于将页面映射到本站的另一页面，而重写到另一个域名下，则安重定向处理。</strong></p></li><li><p>长短地址处理   </p><blockquote><p>利用URL重写，方便实现长短地址转换。</p></blockquote></li></ol><pre><code>RewriteEngine onRewriteRule ^grab /public/files/download/download.php</code></pre><p>若访问 <a href="http://your-domain/grab?file=my.zip">http://your-domain/grab?file=my.zip</a>, 则页面会实际执行该页面 <a href="http://your-domain/public/files/download/download.php?file=my.zip">http://your-domain/public/files/download/download.php?file=my.zip</a><br>5. 去掉WWW</p><pre><code>RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^(.*)$RewriteRule (.*) http://www\.%1/$1 [R=301,L]</code></pre><p><em><strong>注:</strong></em></p><ul><li>RewriteCond 定义了规则的生效条件。即，一个RewriteRule规则之前可以有一个或者多个RewriteCond指令。</li><li>语法：RewriteCond TestString CondPattern [flags]</li></ul><ol start="6"><li><p>加上www</p><pre><code>RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^(.*)$RewriteRule (.*) http://www\.%1/$1 [R=301,L]</code></pre></li><li><p>支持多域名访问</p></li></ol><blockquote><p>如果有些主机不支持多域名，那么<code>.htaccess</code> 或许也可以解决。</p></blockquote><pre><code>#one.comRewriteCond %&#123;HTTP_HOST&#125; one.comRewriteCond %&#123;REQUEST_URI&#125; !^/oneRewriteRule ^(.*)$ /one/$1 [L]#two.comRewriteCond %&#123;HTTP_HOST&#125; two.comRewriteCond %&#123;REQUEST_URI&#125; !^/twoRewriteRule ^(.*)$ /two/$1 [L]</code></pre><h2 id="改写查询字符串-QUERY-STRING"><a href="#改写查询字符串-QUERY-STRING" class="headerlink" title="改写查询字符串 QUERY_STRING"></a>改写查询字符串 QUERY_STRING</h2><p>所谓查询字符串，就是值URL问号之后的部分。</p><ol><li>利用QSA转换 QUERY_STRING<pre><code>RewriteEngine onRewriteRule /page/(.+) /page.php?page=$1 [QSA]</code></pre></li></ol><p><em><strong>注：</strong></em></p><ol><li><p>将会把 <code>/page/123?one=two</code> 映射到 <code>/page.php?page=123&amp;one=two</code>.</p></li><li><p>如果没有[QAS] 标志，则会映射到<code>page.php?page=123</code>.</p></li><li><p>如果没有用到小括号正则表达式，就不需要 QSA</p><blockquote><p>例，将 <code>/simple/flat/link </code> =&gt; server-side.php?first-var=flat&amp;second-var=link</p></blockquote><pre><code>RewriteEngine onRewriteRule ^/simple/([^/]+)/([^/]+)/? /server-side.php?first-var=$1&amp;second-var=$2 [QSA]</code></pre></li><li><p>利用RewriteCond 改写 QUERY_STRING</p><pre><code>RewriteEngine OnRewriteCond %&#123;QUERY_STRING&#125; foo=(.*)RewriteRule ^grab(.*) /page.php?bar=%1</code></pre></li></ol><ul><li>该规则将访问请求<a href="http://mysite/grab?foo=bar%E8%BD%AC%E6%8D%A2%E4%B8%BAhttp://mysite/page.php?bar=bar">http://mysite/grab?foo=bar转换为http://mysite/page.php?bar=bar</a></li><li>RewriteCond用于捕获查询字符串（QUERY_STRING）中变量foo的值，并存储在%1中</li><li>QUERY_STRING是Apache定义的“变量=值”向量（数组）</li></ul><ol start="3"><li>RewriteCond与QSA双剑齐发<pre><code>RewriteEngine OnRewriteCond %&#123;QUERY_STRING&#125; foo=(.+)RewriteRule ^grab/(.*) /%1/index.php?file=$1 [QSA]</code></pre></li></ol><ul><li>会把/grab/foobar.zip?level=5&amp;foo=bar 映射到 /bar/index.php?file=foobar.zip&amp;level=5&amp;foo=bar</li><li>转换后根目录是bar目录</li><li>foobar.zip?level=5中的“问号”变成了foobar.zip&amp;level=5中的“与”符号</li></ul><ol start="4"><li>剥离查询字符串<blockquote><p>只需在要开始剥离的链接后面加个“问号”，并且不要启用QSA标志，就可剥离查询字符串</p></blockquote></li></ol><pre><code>RewriteEngine On# Whatever QS isRewriteCond %&#123;QUERY_STRING&#125; .# I don&#39;t want it with Question markRewriteRule foo.php(.*) /foo.php? [L]</code></pre><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ol><li>文件访问控制<blockquote><p>利用Order、Files及FilesMatch命令实现的访问控制可以满足大部分要求，但是当用户被拒绝时，他们看到的是硕大的“403 Forbidden”，如果你不想伤害用户的感情，就需要显示一些别的东西，通过Rewrite就可以实现这个特性：</p></blockquote></li></ol><pre><code>RewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !^(.+)\.css$RewriteCond %&#123;REQUEST_FILENAME&#125; !^(.+)\.js$RewriteCond %&#123;REQUEST_FILENAME&#125; !special.zip$RewriteRule ^(.+)$ /chat/ [NC]</code></pre><ul><li>该规则将仅允许用户请求.css, .js类型的文件，还有special.zip文件</li><li>RewriteRule 后面指定了限制规则：映射到/char/目录下处理</li><li>RewriteCond 后面的“感叹号”(!)起到了“否定”作用，它表明，对不满足后面正则表达式者应用RewriteRule规则，也就是对当前类型的文件将不应用规则</li><li>RewriteCond 之间是以逻辑“与”连接的，也就是只有当三个条件都不满足时才执行RewriteRule</li><li>该规则也会限制访问.htm, .jpg等格式</li><li>该规则不可以放在虚拟站点根目录（/）下，否则会死循环</li><li>如果是二级目录，如/test/，那么传入RewriteCond的参数是以/test/开始的，因此从(.+)获得的文件名也含有/test/，读者必须对此多加小心</li><li>要想仅获得文件名，可以将(.+)替换成([^/]+)，并且去掉符号^，如下所示：<pre><code>RewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !([^/]+)\.css$RewriteCond %&#123;REQUEST_FILENAME&#125; !([^/]+)\.js$RewriteRule ^(.+)$ /chat/ [NC]</code></pre></li></ul><ol start="2"><li>用.htaccess阻止User-agent<blockquote><p>User-agent用于浏览器向服务器“自报家门”，更确切的说是所有HTTP客户端都得用User-agent向服务器“自报家门”，以便服务器对不同的客户端作出不同响应。比如，某站点可能需要对浏览器、搜索引擎crawl还有各类下载工具作出不同的响应。服务器就是通过所谓的User-agent进行区分的。<br>如果你的服务器提供某些资源的下载，那么你就必须多加小心诸如“迅雷”等下载软件，因为它们可能把你网站资源吸干，并且影响你的正常访客访问。</p></blockquote></li></ol><p>  为此，我们可以利用Rewrite限制某些UA的访问：</p><pre><code>RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; 2.0.50727 [NC]RewriteRule . abuse.txt [L]</code></pre><ul><li>该规则限制“迅雷”客户端下载资源，并将下载文件重置到abuse.txt</li><li>HTTP_USER_AGENT是Apache的内置变量</li><li>2.0.50727是迅雷User-agent的特征字符串</li><li>RewriteRule后面的“点”表示“任意URI”，也就是不管请求的是什么，都输出abuse.txt</li></ul><p>  通常，我们不会仅限制一个UA。利用[OR]即可实现对多个UA作出统一处理：</p><pre><code>RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; 2.0.50727 [NC,OR]RewriteCond %&#123;HTTP_USER_AGENT&#125; ^BlackWidow [NC,OR]# etc..RewriteCond %&#123;HTTP_USER_AGENT&#125; ^Net\ Vampire [NC]RewriteRule . abuse.txt [L]</code></pre><ol start="3"><li>用.htaccess阻止盗链(hot-linking)<blockquote><p>盗链，特别是图片，是非常可耻的！哪怕将图片复制到自己服务器上，也比盗用他人的图片链接来得光彩！</p></blockquote></li></ol><p>  .htaccess的Rewrite功能可以提供非常简单、有效的方法阻止这种可耻行为：</p><pre><code>RewriteEngine OnRewriteCond %&#123;HTTP_REFERER&#125; !^$RewriteCond %&#123;HTTP_REFERER&#125; !^http://(www\.)?lesca\.me/ [NC]RewriteCond %&#123;REQUEST_URI&#125; !hotlink\.png [NC]RewriteRule .*\.(gif|jpg|png)$ /hotlink.png [NC]</code></pre><p>简单解释一下该规则的功能：</p><ul><li>除本站以外其他网站都不得引用本站图片，具体可以理解为</li><li>如果引用站点为“空”或者是“本站”，或者，所引用对象是“hotlink.png”，那么就允许访问</li><li>再次提醒，RewriteCond之间默认的逻辑连接词是逻辑“与”</li><li>这里的难点是理解逻辑转换，即德·摩根定律</li></ul><h2 id="htaccess-缺点"><a href="#htaccess-缺点" class="headerlink" title="htaccess 缺点"></a>htaccess 缺点</h2><p>说了这么多<code>.htaccess</code> 可以实现这么多的功能，那么它有没有什么缺点呢?</p><p>答案是，当然有。由于开启了<code>.htaccess</code> 文件，当我们访问了一个地址对应到服务器端某个目录之后<code>Apache</code> 会遍历并解析每层目录下的<code>.htaccess</code> 文件，所有对服务器性能会有一定的影响。</p><p>但是具体影响有多大，要不要使用还需要看具体的环境。或者需要进行前后对比在进行选择。</p><h2 id="htaccess-生成工具"><a href="#htaccess-生成工具" class="headerlink" title="htaccess 生成工具"></a>htaccess 生成工具</h2><p>说了这么多，貌似真正配置起来还是非常麻烦。不用着急目前网上有非常多<code>htaccess</code> 在线生成工具，可大大方便我们进行完成各种配置。</p><p>如：<a href="http://htaccess.uuz.cc/">smarty .htaccess :http://htaccess.uuz.cc/</a></p><p><a href="http://lesca.me/archives/htaccess-rewrite.html">转自:Lesca技术宅</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;URL重定向是&lt;code&gt;.htaccess&lt;/code&gt; 的重头戏，它可以将长地址转为短地址、将动态地址转为静态地址、重定向丢失的页面、防止盗链、实现自动语言转换等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难点：&lt;/strong&gt; 正则表达式的运用和理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/tags/Apache/"/>
    
    <category term=".htaccess" scheme="https://weizhimiao.github.io/tags/htaccess/"/>
    
  </entry>
  
  <entry>
    <title>Apache分层与模块化体系结构小结</title>
    <link href="https://weizhimiao.github.io/2016/08/26/Apache%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB%E5%B0%8F%E7%BB%93/"/>
    <id>https://weizhimiao.github.io/2016/08/26/Apache%E5%88%86%E5%B1%82%E4%B8%8E%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB%E5%B0%8F%E7%BB%93/</id>
    <published>2016-08-26T02:10:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache的分层体系结构"><a href="#Apache的分层体系结构" class="headerlink" title="Apache的分层体系结构"></a>Apache的分层体系结构</h2><p>最新版本的Apache按照其功能一般会被划分为五层，</p><ol><li><p>操作系统平台功能层</p><blockquote><p>各操作系统本身提供的底层功能，比如进程、线程管理,进程和线程之间通信、网络套接字通信、文件操作等</p></blockquote></li><li><p>可移植运行库层（操作系统适配层）</p><blockquote><p>封装不同操作系统的底层细节，向上提供统一的接口。</p></blockquote></li><li><p>Apache核心功能层</p><blockquote><p>提供最基本的HTTP服务功能，对其他模块提供对应的API。</p></blockquote></li><li><p>Apache可选功能层</p><blockquote><p>这一层通常指 Apache模块，Apache核心功能层提供不了的功能交给不同的Apache模块来处理。</p></blockquote></li><li><p>Apache第三方功能层</p><blockquote><p>Apache的一些模块中用到的一些第三方开发的类库等</p></blockquote></li></ol><p><img data-src="http://n.sinaimg.cn/games/3ece443e/20160826/apacheFenCengYuMoKuaiHuaTiXiJieGou.png" alt="Apache的分层体系结构"></p><span id="more"></span><p><strong>Apache源码目录结构简介</strong></p><pre><code>build/    #docs/     #包含一些相关文档include/  #包含一些必须的头文件modules/  #包含Apache的各种模块os/       #各种操作系统的依赖文件server/   #Apache核心功能（请求处理、协议处理、多处理模块mpm等）srclib/   #Apache开发和运行需要的基础库（Apr_util,apr,pcre）support/  #一些辅助工具等test/     #APR的测试函数</code></pre><h3 id="操作系统平台功能层"><a href="#操作系统平台功能层" class="headerlink" title="操作系统平台功能层"></a>操作系统平台功能层</h3><p>Apache实质上还是运行在操作系统上面的应用程序，因此必须使用操作系统本身提供的底层功能，比如进程和线程、进程和线程的通信，网络套接字通信和文件操作等。</p><h3 id="可移植运行库（操作系统适配层，APR）"><a href="#可移植运行库（操作系统适配层，APR）" class="headerlink" title="可移植运行库（操作系统适配层，APR）"></a>可移植运行库（操作系统适配层，APR）</h3><p>APR(Apache portable runtime) 是操作系统的适配层，通过APR也实现了Apache的跨平台。因为不同的操作系统提供的底层API不同，也就是实现同一个操作所用的函数方法不同，这时在Apache和操作系统中间设计一个APR，这样APR根据不同的操作系统分别实现一个相同的功能，这样apache可以调用APR的提供的一个API接口。</p><p>例如，如果Apache要创建一个进程，这时会调用 APR中的 apr_proc_create()函数，此时APR会自动识别操作系统的类型根据不同的类型调用操作系统通过的API，如是Unix系列则会调用unix中的fork()方法实现创建进程；如果是windows系统，则调用createProcess()创建进程。</p><p>所以，Apache在处理与操作系统有关的事物时，不用考虑是基于哪一个操作系统，直接用APR的统一API接口就可，具体的由APR来实现跨操作系统。</p><p>实际上任何应用程序都可以借助APR进行跨平台。</p><h3 id="Apache核心功能层"><a href="#Apache核心功能层" class="headerlink" title="Apache核心功能层"></a>Apache核心功能层</h3><ol><li>核心功能层主要实现Apache的基本功能和核心功能，包括读取和响应HTTP请求，处理HTTP协议；核心功能层包括核心程序和核心模块</li></ol><p><strong>核心程序</strong> 主要是实现Apache的基本功能：</p><ul><li>启动和终止apache</li><li>处理配置文件(config.c)</li><li>接受和处理HTTP连接</li><li>读取HTTP请求并对该请求进行处理</li><li>处理HTTP协议</li></ul><p>核心功能层另一个是 <strong>核心模块</strong></p><ol start="2"><li>Apache 最基本的核心功能由apache 核心完成，除此之外，核心无法提供的功能则全部由模块提供。为了允许这些模块能完成控制apache的处理，apache核心程序提供了对应的API；这些API是指每个模块中包含的一系列的函数(核心程序处理HTTP请求的时候用来将信息传递给模块)，以及一些列apr的函数。</li></ol><h3 id="Apache可选功能层"><a href="#Apache可选功能层" class="headerlink" title="Apache可选功能层"></a>Apache可选功能层</h3><p>Apache有很多模块，包括mod_ssl mod_proxy mod_perl ；apache的文件都是C语言开发的，如果有perl脚本写的模块，必须把mod_perl 模块加载，否则不能运行</p><h3 id="Apache第三方功能库"><a href="#Apache第三方功能库" class="headerlink" title="Apache第三方功能库"></a>Apache第三方功能库</h3><p>apahe的一些模块会使用到第三方的开发库，比如 mod_ssl 使用了 openssl；mod_perl 使用了perl 开发库，这些库并不属于apache，是第三方库。</p><h2 id="Apache模块化体系结构"><a href="#Apache模块化体系结构" class="headerlink" title="Apache模块化体系结构"></a>Apache模块化体系结构</h2><p>Apache体系结构的模块化特点，主要体现在第三层（核心功能层）与第四层（可选功能层）。Apache采用模块化体系结构，使它作为一个HTTP服务器的大部分功能都被分割为相互独立的模块，使我们能够通过增加或者删除模块就可以扩展和修改Apache的功能。</p><h3 id="核心模块-amp-可选模块"><a href="#核心模块-amp-可选模块" class="headerlink" title="核心模块&amp;可选模块"></a>核心模块&amp;可选模块</h3><p>Apache中大部分模块都是可选择的，这意味着这些模块的缺失至多影响Apache的功能完整性，而不影响起运行。但有两个模块是必须的，mod_core和mod_so。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><ul><li><strong>mod_core:</strong> 负责处理配置文件中的大部分配置指令，并根据这些指令运行Apache。</li><li><strong>mod_so:</strong> 负责动态加载其余的模块。没有该模块，其余的模块就无法被加载使用。</li><li><strong>MPM模块</strong> 即，多进程处理模块，虽然该模块是一个可选模块，但一般情况下，我们都会使用，所以我们将其也视为核心模块。<blockquote><p>前两个模块我们必须静态编译。mpm模块的话，当我们在编译Apache是已经确定使用某一MPM模块之后通过也可将其采用静态编译的方式进行编译。但是如果我们想要在Apache安装之后动态修改MPM模式的话，那么在Apache编译安装的时候，MPM模块就需要通过动态编译的方式进行编译安装。</p></blockquote></li></ul><h4 id="非核心模块"><a href="#非核心模块" class="headerlink" title="非核心模块"></a>非核心模块</h4><p>一些常见的可选模块：</p><ul><li><p>mod_alias</p><blockquote><p>Provides for mapping different parts of the host filesystem in the document tree and for URL redirection<br>为不同的url地址映射到文件系统的指定位置，即『起别名』</p></blockquote></li><li><p>mod_autoindex</p><blockquote><p>用于生成目录索引</p></blockquote></li><li><p>mod_cache</p><blockquote><p>RFC 2616标准的HTTP缓存的过滤器。是apache中基于URI键的内容动态缓冲(内存或磁盘)。<br>从Apache2.2起，mod_cache和mod_file_cache将不再是试验模块，它们已经足够稳定，可以用于实际生产中了。这些缓冲体系提供了一个强有力的途径来加速原始web服务器(origin webserver)和代理服务器(proxy)的HTTP处理速度。</p></blockquote></li><li><p>mod_cgi</p><blockquote><p> 执行cgi脚本</p></blockquote></li><li><p>mod_dir</p><blockquote><p>目录的索引可以来自两个来源：</p><ul><li>由用户编写的文件，通常被称为 index.html。该DirectoryIndex指令设置该文件的名称。这是由控制 mod_dir。</li><li>否则，由服务器生成的列表。这是通过提供mod_autoindex。</li></ul><p>这两种功能是分开的，这样如果你想你可以完全删除（或更换）自动索引生成。</p><p>当服务器收到一个URL请求的“斜线”重定向发出 <a href="http://servername/foo/dirname%E9%82%A3%E9%87%8C">http://servername/foo/dirname那里</a> dirname是一个目录。目录需要一个结尾斜杠，所以mod_dir发出一个重定向 <a href="http://servername/foo/dirname/%E3%80%82">http://servername/foo/dirname/。</a></p></blockquote></li><li><p>mod_filter</p><blockquote><p>该模块实现输出内容过滤器的智能，上下文相关的配置。例如，Apache可以被配置为处理不同的内容类型通过不同的过滤器，即使当内容类型是不是预先已知的（例如，在一个代理）。</p></blockquote></li><li><p>mod_include</p><blockquote><p>服务器端包含</p></blockquote></li><li><p>mod_isapi</p><blockquote><p>ISAPI Extensions within Apache for Windows<br>本模块实现了互联网服务扩展应用程序编程接口(Internet Server extension API)。本模块使得Windows上的Apache能有限地实现互联网服务扩展(比如调用ISAPI的动态连接库)。</p></blockquote></li><li><p>mod_mime</p><blockquote><p>关联请求的文件名的扩展名与文件的行为（处理器和过滤器）和内容（MIME类型，语言，字符集和编码)</p></blockquote></li><li><p>mod_mime_magic</p><blockquote><p>通过读取部分文件内容自动猜测文件的MIME类型<br>本模块采取Unix系统下file(1)命令相同的方法：检查文件开始的几个字节，来判定文件的MIME类型。它被作为当mod_mime无法解析时，用来处理的”第二道防线”。</p></blockquote></li><li><p>mod_proxy</p><blockquote><p>用于提供代理服务，能够支持的包括正向代理、反向代理、透明代理、缓存、负载均衡，HTTP代理、FTP代理、SSL代理等若干强大的功能.</p></blockquote></li><li><p>mod_rewrite</p><blockquote><p>提供了一个基于规则的重写动态URL重写引擎。</p></blockquote></li><li><p>mod_session</p><blockquote><p>会话支持</p></blockquote></li><li><p>mod_ssl</p><blockquote><p>提供使用安全套接字层（SSL）和传输层安全（TLS）协议强加密。（https协议必须）</p></blockquote></li><li><p>mod_status</p><blockquote><p>提供有关服务器活动和性能信息</p></blockquote></li><li><p>mod_vhost_alias</p><blockquote><p>虚拟主机配置支持</p></blockquote></li></ul><h3 id="静态模块-amp-动态模块"><a href="#静态模块-amp-动态模块" class="headerlink" title="静态模块&amp;动态模块"></a>静态模块&amp;动态模块</h3><h4 id="概念-amp-区别"><a href="#概念-amp-区别" class="headerlink" title="概念&amp;区别"></a>概念&amp;区别</h4><p><strong>什么是静态？</strong>  其实就是编译的时候所有的模块自己编译进 httpd 这个文件中 ，启动的时候这些模块就已经加载进来了，也就是可以使用了。</p><p>查看当前Apache通过静态编译的模块</p><pre><code>[root@MyServer ~]# httpd -lCompiled in modules:core.cmod_so.chttp_core.cevent.c</code></pre><p><strong>那么什么是动态？</strong>  静态是直接编译进httpd中， 那么动态显然就不编译进去了，也就是你启动的时候根本不会加载这个模块， 而是给你一个module.so 文件，你一定要使用 loadmodule 这个语法来加载，这个模块才有效。</p><p><em><strong>配置方法：</strong></em><br>静态的模块通常在http.conf中用<ifmodule></ifmodule> 来配置，动态的要先loadmoule来加载，然后再<ifmodule></ifmodule>配置。<br>官方说静态的比动态的在性能方面多5%左右。</p><p><em><strong>比较：</strong></em><br>相对来说，静态的效率高些，而动态方式配置方面灵活。想想如果编译进去的C这个module你想升级或者去掉，静态方式的就只能重新编译Apache了。</p><p>下面这句在Apache源文件夹下运行，可以查看默认情况下Apache都给你装了那些module进去：</p><pre><code>./configure –help | grep disable</code></pre><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><h5 id="1-模块的类型："><a href="#1-模块的类型：" class="headerlink" title="1. 模块的类型："></a>1. 模块的类型：</h5><ul><li>基本(B)模块默认包含，必须明确禁用；</li><li>扩展(E)/实验(X)模块默认不包含，必须明确启用。</li></ul><p>那么，针对以上这些类型的模块，在编译时有以下几种操作方式：</p><p><strong>–disable-MODULE</strong><br>禁用MODULE模块(仅用于基本模块)</p><p><strong>–enable-MODULE=shared</strong><br>将MODULE编译为DSO(可用于所有模块)</p><p><strong>–enable-MODULE=static</strong><br>将MODULE静态连接进核心(仅用于扩展和实验模块)</p><p><strong>–enable-mods-shared=MODULE-LIST</strong><br>将MODULE-LIST中的所有模块都编译成DSO(可用于所有模块)</p><p><strong>–enable-modules=MODULE-LIST</strong><br>将MODULE-LIST静态连接进核心(可用于所有模块)</p><p><em><strong>针对–enable-modules和–enable-mods-shared有两个懒办法就是 most参数和all参数，分别表示“很多的”和“所有”。</strong></em><br><strong>例如：</strong></p><pre><code>mod_alias是个基本模块，不想安装的话就： --disable-aliasmod_rewrite是个扩展模块，想动态加载它：--enable-rewrite=shared，想静态加载就是：--enable-rewrite=static想静态编译mod_alias和mod_rewrite：--enable-modules=&#39;alias rewrite&#39;想动态编译mod_alias和mod_rewrite：--enable-mods-shared=&#39;alias rewrite&#39;</code></pre><h5 id="2-动态模块管理"><a href="#2-动态模块管理" class="headerlink" title="2. 动态模块管理"></a>2. 动态模块管理</h5><p><strong>Tips:</strong> 让Apache日后可以动态编译和加载模块：<br>如果想让Apache日后可以支持动态编译(DSO)更多的module，需要在初次安装时把so这个模块编译到核心（即，静态编译）。</p><blockquote><p>如果编译中包含任何DSO模块，则mod_so会被自动包含进核心。如果希望核心以后能够装载DSO，但不实际编译任何DSO模块，则需明确指定：</p><ul><li>针对apache1.x: –enable-module=so</li><li>针对apache2.x: –enable-so=static</li></ul></blockquote><p>针对Apache2.2.x的一些例子：</p><pre><code>最大化静态安装Apache:./configure --prefix=/usr/local/apache --enable-modules=all最大化动态安装Apache:./configure --prefix=/usr/local/apache --enable-mods-shared=all静态安装rewrite、动态安装deflate以及headers./configure --prefix=/usr/local/apache --enable-rewrite=static --enable-deflate=shared --enable-headers=shared不安装基本的alais，保留以后的扩展DSO能力：./configure --prefix=/usr/local/apache --enable-so=static --disable-alias</code></pre><h5 id="利用APXS工具动态为Apache编译新的DSO（动态共享对象）"><a href="#利用APXS工具动态为Apache编译新的DSO（动态共享对象）" class="headerlink" title="利用APXS工具动态为Apache编译新的DSO（动态共享对象）"></a>利用APXS工具动态为Apache编译新的DSO（动态共享对象）</h5><p>一般如果我们需要开启或者关闭某一些模块，只需要在 <code>httpd.conf</code> 中注释相应的模块的加载指令或者去掉指令前面的注释。<br>但如果我们需要的模块在 Apache编译安装的时候没有编译进去，我们可以用APXS工具来动态编译，并加入到Apache中。</p><p>APXS,是一个给Apache服务器编译和安装扩展模块的工具。即将一个或者多个源代码或者目标文件编译成一个动态共享对象（DSO），然后可以通过Apache的 LoadModule 指令加载运行。<br>因此，要使用该工具，我们的Apache必须支持DSO特性，即已经安装有mod_so 模块，否则安装会报错。</p><p>apxs命令选项说明：</p><pre><code>apxs -g [ -S name=value ] -n modnameapxs -q [ -v ] [ -S name=value ] query ...apxs -c [ -S name=value ] [ -o dsofile ] [ -I incdir ] [ -D name=value ] [ -L libdir ] [ -l libname ] [ -Wc,compiler-flags ] [ -Wl,linker-flags ] files ...apxs -i [ -S name=value ] [ -n modname ] [ -a ] [ -A ] dso-file ...apxs -e [ -S name=value ] [ -n modname ] [ -a ] [ -A ] dso-file ...</code></pre><p>常用选项：</p><ul><li>-n modname<blockquote><p>明确的设置模块名称, -i(安装)和-g（模板生成）选项</p></blockquote></li></ul><p>执行选项：</p><ul><li>-q<blockquote><p>设置编译httpd时的变量和环境</p></blockquote></li></ul><p>配置选项：</p><ul><li>-S name=value<blockquote><p>此选项更改apxs的上述设置。</p></blockquote></li></ul><p>模板生成选项：</p><ul><li>-g<blockquote><p>该选项将生成一个子目录（名称将取决 -n设置），并会生成两个文件，一个要编译模块的源文件，用来创建模块或作为一个快速启动的apxs机制。另一个，用于编译和安装此模块，如mod_name.cMakefile</p></blockquote></li></ul><p>DSO 编译选项</p><ul><li><p>-c</p><blockquote><p>表明将进行编译操作。它首先编译C源文件(.c)，到对应的目标文件（.o），然后通过连接这些目标文件以及其余的目标文件（.a和.a）构建一个动态的共享对象dsofile</p></blockquote></li><li><p>-o dsofile</p><blockquote><p>明确规定创建动态共享对象文件名。如果没有指定，并且不能从文件名猜测到，则会生成 mod_unknow.so</p></blockquote></li><li><p>-D name=value</p><blockquote><p>直接传给编译命令自定义参数</p></blockquote></li><li><p>-L libdir</p><blockquote><p>设置编译时将要用到的自定义类库路径</p></blockquote></li><li><p>-l libname</p><blockquote><p>设置编译时用到的自定义类库名称</p></blockquote></li><li><p>-Wc，compiler-flags</p><blockquote><p>设置或添加本地编译器特定的选项</p></blockquote></li><li><p>-Wl，linker-flags</p><blockquote><p>设置或添加本地特定连接的选项。</p></blockquote></li><li><p>-p</p><blockquote><p>该选项将会使apxs 连接和引用apr/apr-util类库，使用apr/apr-util将会对编译非常有用。</p></blockquote></li></ul><p>DSO的安装和配置选项</p><ul><li><p>-i</p><blockquote><p>表明安装操作，安装一个或多个动态共享对象到服务器的模块目录</p></blockquote></li><li><p>-a</p><blockquote><p>自动添加 LoadModule 指令到 httpd.conf 配置文件，或者开启该指令。</p></blockquote></li><li><p>-A</p><blockquote><p>同 -a 选项，但创建的 LoadModule指令是被注释的状态，也就是说该模块已经准备就绪，但没开启。</p></blockquote></li><li><p>-e</p><blockquote><p>类似于 -a 和 -A 用来编辑 httpd.conf 而不安装该模块。</p></blockquote></li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>示例：我们有一个可用的Apache 模块 mod_foo.c 想要编译进Apache的DSO。</p><pre><code>$ apxs -c mod_foo.c/path/to/libtool --mode=compile gcc ... -c mod_foo.c/path/to/libtool --mode=link gcc ... -o mod_foo.la mod_foo.slo$ _</code></pre><p>然后，在Apache的配置文件中加入 loadModule 指令加载此共享对象。为了简化该步骤 apxs 提供了自动更新配置文件的的功能选项(-a,-A)。</p><pre><code>$ apxs -i -a mod_foo.la/path/to/instdso.sh mod_foo.la /path/to/apache/modules/path/to/libtool --mode=install cp mod_foo.la /path/to/apache/modules ... chmod 755 /path/to/apache/modules/mod_foo.so[activating module `foo&#39; in /path/to/apache/conf/httpd.conf]$ _</code></pre><p>这时，我们在httpd.conf 中就能看到这条指令。</p><pre><code>LoadModule foo_module modules/mod_foo.so</code></pre><p>如果没有使用 -a 选项自动添加，则需要手动添加进去。</p><p>如果想默认不开启该模块，可以使用 -A 选项。即</p><pre><code>$ apxs -i -A mod_foo.c</code></pre><p><strong>apxs快速测试</strong></p><p>我们可以通过创建一个Apache的测试模块，通过对应的Makefile</p><pre><code>$ apxs -g -n fooCreating [DIR] fooCreating [FILE] foo/MakefileCreating [FILE] foo/modules.mkCreating [FILE] foo/mod_foo.cCreating [FILE] foo/.deps$ _</code></pre><p>然后可以立即编译该测试模块到DSO，并加载到Apache。</p><pre><code>$ cd foo$ make all reloadapxs -c mod_foo.c/path/to/libtool --mode=compile gcc ... -c mod_foo.c/path/to/libtool --mode=link gcc ... -o mod_foo.la mod_foo.sloapxs -i -a -n &quot;foo&quot; mod_foo.la/path/to/instdso.sh mod_foo.la /path/to/apache/modules/path/to/libtool --mode=install cp mod_foo.la /path/to/apache/modules ... chmod 755 /path/to/apache/modules/mod_foo.so[activating module `foo&#39; in /path/to/apache/conf/httpd.conf]apachectl restart/path/to/apache/sbin/apachectl restart: httpd not running, trying to start[Tue Mar 31 11:27:55 1998] [debug] mod_so.c(303): loaded module foo_module/path/to/apache/sbin/apachectl restart: httpd started$ _</code></pre><p>over~</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Apache的分层体系结构&quot;&gt;&lt;a href=&quot;#Apache的分层体系结构&quot; class=&quot;headerlink&quot; title=&quot;Apache的分层体系结构&quot;&gt;&lt;/a&gt;Apache的分层体系结构&lt;/h2&gt;&lt;p&gt;最新版本的Apache按照其功能一般会被划分为五层，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;操作系统平台功能层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;各操作系统本身提供的底层功能，比如进程、线程管理,进程和线程之间通信、网络套接字通信、文件操作等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可移植运行库层（操作系统适配层）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;封装不同操作系统的底层细节，向上提供统一的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apache核心功能层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提供最基本的HTTP服务功能，对其他模块提供对应的API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apache可选功能层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这一层通常指 Apache模块，Apache核心功能层提供不了的功能交给不同的Apache模块来处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apache第三方功能层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Apache的一些模块中用到的一些第三方开发的类库等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://n.sinaimg.cn/games/3ece443e/20160826/apacheFenCengYuMoKuaiHuaTiXiJieGou.png&quot; alt=&quot;Apache的分层体系结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Apache分层" scheme="https://weizhimiao.github.io/tags/Apache%E5%88%86%E5%B1%82/"/>
    
    <category term="Apache模块" scheme="https://weizhimiao.github.io/tags/Apache%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Apache性能监控</title>
    <link href="https://weizhimiao.github.io/2016/08/23/Apache%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>https://weizhimiao.github.io/2016/08/23/Apache%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</id>
    <published>2016-08-23T08:10:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>谈到服务器性能监控，目前市面上有很多成熟的关于性能监控的产品可供我们使用。比如 <a href="http://www.oneapm.com/ci/feature.html">Cloud Insight</a><br>。但通过 Apache本身提供的监控模块或者通过一些简单的bash命令也能实现简单的监控。</p><span id="more"></span><h2 id="Linux下通过Server-status来监控Apache"><a href="#Linux下通过Server-status来监控Apache" class="headerlink" title="Linux下通过Server-status来监控Apache"></a>Linux下通过Server-status来监控Apache</h2><ol><li><p>加载 mod_status.so 模块</p><blockquote><p>mod_status, Apache状态管理模块</p></blockquote><pre><code>#在httpd.conf中加入下面这句或将其前面注释去掉LoadModule status_module modules/server_status.so</code></pre></li><li><p>修改配置文件</p></li></ol><ul><li><p>方式一：直接在 httpd.conf 底部添加以下配置</p><pre><code>&lt;location /c-server-status&gt;setHandle Server-statusOrder Deny,AllowDeny from nothingAllow from all&lt;/location&gt;ExtendedStatus on</code></pre></li><li><p>方式二：添加到子配置文件中<br>在 httpd.conf 中找到 <code>Include conf/extra/httpd-info.conf</code>,去掉<code>#</code>,<br>在 httpd-info.conf 文件中加入 方式一 中的内容。</p></li><li><p><em>Tips：</em>*</p></li><li><p><code>&lt;location /c-server-status&gt;</code>: 这个名字可以任意取，最好不要让别人猜到。</p></li><li><p><code>ExtendedStatus on</code>: 启用扩展状态。该设置仅能用于全局设置，不能在特定的虚拟主机中打开或者关闭。并且，启用该扩展会使服务器运行效率降低。</p></li></ul><ol start="3"><li><p>重启Apache</p><pre><code>/usr/local/apache2/bin/httpd -k start|restart|stop</code></pre></li><li><p>访问页面</p></li></ol><p>  <a href="http://your-domain/c-server-status">http://your-domain/c-server-status</a></p><p>  <a href="http://your-domain/c-server-status?refresh=5">http://your-domain/c-server-status?refresh=5</a></p><p>  <a href="http://www.apache.org/server-status">官网示例</a></p><ol start="5"><li>监控参数</li></ol><table><thead><tr><th>参数名称</th><th>参数描述</th></tr></thead><tbody><tr><td>Total Accesses</td><td>服务器自启动来接收到的请求连接数</td></tr><tr><td>Total kBytes</td><td>传输的总数据量，单位是KB</td></tr><tr><td>CPULoad</td><td>NCPU负荷</td></tr><tr><td>Uptime</td><td>运行时间，单位秒</td></tr><tr><td>ReqPerSec</td><td>每秒请求数</td></tr><tr><td>BytesPerSec</td><td>每秒传输数据量，单位B/s</td></tr><tr><td>BytesPerReq</td><td>平均每个请求的数据传输量（事实上就是BytesPerSec/BytesPerSec）</td></tr><tr><td>BusyWorkers</td><td>在跑的进程数</td></tr><tr><td>IdleWorkers</td><td>空闲的进程数</td></tr></tbody></table><h2 id="Linux下通过命令来实现监控"><a href="#Linux下通过命令来实现监控" class="headerlink" title="Linux下通过命令来实现监控"></a>Linux下通过命令来实现监控</h2><ol><li>ps 查看httpd进程数<pre><code>$ps -ef | grep httpd | wc -l</code></pre>当连接数多了，他就会生出更多进程来处理请求。当然这结果包含 grep httpd 的进程输出，所以一般来说实际进程数比输出结果少1</li><li>用netstat来查看当前连接数<pre><code>$netstat -ant | grep &quot;:80&quot; | wc -l</code></pre>连接数目并不等于httpd线程数目，当然连接数目越多，httpd进程数就有可能数会增多。上面的返回结果数目，有可能包括多种连接状态，比如 LISTEN、ESTABLISHED、TIME_WAIT等等，可以加入状态关键字进一步过滤，得到想要的结果。</li><li>实时检测httpd连接数<pre><code>#watch -n 1 -d &quot;pgrep httpd|wc -l&quot;</code></pre></li><li>计算httpd进程占用内在的平均数<pre><code>#ps aux|grep -v grep|awk &#39;/httpd/&#123;sum+=$6&#125;; END&#123;print sum/n&#125;&#39;</code></pre></li><li>查看Apache的并发请求数及期TCP连接状态<pre><code>#netstat -n | awk &#39;/^tcp/&#123;++S[$NF]&#125;END&#123;for(a in S) print a, S[a]&#125;&#39;返回结果示例：LAST_ACK 5SYN_RECV 30       #表示正在等待处理的请求数；ESTABLISHED 1597  #表示正常数据传输状态；FIN_WAIT1 51FIN_WAIT2 504TIME_WAIT 1057    #表示处理完毕,等待超时结束的请求数</code></pre></li></ol><p>常见的连接状态</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>CLOSED</td><td>无连接是活动的或正在进行</td></tr><tr><td>LISTEN</td><td>服务器在等待进入呼叫</td></tr><tr><td>SYN_RECV</td><td>一个连接请求已经到达,等待确认</td></tr><tr><td>SYN_SENT</td><td>应用已经开始,打开一个连接</td></tr><tr><td>ESTABLISHED</td><td>正常数据传输状态</td></tr><tr><td>FIN_WAIT1</td><td>应用说它已经完成</td></tr><tr><td>FIN_WAIT2</td><td>另一边已同意释放</td></tr><tr><td>ITMED_WAIT</td><td>等待所有分组死掉</td></tr><tr><td>CLOSING</td><td>两边同时尝试关闭</td></tr><tr><td>TIME_WAIT</td><td>另一边已初始化一个释放</td></tr><tr><td>LAST_ACK</td><td>等待所有分组死掉</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;谈到服务器性能监控，目前市面上有很多成熟的关于性能监控的产品可供我们使用。比如 &lt;a href=&quot;http://www.oneapm.com/ci/feature.html&quot;&gt;Cloud Insight&lt;/a&gt;&lt;br&gt;。但通过 Apache本身提供的监控模块或者通过一些简单的bash命令也能实现简单的监控。&lt;/p&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Apache 监控" scheme="https://weizhimiao.github.io/tags/Apache-%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Apache 并行处理模块小结</title>
    <link href="https://weizhimiao.github.io/2016/08/22/Apache%E5%A4%9A%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86/"/>
    <id>https://weizhimiao.github.io/2016/08/22/Apache%E5%A4%9A%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86/</id>
    <published>2016-08-22T14:36:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>Apache 2.X  支持插入式并行处理模块，称为多路处理模块 MPM，（Multi-Processing Modules）它是一个用于选择和处理网络端口的绑定，接收请求并指派子进程处理来自客户端的请求的一个Apache模块。和其他Apache模块相比，它最大的区别是，在任何时间， 必须有一个，而且只有一个 MPM 加载到服务器中。</p><blockquote><p>原理就是增加服务器服务进程或线程数量，是服务器可同时处理更多用户请求。</p></blockquote><span id="more"></span><h2 id="如何为Apache选择并安装一个合适的MPM模块"><a href="#如何为Apache选择并安装一个合适的MPM模块" class="headerlink" title="如何为Apache选择并安装一个合适的MPM模块"></a>如何为Apache选择并安装一个合适的MPM模块</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>MPM 必须在编译前夕，配置时指定，然后编译到服务器程序中。</p><p>即在执行 configure 时，使用参数 –with-mpm=NAME 来指定一个希望安装的MPM模块。NAME 是指定的 MPM 名称。</p><p>例：</p><pre><code>./configure --prefix=/usr/local/apache2 --with-mpm=workermake &amp; make install</code></pre><p>或者也可以编译为支持指定的几种或者全部MPM，之后通过修改配置来更换具体使用哪种MPM。</p><pre><code>--enable-mpms-shared=&#39;prefork worker&#39;--enable-mpms-shared=all</code></pre><p>例：</p><pre><code>./configure --prefix=/usr/local/apache2 --enable-mpms-shared=all···</code></pre><p>安装成功之后，会在modules文件夹下，自动编译出我们指定的MPM的so模块，在httpd.conf中修改Apache的多处理模式MPM可以切换不同MPM模块：</p><pre><code>#LoadModule mpm_prefork_module modules/mod_mpm_prefork.soLoadModule mpm_worker_module modules/mod_mpm_worker.so#LoadModule mpm_event_module modules/mod_mpm_event.so</code></pre><h3 id="如何查看当前使用的是哪种MPM模块"><a href="#如何查看当前使用的是哪种MPM模块" class="headerlink" title="如何查看当前使用的是哪种MPM模块"></a>如何查看当前使用的是哪种MPM模块</h3><ol><li><p>使用 ./httpd -l 来确定选择的 MPM。 此命令会列出编译到服务器程序中的所有模块，包括 MPM。例：</p><pre><code>$ httpd -lCompiled in modules:core.cmod_so.chttp_core.cprefork.c</code></pre><p>如上显示，我们呢当前安装的是以prefork方式工作的MPM模块。</p></li><li><p>使用./httpd -V 来确定当前使用的MPM模块。<br>```<br>$ httpd -V<br>Server version: Apache/2.4.18 (Unix)<br>Server built:   Feb 20 2016 20:03:19<br>Server’s Module Magic Number: 20120211:52<br>Server loaded:  APR 1.4.8, APR-UTIL 1.5.2<br>Compiled using: APR 1.4.8, APR-UTIL 1.5.2<br>Architecture:   64-bit<br>Server MPM:     prefork<br>threaded:     no<br> forked:     yes (variable process count)<br>Server compiled with….</p></li></ol><p> -D APR_HAS_SENDFILE<br> -D APR_HAS_MMAP<br> -D APR_HAVE_IPV6 (IPv4-mapped addresses enabled)<br> -D APR_USE_FLOCK_SERIALIZE<br> -D APR_USE_PTHREAD_SERIALIZE<br> -D SINGLE_LISTEN_UNSERIALIZED_ACCEPT<br> -D APR_HAS_OTHER_CHILD<br> -D AP_HAVE_RELIABLE_PIPED_LOGS<br> -D DYNAMIC_MODULE_LIMIT=256<br> -D HTTPD_ROOT=”/usr”<br> -D SUEXEC_BIN=”/usr/bin/suexec”<br> -D DEFAULT_PIDLOG=”/private/var/run/httpd.pid”<br> -D DEFAULT_SCOREBOARD=”logs/apache_runtime_status”<br> -D DEFAULT_ERRORLOG=”logs/error_log”<br> -D AP_TYPES_CONFIG_FILE=”/private/etc/apache2/mime.types”<br> -D SERVER_CONFIG_FILE=”/private/etc/apache2/httpd.conf”</p><pre><code>## 常见的几种MPM模块以及它们之间的区别如果我们在编译的时候没有明确选择使用哪种MPM模块，那么Apache将会根据不同的系统选择不同的MPM模块进行编译安装。系统  | 默认MPM-----|-------BeOS |beosNetware|mpm_netwareOS/2    |mpmt_os2Unix    |preforkWindows    |mpm_winnt对于类UNIX系统，根据不同的场景需要我们可以选择使用不同的MPM模块。* prefork* worker* event### prefork MPM&gt; 非线程型的、预派生的MPM**原理：** 启动之初，就预先fork一些子进程，然后等待请求进来。</code></pre><h1 id="prefork-MPM"><a href="#prefork-MPM" class="headerlink" title="prefork MPM"></a>prefork MPM</h1><h1 id="StartServers-number-of-server-processes-to-start"><a href="#StartServers-number-of-server-processes-to-start" class="headerlink" title="StartServers: number of server processes to start"></a>StartServers: number of server processes to start</h1><h1 id="MinSpareServers-minimum-number-of-server-processes-which-are-kept-spare"><a href="#MinSpareServers-minimum-number-of-server-processes-which-are-kept-spare" class="headerlink" title="MinSpareServers: minimum number of server processes which are kept spare"></a>MinSpareServers: minimum number of server processes which are kept spare</h1><h1 id="MaxSpareServers-maximum-number-of-server-processes-which-are-kept-spare"><a href="#MaxSpareServers-maximum-number-of-server-processes-which-are-kept-spare" class="headerlink" title="MaxSpareServers: maximum number of server processes which are kept spare"></a>MaxSpareServers: maximum number of server processes which are kept spare</h1><h1 id="MaxRequestWorkers-maximum-number-of-server-processes-allowed-to-start"><a href="#MaxRequestWorkers-maximum-number-of-server-processes-allowed-to-start" class="headerlink" title="MaxRequestWorkers: maximum number of server processes allowed to start"></a>MaxRequestWorkers: maximum number of server processes allowed to start</h1><h1 id="MaxConnectionsPerChild-maximum-number-of-connections-a-server-process-serves"><a href="#MaxConnectionsPerChild-maximum-number-of-connections-a-server-process-serves" class="headerlink" title="MaxConnectionsPerChild: maximum number of connections a server process serves"></a>MaxConnectionsPerChild: maximum number of connections a server process serves</h1><h1 id="before-terminating"><a href="#before-terminating" class="headerlink" title="before terminating"></a>before terminating</h1><IfModule mpm_prefork_module>    StartServers             1  #推荐 小=默认，中=20~50，大=50~100    MinSpareServers          1  #推荐 与 StartServers 保持一致    MaxSpareServers         10  #推荐 小=20，中=30~80，大=80~120    MaxRequestWorkers      250  #推荐 小=500，中=500~1500，大=1500~3000    MaxConnectionsPerChild   0  #推荐 小=10000，中或大10000~50000    #ServerLimit           250  #推荐 与 MaxRequestWorkers 保持一致，当MaxRequestWorkers 值超过256，则需要增加该值配置</IfModule>```启动时建立`StartServers`个子进程，然后按每秒创建指数级个进程数，直到达到`MinSpareServers`个进程（最多增到每秒32个）。如果空闲进程大于`MaxSpareServers`，则检查kill掉一些空闲进程。<p><code>MaxRequestWorkers</code>指定Apache最多可以同时同时处理的请求数，即进程数，当请求数多余这个值之后，多余的请求就会进入请求队列等待处理（默认不能大于256）。但可以通过设定ServerLimit来增大限制数，serverlimit最大为20000。apache2.3.1之前的版本该参数叫 MaxClients 。当我们的服务器资源很多，但访问却很慢时，我们就可以试一下增大该值，来提高服务器的请求处理能力。<br><code>MaxConnectionsPerChild</code>每个子进程可处理的请求数。处理完之后子进程就会自动销毁。<code>0</code>表示无限，永不销毁。</p><ul><li>优点：成熟稳定，兼容所有新老模块。同时，不需要担心线程安全的问题。</li><li>缺点：相对于线程，进程相对占用更多的系统资源，消耗更多的内存。所以不擅长处理高并发请求。</li></ul><h3 id="worker-MPM"><a href="#worker-MPM" class="headerlink" title="worker MPM"></a>worker MPM</h3><blockquote><p>支持混合的多线程、多进程的MPM。相比于prefork，worker采用了多进程和多线程混合模式，所以在使用中它占据更少的内存，在高并发情况下表现更优秀。</p></blockquote><pre><code># worker MPM# StartServers: initial number of server processes to start# MinSpareThreads: minimum number of worker threads which are kept spare# MaxSpareThreads: maximum number of worker threads which are kept spare# ThreadsPerChild: constant umber of worker threads in each server process# MaxRequestWorkers: maximum number of worker threads# MaxConnectionsPerChild: maximum number of connections a server process serves#                         before terminating&lt;IfModule mpm_worker_module&gt;    StartServers             3  #推荐 小=默认，中=3~5，大=5~10    MinSpareThreads         75  #推荐 小=默认，中=50~100，大=100~200    MaxSpareThreads        250  #推荐 小=默认，中=80~160，大=200~400    ThreadsPerChild         25  #推荐 小=默认，中=50~100，大=100~200    MaxRequestWorkers      400  #推荐 小=500，中=500~1500，大=1500~3000    MaxConnectionsPerChild   0  #推荐 小=10000，中或大=10000~50000    #ServerLimit           250  #推荐 当 MaxRequestWorkers/ThreadsPerChild 大于16时，则需要增加该值配置。并且该值必须大于等于MaxRequestWorkers/ThreadsPerChild 的值&lt;/IfModule&gt;</code></pre><p><code>ThreadsPerChild</code> 每个进程包含线程数<br><code>MaxSpareThreads</code> 定义最大空闲线程数，超过则清理</p><ul><li>优点：占用更少系统资源，高并发情况下表现更优秀。</li><li>缺点：必须考虑线程安全的问题。</li></ul><h3 id="event-MPM"><a href="#event-MPM" class="headerlink" title="event MPM"></a>event MPM</h3><blockquote><p>worker方式的升级版，也采用多进程和多线程混合模式，并且解决了在 <code>keep-alive</code> 情况下，长期被占用的线程的资源浪费问题。</p></blockquote><pre><code># event MPM# StartServers: initial number of server processes to start# MinSpareThreads: minimum number of worker threads which are kept spare# MaxSpareThreads: maximum number of worker threads which are kept spare# ThreadsPerChild: constant number of worker threads in each server process# MaxRequestWorkers: maximum number of worker threads# MaxConnectionsPerChild: maximum number of connections a server process serves#                         before terminating&lt;IfModule mpm_event_module&gt;    StartServers             3    MinSpareThreads         75    MaxSpareThreads        250    ThreadsPerChild         25    MaxRequestWorkers      400    MaxConnectionsPerChild   0&lt;/IfModule&gt;</code></pre><ul><li>优点：更好的高并发请求处理能力。</li><li>缺点：兼容性问题可能不是很好（最新的官方自带的模块，已经全部支持event MPM了），需要Linux系统（Linux 2.6+）对EPoll的支持，才能启用</li></ul><p><strong>Tips：</strong></p><ul><li><em><strong>空闲子进程：</strong></em> 即没有正在处理请求的子进程。</li><li><em><strong>请求等待队列：</strong></em> 任何超过 MaxClients 或 MaxRequestWorkers 限制的请求都将进入到等待队列，直到收到 ListenBacklog 指令限制的最大值为止（默认 ListenBacklog 511）</li><li><em><strong>ServerLimit：</strong></em> 该值表示Apache允许创建的最大进程数。值得注意的是 Apache在编译的时候会有一个硬限制 ServerLimit 20000 ，你不能超过该值。该值如果设置过高，将会有过多的内存被分配，可能会导致Apache 无法启动或者不稳定的情况。</li></ul><h2 id="简单测试对比"><a href="#简单测试对比" class="headerlink" title="简单测试对比"></a>简单测试对比</h2><p>对上面三种模式，我们做简单的测试进行对比。</p><h3 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h3><pre><code>./ab -k -c 200 -n 200000 192.168.1.234/index.html</code></pre><p>结果：</p><pre><code>prefork：9556QPSworker ：11038QPSevent ：10224QPS</code></pre><h3 id="PHP页面"><a href="#PHP页面" class="headerlink" title="PHP页面"></a>PHP页面</h3><pre><code>./ab -k -c 200 -n 200000 192.168.1.234/index.php  #echo &quot;hello world&quot;;</code></pre><p>结果：</p><pre><code>prefork：6094QPSworker ：7411QPSevent ：7089QPS</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache 2.X  支持插入式并行处理模块，称为多路处理模块 MPM，（Multi-Processing Modules）它是一个用于选择和处理网络端口的绑定，接收请求并指派子进程处理来自客户端的请求的一个Apache模块。和其他Apache模块相比，它最大的区别是，在任何时间， 必须有一个，而且只有一个 MPM 加载到服务器中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理就是增加服务器服务进程或线程数量，是服务器可同时处理更多用户请求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Apache Apache性能优化" scheme="https://weizhimiao.github.io/tags/Apache-Apache%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>面向对象三大特性五大基本原则</title>
    <link href="https://weizhimiao.github.io/2016/08/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://weizhimiao.github.io/2016/08/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2016-08-22T13:30:00.000Z</published>
    <updated>2021-10-26T06:53:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础.</p><span id="more"></span><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><p>封装是面向对象的特征之一，是对象和类概念的主要特性。</p><p>简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。</p><p>通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。</p><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。</p><p>继承的过程，就是从一般到特殊的过程。</p><p>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。</p><p>继承概念的实现方式有二类：实现继承与接口继承。</p><ul><li>实现继承是指直接使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。<br>多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p><p>这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h2 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h2><h3 id="单一职责原则SRP-Single-Responsibility-Principle"><a href="#单一职责原则SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则SRP(Single Responsibility Principle)"></a>单一职责原则SRP(Single Responsibility Principle)</h3><p>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</p><h3 id="开放封闭原则OCP-Open－Close-Principle"><a href="#开放封闭原则OCP-Open－Close-Principle" class="headerlink" title="开放封闭原则OCP(Open－Close Principle)"></a>开放封闭原则OCP(Open－Close Principle)</h3><p>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。</p><p>比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，<br>那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p><h3 id="替换原则-the-Liskov-Substitution-Principle-LSP"><a href="#替换原则-the-Liskov-Substitution-Principle-LSP" class="headerlink" title="替换原则(the Liskov Substitution Principle LSP)"></a>替换原则(the Liskov Substitution Principle LSP)</h3><p>子类应当可以替换父类并出现在父类能够出现的任何地方。</p><p>比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，<br>也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p><h3 id="依赖原则-the-Dependency-Inversion-Principle-DIP"><a href="#依赖原则-the-Dependency-Inversion-Principle-DIP" class="headerlink" title="依赖原则(the Dependency Inversion Principle DIP)"></a>依赖原则(the Dependency Inversion Principle DIP)</h3><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，</p><p>这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到<br>了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。</p><p>通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p><p>一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p><h3 id="接口分离原则-the-Interface-Segregation-Principle-ISP"><a href="#接口分离原则-the-Interface-Segregation-Principle-ISP" class="headerlink" title="接口分离原则(the Interface Segregation Principle ISP)"></a>接口分离原则(the Interface Segregation Principle ISP)</h3><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p><p>转自：<a href="http://www.cnblogs.com/hnrainll/">http://www.cnblogs.com/hnrainll/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;透切理解面向对象三大基本特性是理解面向对象五大基本原则的基础.&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://weizhimiao.github.io/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="https://weizhimiao.github.io/2016/08/12/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://weizhimiao.github.io/2016/08/12/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2016-08-12T12:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code>$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 <code>_config.yml</code> 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><span id="more"></span><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre><code>$ hexo generate</code></pre><p>生成静态文件。</p><p>  选项    描述<br>  -d, –deploy    文件生成后立即部署网站<br>  -w, –watch    监视文件变动</p><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre><code>$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><p>  选项    描述<br>  -p, –port    重设端口<br>  -s, –static    只使用静态文件<br>  -l, –log    启动日记记录，使用覆盖记录格式</p><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre><code>$ hexo deploy</code></pre><p>部署网站。</p><p>  参数    描述<br>  -g, –generate    部署之前预先生成静态文件</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre><code>$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><p>  参数    描述<br>  -o, –output    设置输出路径</p><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre><code>$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 迁移内容。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre><code>$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre><code>$ hexo version</code></pre><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre><code>$ hexo --config custom.yml</code></pre><p>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code>。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre><code>$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ hexo init [folder]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。&lt;/p&gt;
&lt;h2 id=&quot;new&quot;&gt;&lt;a href=&quot;#new&quot; class=&quot;headerlink&quot; title=&quot;new&quot;&gt;&lt;/a&gt;new&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ hexo new [layout] &amp;lt;title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 &lt;code&gt;_config.yml&lt;/code&gt; 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://weizhimiao.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Apache的安装</title>
    <link href="https://weizhimiao.github.io/2016/08/09/Apache%E5%AE%89%E8%A3%85%E6%B1%87%E6%80%BB/"/>
    <id>https://weizhimiao.github.io/2016/08/09/Apache%E5%AE%89%E8%A3%85%E6%B1%87%E6%80%BB/</id>
    <published>2016-08-09T06:00:00.000Z</published>
    <updated>2021-10-26T06:53:41.613Z</updated>
    
    <content type="html"><![CDATA[<p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。<br>Apache的安装无外乎两种方式：</p><ul><li>二进制包安装</li><li>源码包安装</li></ul><span id="more"></span><p>接下来我将会演示和记录通过源码包来安装apache到服务器。<br>环境：阿里云 Centos 7.2 64</p><h2 id="安装前准备工作"><a href="#安装前准备工作" class="headerlink" title="安装前准备工作"></a>安装前准备工作</h2><p>通过源码包安装，我们需要将源码编译成计算机运行的二进制，因此我们需要编译工具。</p><h3 id="gcc安装"><a href="#gcc安装" class="headerlink" title="gcc安装"></a>gcc安装</h3><p>GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。</p><pre><code>[root@iZ28v78hcmrZ ~]# gccgcc: 致命错误：没有输入文件编译中断。[root@iZ28v78hcmrZ ~]# yum install gcc···作为依赖被升级:  cpp.x86_64 0:4.8.5-4.el7            gcc-c++.x86_64 0:4.8.5-4.el7            gcc-gfortran.x86_64 0:4.8.5-4.el7    libgcc.x86_64 0:4.8.5-4.el7  libgfortran.x86_64 0:4.8.5-4.el7    libgomp.x86_64 0:4.8.5-4.el7            libquadmath.x86_64 0:4.8.5-4.el7     libquadmath-devel.x86_64 0:4.8.5-4.el7  libstdc++.x86_64 0:4.8.5-4.el7      libstdc++-devel.x86_64 0:4.8.5-4.el7完毕！[root@iZ28v78hcmrZ ~]#</code></pre><h3 id="APR、APR-UTIL-安装"><a href="#APR、APR-UTIL-安装" class="headerlink" title="APR、APR-UTIL 安装"></a>APR、APR-UTIL 安装</h3><p>APR （全称：Apache Portable Runtime）可移植运行时库、APR-UTIL（全称：Apache Portable Runtime Utility Library）可移植运行时工具库。它们的作用是使得对平台细节的处理进行下移。对于应用程序而言，它们根本就不需要考虑具体的平台，不管是Unix、Linux还是Window，应用程序执行的接口基本都是统一一致的。<br>APR的目标则是希望安全合并所有的能够合并的代码而不需要牺牲性能，为大多数平台提供所有的APR特性支持，包括Win32、OS/2、BeOS、Darwin、Linux等等。</p><p>关于apr和apr-util，apache可以使用系统已经安装的版本，也可以不实用系统提供的版本。具体方法是分别下载apr和apr-util，解压到apache源码包中的srclib/apr和srclib/apr-util路径中（路径中不包含版本号等信息），在编译源码包之前的./configure 过程中使用 –with-included-apr 选项</p><h3 id="PRCE-Perl-Compatible-Regular-Expressions-Library-Perl兼容的正则表达式库"><a href="#PRCE-Perl-Compatible-Regular-Expressions-Library-Perl兼容的正则表达式库" class="headerlink" title="PRCE (Perl-Compatible Regular Expressions Library,Perl兼容的正则表达式库)"></a>PRCE (Perl-Compatible Regular Expressions Library,Perl兼容的正则表达式库)</h3><p>PCRE(Perl Compatible Regular Expressions)是一个用C语言编写的正则表达式函数库。<br>PCRE被广泛使用在许多开源软件之中，最著名的莫过于Apache HTTP服务器和PHP脚本语言、R脚本语言，此外，正如从其名字所能看到的，PCRE也是perl语言的缺省正则库。</p><p>[PCRE 下载网址][pcre_download]<br>[pcre_download]:<a href="https://sourceforge.net/projects/pcre/files/">https://sourceforge.net/projects/pcre/files/</a></p><pre><code>#解压[root@iZ94m2e99jtZ ~]# tar -zxvf pcre-8.38.tar.gz[root@iZ94m2e99jtZ ~]# cd pcre-8.38[root@iZ94m2e99jtZ pcre-8.38]# ./configure···pcre-8.38 configuration summary:    Install prefix .................. : /usr/local    C preprocessor .................. : gcc -E    C compiler ...................... : gcc    C++ preprocessor ................ : g++ -E    C++ compiler .................... : g++    Linker .......................... : /usr/bin/ld -m elf_x86_64    C preprocessor flags ............ :    C compiler flags ................ : -g -O2 -fvisibility=hidden    C++ compiler flags .............. : -O2 -fvisibility=hidden -fvisibility-inlines-hidden    Linker flags .................... :    Extra libraries ................. :    Build 8 bit pcre library ........ : yes    Build 16 bit pcre library ....... : no    Build 32 bit pcre library ....... : no    Build C++ library ............... : yes    Enable JIT compiling support .... : no    Enable UTF-8/16/32 support ...... : no    Unicode properties .............. : no    Newline char/sequence ........... : lf    \R matches only ANYCRLF ......... : no    EBCDIC coding ................... : no    EBCDIC code for NL .............. : n/a    Rebuild char tables ............. : no    Use stack recursion ............. : yes    POSIX mem threshold ............. : 10    Internal link size .............. : 2    Nested parentheses limit ........ : 250    Match limit ..................... : 10000000    Match limit recursion ........... : MATCH_LIMIT    Build shared libs ............... : yes    Build static libs ............... : yes    Use JIT in pcregrep ............. : no    Buffer size for pcregrep ........ : 20480    Link pcregrep with libz ......... : no    Link pcregrep with libbz2 ....... : no    Link pcretest with libedit ...... : no    Link pcretest with libreadline .. : no    Valgrind support ................ : no    Code coverage ................... : no[root@iZ94m2e99jtZ pcre-8.38]# make &amp; make install</code></pre><p><strong>Tips</strong><br>在编译pcre时可能会出现这样的：configure: error: You need a C++ compiler for C++ support.提示我们缺少一个C++ 的编译器，需要我们再安装一个C++的编译器。</p><pre><code>[root@iZ94m2e99jtZ pcre-8.38]# yum install gcc-c++</code></pre><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>[apr、apr-uitl官网][apr_website]<br>[apr_website]:<a href="http://apr.apache.org/">http://apr.apache.org/</a></p><p>[apr 下载地址][apr_1.5.2_download]<br>[apr_1.5.2_download]:<a href="http://mirrors.hust.edu.cn/apache//apr/apr-1.5.2.tar.gz">http://mirrors.hust.edu.cn/apache//apr/apr-1.5.2.tar.gz</a><br>[apr-uitl 下载地址][apr-uitl_1.5.4_download]<br>[apr-uitl_1.5.4_download]:<a href="http://mirrors.hust.edu.cn/apache//apr/apr-util-1.5.4.tar.gz">http://mirrors.hust.edu.cn/apache//apr/apr-util-1.5.4.tar.gz</a></p><p>[apache 源码包][apache_download]<br>[apache_download]:<a href="http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.23.tar.gz">http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.23.tar.gz</a></p><p>下载、解压、将apr和apr-util分别复制到httpd-2.4.23/srclib/apr和httpd-2.4.23/srclib/apr-util中</p><pre><code>[root@iZ94m2e99jtZ ~]# wget http://mirrors.hust.edu.cn/apache//apr/apr-1.5.2.tar.gz[root@iZ94m2e99jtZ ~]# wget  http://mirrors.hust.edu.cn/apache//apr/apr-util-1.5.4.tar.gz[root@iZ94m2e99jtZ ~]# wget http://mirrors.tuna.tsinghua.edu.cn/apache//httpd/httpd-2.4.23.tar.gz[root@iZ94m2e99jtZ ~]# tar -zxvf apr-1.5.2.tar.gz[root@iZ94m2e99jtZ ~]# tar -zxvf apr-util-1.5.4.tar.gz[root@iZ94m2e99jtZ ~]# tar -zxvf httpd-2.4.23.tar.gz[root@iZ94m2e99jtZ ~]# ll总用量 10088drwxr-xr-x 27 1000  1000    4096 4月  25 2015 apr-1.5.2-rw-r--r--  1 root root  1031613 4月  29 2015 apr-1.5.2.tar.gzdrwxr-xr-x 19 1000  1000    4096 9月  17 2014 apr-util-1.5.4-rw-r--r--  1 root root   874044 9月  20 2014 apr-util-1.5.4.tar.gzdrwxr-xr-x 11  501 games    4096 7月   1 01:15 httpd-2.4.23-rw-r--r--  1 root root  8406575 7月   5 03:50 httpd-2.4.23.tar.gz[root@iZ94m2e99jtZ ~]#[root@iZ94m2e99jtZ ~]# cp -r  apr-1.5.2 httpd-2.4.23/srclib/apr[root@iZ94m2e99jtZ ~]# cp -r  apr-util-1.5.4 httpd-2.4.23/srclib/apr-util</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Configuring-the-source-tree"><a href="#Configuring-the-source-tree" class="headerlink" title="Configuring the source tree"></a>Configuring the source tree</h3><p>如果使用所有默认选项，只需键入的./configure即可，但一般我们根据自己的需求来修改一些配置。</p><p>其中最重要的选项应该是apache的安装位置的配置项 –prefix ；<br>此外，我们可以指定哪些功能被启用和禁用模块要包含在Apache中。apache配备了一个广泛的默认包含的模块。它们将被编译为可以装载或在运行时卸载共享对象（的DSO）。您也可以选择通过选项–enable-模块=静态编译静态模块。</p><p>额外的模块使用–enable模块选项，其中模块与除去mod_个串并转换为破折号任何下划线模块的名称启用。<br>同样，我们可以禁用与–disable模块选件模块。使用这些选项的时候，因为配置无法警告你，如果你指定的模块不存在要小心;它会简单地忽略选项。 此外，有时需要提供的配置脚本与你的编译器，库和头文件的位置额外信息。这是通过两种环境变量或命令行选项来配置完成。有关详细信息，请参考配置页面。或使用–help选项调用配置。</p><p>[Apache 官方配置说明][apache_configure_doc]<br>[apache_configure_doc]:<a href="http://httpd.apache.org/docs/2.4/programs/configure.html#installationdirectories">http://httpd.apache.org/docs/2.4/programs/configure.html#installationdirectories</a></p><pre><code>概要你应该叫configure从分布的根目录中的脚本。./configure [OPTION]... [VAR=VALUE]...要指定环境变量（例如CC， CFLAGS......），它们指定为 。请参见下面 的一些有用的变量的说明。VAR=VALUE最佳选项配置选项安装目录系统类型可选功能支持程序的选项配置选项下列选项影响的行为 configure本身。-C--config-cache这是一个别名 --cache-file=config.cache--cache-file=FILE测试结果将在文件中缓存文件。此选项默认为禁用 ​​。-h--help [short|recursive]输出的帮助和退出。随着说法short只是具体 ​​到这个包的选项将显示出来。参数 recursive显示所有包含包的简短帮助。-n--no-create该configure脚本运行正常，但不创建输出文件。这是有用的生成makefile文件编译前检查测试结果。-q--quiet不打印checking ...在配置过程的消息。--srcdir=DIR定义目录DIR是源文件目录。默认为所在目录configure的位置，或父目录。--silent与...一样 --quiet-V- 版显示版权信息并退出。安装目录这些选项定义安装目录。安装树取决于所选的布局。--prefix=PREFIX在安装结构无关的文件PREFIX。默认安装目录设置为 /usr/local/apache2。--exec-prefix=EPREFIX在安装体系相关的文件EPREFIX。默认安装目录设置为 PREFIX目录。默认情况下，make install将安装所有文件 /usr/local/apache2/bin，/usr/local/apache2/lib 等等。您可以指定以外的安装前缀 /usr/local/apache2使用--prefix，例如--prefix=$HOME。定义一个目录布局--enable-layout=LAYOUT配置源代码和编译脚本的假设基础上的布局安装树布局。这使您可以分别指定为Apache HTTP服务器安装在每个类型的文件的位置。该config.layout 文件包含几个示例配置，你还可以创建下面的例子中你自己的自定义配置。该文件中的不同布局分为&lt;Layout FOO&gt;...&lt;/Layout&gt;部分，并通过名称简称为中FOO，默认布局Apache。安装目录微调为了更好地控制安装目录中，使用下面的选项。请注意，目录默认被设置 autoconf，并通过相应布局设置被覆盖。--bindir=DIR在用户安装可执行文件DIR。用户可执行文件都支持这样的程序htpasswd， dbmmanage等等。这对于网站管理员有用。默认情况下DIR设置为 EPREFIX/bin。--datadir=DIR在安装只读体系结构无关的数据DIR。默认datadir设置为 PREFIX/share。此选项是提供 autoconf与当前未使用。--includedir=DIR在安装C头文件DIR。默认 includedir设置为 EPREFIX/include。--infodir=DIR在安装info文档DIR。默认infodir设置为 PREFIX/info。此选项当前未使用。--libdir=DIR在安装目标代码库DIR。默认 libdir设置为 EPREFIX/lib。--libexecdir=DIR在安装程序的可执行文件（例如，共享模块） DIR。默认libexecdir设置为 EPREFIX/modules。--localstatedir=DIR在安装修改的单机数据DIR。默认localstatedir设置为 PREFIX/var。此选项是提供 autoconf与当前未使用。--mandir=DIR在安装该男子文档DIR。默认 mandir设置为 EPREFIX/man。--oldincludedir=DIR在非GCC安装C头文件DIR。默认oldincludedir设置为 /usr/include。此选项是提供 autoconf与当前未使用。--sbindir=DIR在系统中安装管理员可执行DIR。这些都是服务器程序，如httpd， apachectl，suexec等，这些都需要运行在Apache HTTP服务器。默认 sbindir设置为 EPREFIX/sbin。--sharedstatedir=DIR在安装修改的架构无关的数据DIR。默认sharedstatedir设置为 PREFIX/com。此选项是提供 autoconf与当前未使用。--sysconfdir=DIR安装只读的单机数据，如服务器配置文件httpd.conf，mime.types等在 DIR。默认sysconfdir设置为 PREFIX/conf。系统类型这些选项用于交叉编译Apache HTTP服务器到另一个系统上运行。在正常的情况下，建立和运行在同一系统上的服务器时，不使用这些选项。--build=BUILD定义系统类型上的工具正在建立该系统。它默认为脚本的结果 config.guess。--host=HOST定义系统类型的服务器将运行，系统的 HOST默认为BUILD。--target=TARGET配置构建编译器系统类型 目标。它默认为HOST。此选项被提供autoconf，而不是必要的Apache HTTP服务器。可选功能这些选项用于微调您的HTTP服务器将具备的功能。一般语法一般来说，你可以使用下面的语法来启用或禁用功能：--disable-FEATURE不包括特征。这是相同的 。--enable-FEATURE=no--enable-FEATURE[=ARG]包括特征。为默认值ARG 为yes。--enable-MODULE=shared相应的模块将被建设成为DSO模块。默认情况下启用的模块是动态链接的。--enable-MODULE=static相应的模块将被静态链接。注意configure不会抱怨 ，即使富不存在，所以你需要仔细类型。 --enable-foo选择模块编译大多数模块由默认编译并已被明确或通过使用关键字禁用few （见--enable-modules，--enable-mods-shared 并且--enable-mods-static下面进一步解释）或--enable-modules=none作为一组被删除。其它模块默认不编译并已被明确或通过使用关键字启用all或 reallyall可用。要了解哪些模块是默认编译，运行 ./configure -h或./configure --help 下看Optional Features。假设你有兴趣mod_example1和 mod_example2，你看这个：可选功能：  ...  --disable-例1示例模块1  --enable-例题例如模块2  ...然后mod_example1是默认启用的，你就可以使用--disable-example1不编译。 mod_example2默认情况下禁用，你就可以使用--enable-example2 编译它。多道处理模块多道处理模块，或的MPM，实现了服务器的基本行为。单个MPM必须为了使服务器的功能被激活。出现在可用MPM列表 模块索引页。的MPM可以建成为数字存储示波器的动态加载或静态与服务器相连，并使用下列选项被启用：--with-mpm=MPM选择适合您的服务器的默认MPM。如果MPM的构建为DSO模块（见--enable-mpms-shared），该指令选择将默认的配置文件中加载的MPM。否则，这个指令选择唯一可用的MPM，这将静态链接到服务器。如果省略此选项，默认的MPM为您的操作系统将被使用。--enable-mpms-shared=MPM-LIST使动态共享模块的MPM的列表。这些模块之一必须动态使用加载 LoadModule指令。MPM-LIST是加了引号的MPM名称的空格分隔的列表。例如：--enable-mpms-shared=&#39;prefork worker&#39;此外，您还可以使用特殊关键字all，这将选择支持在当前平台上动态加载所有的MPM和他们建立的DSO模块。例如：--enable-mpms-shared=all第三方模块要添加其他第三方模块使用下列选项：--with-module=module-type:module-file[, module-type:module-file]添加一个或多个第三方的模块，以静态链接模块列表。该模块的源文件module-file 将在搜索 你的Apache HTTP服务器的源代码树的子目录。如果没有找到有它正在考虑模块文件是一个绝对文件路径，并尝试将源文件复制到 模块式子目录。如果子目录不存在，它将被创建并与标准的填充 。modules/module-typeconfigureMakefile.in此选项很有用添加由一个源文件小的外部组件。对于更复杂的模块，你应该阅读供应商的文档。注意如果你想建立一个DSO模块，而不是一个静态链接使用apxs。累积和其他选项--enable-maintainer-mode打开调试和编译时警告，并加载所有编译的模块。--enable-mods-shared=MODULE-LIST定义启用并建立动态共享模块模块的列表。这意味着，这些模块必须通过使用动态加载 LoadModule指令。MODULE-LIST是加了引号的modulenames空格分隔列表。该模块名称没有给出前面mod_。例如：--enable-mods-shared=&#39;headers rewrite dav&#39;此外，您还可以使用特殊的关键字reallyall， all，most和few。例如，--enable-mods-shared=most将编译大多数模块，并将其建设成为DSO模块，--enable-mods-shared=few将只编译一个非常基本的模块组。默认设置为most。在LoadModule对所选择的模块的指令将在主配置文件中自动生成。默认情况下，所有的指令都只是由一个配置要求或明确选择的模块被注释掉--enable-foo的说法。您可以更改设置启用或关闭加载的模块LoadModule的指令 httpd.conf。此外， LoadModule所有构建的模块的指令可通过配置选项被激活 --enable-load-all-modules。--enable-mods-static=MODULE-LIST此选项的行为类似--enable-mods-shared，但在给定的模块静态链接。这意味着，这些模块将始终存在，同时运行httpd。他们不必被加载LoadModule。--enable-modules=MODULE-LIST此选项的行为等来--enable-mods-shared，并且还将动态地链接的给定模块。特殊关键字none禁用所有模块的版本。--enable-v4-mapped允许IPv6的套接字来处理IPv4连接。--with-port=PORT这定义上的端口httpd会听。生成配置文件时，该端口号用于 httpd.conf。默认值是80。--with-program-name定义一个替代的可执行文件名 ​​称。默认值是 httpd。可选包这些选项用于定义可选包。一般语法一般来说，你可以使用下面的语法定义一个可选包：--with-PACKAGE[=ARG]使用包PACKAGE。为默认值 ARG为yes。--without-PACKAGE不要使用包PACKAGE。这是相同的 。此选项所提供 ，但对于Apache HTTP服务器不是非常有用。--with-PACKAGE=noautoconf特定软件包--with-apr=DIR|FILE在Apache可移植运行时（APR）是httpd的源代码分发的一部分，将自动与HTTP服务器共同建立。如果您想使用已安装的年利率，而不是你要告诉configure路径的 apr-config脚本。你可以设置绝对路径和名称或目录切换到安装四月apr-config必须在该目录或子目录中存在 bin。--with-apr-util=DIR|FILEApache可移植运行实用程序（APU）是httpd的源代码分发的一部分，将自动与HTTP服务器共同建立。如果您想使用已安装的APU，而不是你要告诉configure路径的 apu-config脚本。你可以设置绝对路径和名称或目录切换到安装APU，apu-config必须在该目录或子目录中存在 bin。--with-ssl=DIR如果mod_ssl已启用configure 已安装的OpenSSL的搜索。您可以将目录路径设置为SSL / TLS工具包来代替。--with-z=DIRconfigure已安装的自动搜索 zlib，如果你的源配置需要一个库（例如，当mod_deflate使能）。您可以设置压缩库的目录路径来代替。Apache HTTP服务器的一些特性，如 mod_authn_dbm和mod_rewrite的DBM RewriteMap使用简单的键/值对数据库信息的快速查询。SDBM被包括在APU，所以这个数据库是始终可用。如果您想使用其他数据库类型，可以使用下面的选项，以使它们：--with-gdbm[=path]如果没有路径指定，configure将搜索在平时的搜索路径GNU DBM安装的包含文件和库。一个明确的 路径会导致configure在寻找 path/lib，并 path/include为相关的文件。最后，路径可以指定用冒号隔开具体包括和库路径。--with-ndbm[=path]像--with-gdbm，但搜索新DBM安装。--with-berkeley-db[=path]像--with-gdbm，但搜索一个Berkeley DB的安装。注意由APU提供，并通过其配置脚本传递的DBM选项。他们利用确定已安装的APU时是无用的--with-apr-util。您可以使用自己的HTTP服务器一起使用一个以上的DBM实现。该拨款DBM类型将每次运行时配置中配置。支持程序的选项--enable-static-support构建支持二进制文件的静态链接的版本。这意味着，一个独立的可执行文件将集成所有必要的库来构建。否则，支持二进制文件默认情况下，动态链接。--enable-suexec使用此选项可启用suexec，它允许您设置UID和GID的催生过程。除非你了解你的服务器上运行的SUID二进制的所有安全隐患，请勿使用此选项。更多选项来配置suexec介绍如下。这可以通过使用下列选项来创建一个单一的支持程序的静态链接二进制文件：--enable-static-ab建立一个静态链接的版本ab。--enable-static-checkgid建立一个静态链接的版本checkgid。--enable-static-htdbm建立一个静态链接的版本htdbm。--enable-static-htdigest建立一个静态链接的版本htdigest。--enable-static-htpasswd建立一个静态链接的版本htpasswd。--enable-static-logresolve建立一个静态链接的版本logresolve。--enable-static-rotatelogs建立一个静态链接的版本rotatelogs。suexec 配置选项下列选项用于微调的行为suexec。参见配置和安装suEXEC的 进一步的信息。--with-suexec-bin这定义的路径suexec二进制文件。默认值是--sbindir（见安装目录微调）。--with-suexec-caller这定义允许呼叫的用户suexec。它应该是相同下，用户 httpd正常运行。--with-suexec-docroot这个定义下的目录树suexec允许访问的可执行文件。默认值是 --datadir/htdocs。--with-suexec-gidmin这个定义的最低GID成为目标用户 suexec。默认值是100。--with-suexec-logfile这个定义的文件名suexec​​日志文件。默认情况下，日志文件被命名为suexec_log，位于 --logfiledir。--with-suexec-safepath定义环境变量的值PATH由启动的进 ​​程进行设置suexec。默认值是/usr/local/bin:/usr/bin:/bin。--with-suexec-userdir此定义包含所有可执行文件的用户目录下的子目录suexec的访问是允许的。当你想使用此设置时必须 suexec使用特定用户目录在一起（如所提供的mod_userdir）。默认值是 public_html。--with-suexec-uidmin它定义为最低的UID允许为目标用户 suexec。默认值是100。--with-suexec-umask设置umask由启动的进 ​​程 suexec。它默认为您的系统设置。最佳环境变量有一些有用的环境变量覆盖所作出的选择 configure，或帮助它找到库和程序与非标准名称或位置。CC定义要用于编译的C编译器的命令。CFLAGS要使用编译设置C编译器的标志。CPP定义C预处理命令使用。CPPFLAGS将C / C ++预处理器的标志，例如 ，如果你在一个非标准目录头了includedir。-IincludedirLDFLAGS设置连接器选项，例如，如果你在一个非标准目录库LIBDIR。-Llibdir</code></pre><p><em><strong>示例：</strong></em><br>这里是一个典型的例子编译Apache，安装树/ SW /包装/与特定的编译器和标志，加上两个额外的模块阿帕奇mod_ldap模块和mod_lua</p><pre><code>$ CC=&quot;pgcc&quot; CFLAGS=&quot;-O2&quot; \./configure --prefix=/sw/pkg/apache \--enable-ldap=shared \--enable-lua=shared</code></pre><p>我们本次采用基本的默认设置 来进行安装</p><pre><code>[root@iZ94m2e99jtZ ~]# cd httpd-2.4.23[root@iZ94m2e99jtZ httpd-2.4.23]# ./configure  --with-included-apr</code></pre><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><pre><code>[root@iZ94m2e99jtZ httpd-2.4.23]# make</code></pre><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><pre><code>[root@iZ94m2e99jtZ httpd-2.4.23]# make install···Installing configuration filesmkdir /usr/local/apache2/confmkdir /usr/local/apache2/conf/extramkdir /usr/local/apache2/conf/originalmkdir /usr/local/apache2/conf/original/extraInstalling HTML documentsmkdir /usr/local/apache2/htdocsInstalling error documentsmkdir /usr/local/apache2/errorInstalling iconsmkdir /usr/local/apache2/iconsmkdir /usr/local/apache2/logsInstalling CGIsmkdir /usr/local/apache2/cgi-binInstalling header filesInstalling build system filesInstalling man pages and online manualmkdir /usr/local/apache2/manmkdir /usr/local/apache2/man/man1mkdir /usr/local/apache2/man/man8mkdir /usr/local/apache2/manual</code></pre><h3 id="Customize（定制）"><a href="#Customize（定制）" class="headerlink" title="Customize（定制）"></a>Customize（定制）</h3><p>接下来，我们可以通过在 /usr/local/apache2/conf 目录，编辑配置文件来自定义我们的Apache HTTP服务器。</p><p>[配置指令快速参考索引][apache_conf_directive_index]<br>[apache_conf_directive_index]:<a href="http://httpd.apache.org/docs/2.4/zh-cn/mod/directives.html">http://httpd.apache.org/docs/2.4/zh-cn/mod/directives.html</a></p><h3 id="Testinh-测试"><a href="#Testinh-测试" class="headerlink" title="Testinh(测试)"></a>Testinh(测试)</h3><p>启动Apache服务器</p><pre><code>[root@iZ94m2e99jtZ httpd-2.4.23]# /usr/local/apache2/bin/apachectl -k start[root@iZ94m2e99jtZ httpd-2.4.23]# ps aux | grep httpdroot     15386  0.0  0.2  70556  2188 ?        Ss   11:53   0:00 /usr/local/apache2/bin/httpd -k startdaemon   15387  0.0  0.4 359520  4260 ?        Sl   11:53   0:00 /usr/local/apache2/bin/httpd -k startdaemon   15388  0.0  0.4 359520  4260 ?        Sl   11:53   0:00 /usr/local/apache2/bin/httpd -k startdaemon   15389  0.0  0.4 359520  4256 ?        Sl   11:53   0:00 /usr/local/apache2/bin/httpd -k startroot     15472  0.0  0.0 112664   972 pts/0    S+   11:53   0:00 grep --color=auto httpd</code></pre><p>浏览器访问：<a href="http://ip地址/">http://IP地址</a></p><p>当出现『It works!』字样说明我们已经安装成功</p><p><em><strong>注意</strong></em> 如果通过浏览器访问不到，可能是请求服务器防火墙给拦截了，所以我们需要在防火墙里将我们用到的80端口给放行。<br>我以我当前Centos7 的系统为例，Centos7现在默认的防火墙是firewalld，Centos6以及6以前的版本则使用的是iptables，所以具体设置方法还请自己去搜索。</p><pre><code>[root@iZ94m2e99jtZ ~]# firewall-cmd  --permanent --zone=public --add-port=80/tcp  #将80端口开放success[root@iZ94m2e99jtZ ~]# firewall-cmd  --reload #重新加载防火墙配置success</code></pre><h2 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h2><p>一般常见的管理方式有两种</p><ul><li>直接通过httpd命令来管理</li><li>通过apachectl来管理</li><li><strong>Tips</strong>* apachetl其实一个是对httpd命令进行了封装sh脚本</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>#通过apachectl来管理[root@iZ94m2e99jtZ ~]# /usr/local/apache2/bin/apachectl -k start  #启动[root@iZ94m2e99jtZ ~]# /usr/local/apache2/bin/apachectl -k restart  #重启[root@iZ94m2e99jtZ ~]# /usr/local/apache2/bin/apachectl -k stop  #停止#直接通过httpd命令来管理[root@iZ94m2e99jtZ ~]# /usr/local/apache2/bin/httpd -k start|restart|graceful|graceful-stop|stop</code></pre><h3 id="具体参数"><a href="#具体参数" class="headerlink" title="具体参数"></a>具体参数</h3><pre><code>Usage: /usr/local/apache2/bin/httpd [-D name] [-d directory] [-f file]                                    [-C &quot;directive&quot;] [-c &quot;directive&quot;]                                    [-k start|restart|graceful|graceful-stop|stop]                                    [-v] [-V] [-h] [-l] [-L] [-t] [-T] [-S] [-X]Options:  -D name            : define a name for use in &lt;IfDefine name&gt; directives  -d directory       : specify an alternate initial ServerRoot  -f file            : specify an alternate ServerConfigFile  -C &quot;directive&quot;     : process directive before reading config files  -c &quot;directive&quot;     : process directive after reading config files  -e level           : show startup errors of level (see LogLevel)  -E file            : log startup errors to file  -v                 : show version number  -V                 : show compile settings  -h                 : list available command line options (this page)  -l                 : list compiled in modules  -L                 : list available configuration directives  -t -D DUMP_VHOSTS  : show parsed vhost settings  -t -D DUMP_RUN_CFG : show parsed run settings  -S                 : a synonym for -t -D DUMP_VHOSTS -D DUMP_RUN_CFG  -t -D DUMP_MODULES : show all loaded modules  -M                 : a synonym for -t -D DUMP_MODULES  -t -D DUMP_INCLUDES: show all included configuration files  -t                 : run syntax check for config files  -T                 : start without DocumentRoot(s) check  -X                 : debug mode (only one worker, do not detach)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。&lt;br&gt;Apache的安装无外乎两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二进制包安装&lt;/li&gt;
&lt;li&gt;源码包安装&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Apache" scheme="https://weizhimiao.github.io/categories/Apache/"/>
    
    
    <category term="Web服务器" scheme="https://weizhimiao.github.io/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Apache" scheme="https://weizhimiao.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Web性能优化随笔</title>
    <link href="https://weizhimiao.github.io/2016/07/31/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9A%8F%E7%AC%94/"/>
    <id>https://weizhimiao.github.io/2016/07/31/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9A%8F%E7%AC%94/</id>
    <published>2016-07-31T06:22:23.000Z</published>
    <updated>2021-10-26T06:53:41.617Z</updated>
    
    <content type="html"><![CDATA[<p>谈到web性能优化，一般我们可以把它分为两个部分来讲，页面加载（Page Speed）和页面渲染（Page Performance）。</p><span id="more"></span><h1 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h1><h2 id="加快服务器脚本的计算速度"><a href="#加快服务器脚本的计算速度" class="headerlink" title="加快服务器脚本的计算速度"></a>加快服务器脚本的计算速度</h2><ul><li>动态内容缓存</li><li>数据缓存</li><li>动态内容静态化</li><li>选择适合的web服务器软件（Apache、nginx等）</li><li>数据库优化</li><li>等等···</li></ul><h2 id="压缩源码和图片"><a href="#压缩源码和图片" class="headerlink" title="压缩源码和图片"></a>压缩源码和图片</h2><ul><li>Js 混淆压缩</li><li>CSS 普通压缩</li><li>JPG 根据具体质量压缩到50%~70%</li><li>PNG 色彩压缩、去除一些格式信息等</li></ul><h2 id="选择合适的图片"><a href="#选择合适的图片" class="headerlink" title="选择合适的图片"></a>选择合适的图片</h2><ul><li>颜色较多，则使用JPG格式</li><li>颜色较少，则使用PNG格式</li><li>尽量使用WebP、SVG</li></ul><blockquote><p>总之就是，尽量减少每一个资源的体积</p></blockquote><h2 id="合并静态资源"><a href="#合并静态资源" class="headerlink" title="合并静态资源"></a>合并静态资源</h2><p>合并CSS、Javascript和小图片</p><blockquote><p>尽量减少同一域下的HTTP请求数</p></blockquote><h2 id="开启服务器短的Gzip压缩"><a href="#开启服务器短的Gzip压缩" class="headerlink" title="开启服务器短的Gzip压缩"></a>开启服务器短的Gzip压缩</h2><p>Gzip开启以后会将输出到用户浏览器的数据进行压缩的处理，这样就会减小通过网络传输的数据量，提高浏览的速度。所以Gzip对文本资源非常有效。</p><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><p>一些公用的静态资源（比如jquery、angular、bootstrap等）。使用这些公用的静态资源一方面可以增加页面文件并发下载量，另一方面还能和其他网站共享这些缓存。</p><h2 id="尽可能缓存静态资源"><a href="#尽可能缓存静态资源" class="headerlink" title="尽可能缓存静态资源"></a>尽可能缓存静态资源</h2><p>尽可能延长静态资源的缓存时间，不但能使频繁访问网站的用户更快的访问，还能减轻服务器压力。至于静态资源的更新，则可以结合<code>修改文件名和+版本号</code>的方式来确保资源更新时，用户会加载到新的内容。</p><h2 id="尽可能将CSS文件放在页面头部，JavaScript放在页面底部"><a href="#尽可能将CSS文件放在页面头部，JavaScript放在页面底部" class="headerlink" title="尽可能将CSS文件放在页面头部，JavaScript放在页面底部"></a>尽可能将CSS文件放在页面头部，JavaScript放在页面底部</h2><p>应为javascript在加载的时候会出现阻塞，所以为避免出现阻塞页面渲染，让页面页面出现长时间空白，尽量将Javascript文件放在页面底部。</p><h1 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h1><h2 id="关键渲染路径"><a href="#关键渲染路径" class="headerlink" title="关键渲染路径"></a>关键渲染路径</h2><p><img data-src="https://sfault-image.b0.upaiyun.com/315/063/3150630289-5766c21f45ef4_articlex" alt="CRP"></p><blockquote><p>上图是浏览器渲染的关键路径，首先，让我们从浏览器解析一个页面开始吧。</p></blockquote><ul><li><em><strong>转化</strong></em>： 浏览器从磁盘或网络读取 HTML 的原始字节，浏览器会将这段原始文件按照相应编码规范进行解码（现在一般为 utf-8）。</li><li><em><strong>符号化</strong></em>： 根据 W3C 标准转化为对应的符号（一般在尖括号内）。</li><li><em><strong>DOM 构建</strong></em>：HTML 解析器会解析其中的 tag 标签，生成 token ，遇到 CSS 或 JS 会发送相应请求。HTML 解析时阻塞主进程的，CSS 一般也是阻塞主进程的（媒体查询时例外），也就是说它们在解析过程中是无法做出响应的。而 JS 手动添加 async 后达到异步加载，根据 token 生成相应 DOM 树。</li><li><em><strong>CSSDOM 构建</strong></em>：添加 CSS 样式生成 CSSDOM 树。</li><li><em><strong>渲染树构建</strong></em>：从 DOM 树的根节点开始，遍历每个可见的节点，给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，连带其内容及计算的样式。</li><li><em><strong>样式计算</strong></em>：浏览器会将所有的相对位置转换成绝对位置等一系列的样式计算。</li><li><em><strong>布局</strong></em>：浏览器将元素进行定位、布局。</li><li><em><strong>绘制</strong></em>：绘制元素样式，颜色、背景、大小、边框等。</li><li><em><strong>合成</strong></em>：将各层合成到一起、显示在屏幕上。</li></ul><p><img data-src="https://sfault-image.b0.upaiyun.com/951/893/951893846-5766c220cc68c_articlex"></p><p>如果我们是做一个动画，一般会用 JS 更改相应样式，接着浏览器就会经历 JS 运行、样式计算、布局、绘制、合成等多个重要步骤（后面还会讲到这个步骤实际过程中可以更长或者更短）。那么要做的优化就是在这几个步骤中进行优化并且尽量去掉中间的耗时步骤。<br><img data-src="https://sfault-image.b0.upaiyun.com/396/985/3969857354-5766c2228ceed_articlex"></p><h3 id="优化JavaScript的执行"><a href="#优化JavaScript的执行" class="headerlink" title="优化JavaScript的执行"></a>优化JavaScript的执行</h3><ul><li>函数的输入事件处理</li><li>优化处理</li></ul><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><ul><li>减小选择器的复杂性</li><li>减少样式的计算量</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li>避免触发布局</li><li>使用Flexbox布局</li><li>避免强制同步布局事件</li><li>避免快速连续的布局</li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><ul><li>提升移动或渐变元素的绘制层</li><li>仔细规划动画和简化绘制的复杂度</li></ul><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul><li>使用transform/opacity实现动画效果</li><li>管理渲染层、避免过多数量的层</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>关注趋势，今天很多的性能瓶颈很可能在将来都不再是问题。</li><li>充分利用工具 Chrome DevTools。</li><li>不要进行微优化，有时花上很短的带来的性能提升却很小，对于日常快速迭代的业务是没必要这样做的。</li></ul><p>[更多详细关于页面渲染的内容，请查看][Performance]<br>[Performance]:<a href="https://segmentfault.com/a/1190000005754881">https://segmentfault.com/a/1190000005754881</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谈到web性能优化，一般我们可以把它分为两个部分来讲，页面加载（Page Speed）和页面渲染（Page Performance）。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://weizhimiao.github.io/categories/Web/"/>
    
    
    <category term="Web" scheme="https://weizhimiao.github.io/tags/Web/"/>
    
    <category term="性能优化" scheme="https://weizhimiao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
